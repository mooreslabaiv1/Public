dut: weighted_round_robin
intf_1: &rr_if_1
  intf_name: rr_if
  intf_code: "interface rr_if #(parameter N = 32, parameter ID_BITS = 5) (input logic\
    \ clk, input logic rst);\n\n  // Request signals (input to DUT)\n  logic [N-1:0]\
    \ req;\n  logic         ack;\n\n  // Grant signals (output from DUT)\n  logic\
    \ [N-1:0] gnt_w;\n  logic [ID_BITS-1:0] gnt_id;\n\n  // Clocking block for UVM\
    \ driver/monitor\n  clocking cb @(posedge clk);\n    default input #1step output\
    \ #1step;\n    input  gnt_w, gnt_id;\n    output req, ack;\n  endclocking\n\n\
    \  // Modport for driver\n  modport drv (\n    input  clk, rst,\n    output req,\
    \ ack,\n    input  gnt_w, gnt_id,\n    clocking cb\n  );\n\n  // Modport for monitor\n\
    \  modport mon (\n    input  clk, rst,\n    input  req, ack, gnt_w, gnt_id,\n\
    \    clocking cb\n  );\n\nendinterface"
  intf_sig_list:
  - [req, in, 32]
  - [ack, in, 1]
  - [gnt_w, out, 32]
  - [gnt_id, out, 5]
  drv_name: rr_driver
  mon_name: rr_monitor
agent_1: &rr_agent
  agent_name: rr_agent
  intf: *rr_if_1
intf_2: &prio_if_2
  intf_name: prio_if
  intf_code: "interface prio_if #(parameter PRIORITY_W = 4, parameter ID_BITS = 5)\
    \ (input logic clk, input logic rst);\n\n  // Priority update signals (input to\
    \ DUT)\n  logic [PRIORITY_W-1:0] prio;\n  logic [ID_BITS-1:0]    prio_id;\n  logic\
    \                  prio_upt;\n\n  // Clocking block for UVM driver/monitor\n \
    \ clocking cb @(posedge clk);\n    default input #1step output #1step;\n    output\
    \ prio, prio_id, prio_upt;\n  endclocking\n\n  // Modport for driver\n  modport\
    \ drv (\n    input  clk, rst,\n    output prio, prio_id, prio_upt,\n    clocking\
    \ cb\n  );\n\n  // Modport for monitor\n  modport mon (\n    input  clk, rst,\n\
    \    input  prio, prio_id, prio_upt,\n    clocking cb\n  );\n\nendinterface"
  intf_sig_list:
  - [prio, in, 4]
  - [prio_id, in, 5]
  - [prio_upt, in, 1]
  drv_name: prio_driver
  mon_name: prio_monitor
agent_2: &prio_update_agent
  agent_name: prio_update_agent
  intf: *prio_if_2
agents:
- *rr_agent
- *prio_update_agent
tb_top:
  mod_name: weighted_round_robin_tb_top
  sv_code: "module weighted_round_robin_tb_top;\n\n  import uvm_pkg::*;\n  import\
    \ weighted_round_robin_test_pkg::*;\n  `include \"uvm_macros.svh\"\n\n  logic\
    \ clk;\n  logic rst;\n\n  clk_rst_if clk_rst_if_inst ();\n  assign clk = clk_rst_if_inst.clk;\n\
    \  assign rst = clk_rst_if_inst.rst;\n  rr_if rr_if_inst( .clk(clk), .rst(rst)\
    \ );\n  prio_if prio_if_inst( .clk(clk), .rst(rst) );\n\n  weighted_round_robin\
    \ #(.N(32), .ID_BITS(5), .PRIORITY_W(4)) dut (\n    .clk(clk),\n    .rst(rst),\n\
    \    .req(rr_if_inst.req),\n    .ack(rr_if_inst.ack),\n    .gnt_w(rr_if_inst.gnt_w),\n\
    \    .gnt_id(rr_if_inst.gnt_id),\n    .prio(prio_if_inst.prio),\n    .prio_id(prio_if_inst.prio_id),\n\
    \    .prio_upt(prio_if_inst.prio_upt)\n  );\n\n  initial begin\n    uvm_config_db#(virtual\
    \ rr_if)::set(null, \"\", \"rr_if\", rr_if_inst);\n    uvm_config_db#(virtual\
    \ prio_if)::set(null, \"\", \"prio_if\", prio_if_inst);\n    uvm_config_db#(virtual\
    \ clk_rst_if)::set(null, \"\", \"clk_rst_if\", clk_rst_if_inst);\n    run_test();\n\
    \  end\n\n  initial begin\n    $timeformat(-9, 3, \"ns\");\n  end\n\n  initial\
    \ begin\n    string testname;\n    if (!$value$plusargs(\"UVM_TESTNAME=%s\", testname))\
    \ begin\n      testname = \"default\";\n    end\n    $dumpfile($sformatf(\"testbench_%s.vcd\"\
    , testname));\n    $dumpvars(0, weighted_round_robin_tb_top);\n  end\n\nendmodule\
    \ : weighted_round_robin_tb_top\n"
DUT_desc: "{\n  \"signals\": [\n    \"port_name='ack' direction='input' original_port_name='ack'\
  \ protocol_ref=[] width_expr='[]' is_vector=False comments='Round Robin Interface\
  \ \\u2013 Handshake: 1 means \\\"accepted\\\" this cycle'\",\n    \"port_name='clk'\
  \ direction='input' original_port_name='clk' protocol_ref=[] width_expr='[]' is_vector=False\
  \ comments='Misc'\",\n    \"port_name='gnt_id' direction='output' original_port_name='gnt_id'\
  \ protocol_ref=[] width_expr='[ID_BITS-1:0]' is_vector=True comments='Round Robin\
  \ Interface \\u2013 Encoded ID of granted request'\",\n    \"port_name='gnt_w' direction='output'\
  \ original_port_name='gnt_w' protocol_ref=[] width_expr='[N-1:0]' is_vector=True\
  \ comments='Round Robin Interface \\u2013 One-hot grant'\",\n    \"port_name='prio'\
  \ direction='input' original_port_name='prio' protocol_ref=[] width_expr='[PRIORITY_W-1:0]'\
  \ is_vector=True comments='Dynamic Priority/Weight Update Interface \\u2013 New\
  \ priority value'\",\n    \"port_name='prio_id' direction='input' original_port_name='prio_id'\
  \ protocol_ref=[] width_expr='[ID_BITS-1:0]' is_vector=True comments='Dynamic Priority/Weight\
  \ Update Interface \\u2013 Which requestor to update'\",\n    \"port_name='prio_upt'\
  \ direction='input' original_port_name='prio_upt' protocol_ref=[] width_expr='[]'\
  \ is_vector=False comments='Dynamic Priority/Weight Update Interface \\u2013 Update\
  \ strobe'\",\n    \"port_name='req' direction='input' original_port_name='req' protocol_ref=[]\
  \ width_expr='[N-1:0]' is_vector=True comments='Round Robin Interface \\u2013 Request\
  \ signals'\",\n    \"port_name='rst' direction='input' original_port_name='rst'\
  \ protocol_ref=[] width_expr='[]' is_vector=False comments='Misc'\"\n  ],\n  \"\
  description\": \"Micro -Architecture Specification (MAS): \\nWeighted Round Robin\
  \ (WRR) Arbiter  \\nTable of Contents  \\n1. Document Control  \\n2. Introduction\
  \  \\n3. Contents Overview  \\n4. High -Level IP Overview  \\n5. IP Input/Output\
  \ Ports  \\n6. Internal Sub -Block Descriptions  \\n7. Data Path Details  \\n8.\
  \ Control Path Details  \\n9. Pipeline & Timing  \\n10. Clocking & Reset  \\n11.\
  \ Registers & Configuration  \\n12. Performance  \\n13. Error Correction / Security\
  \ / Safety  \\n14. Advanced Debug & QoS  \\n15. Parameterization & Configurability\
  \  \\n16. Error Handling & Debug Hooks  \\n17. Example Scenarios & Waveforms  \\\
  n18. Implementation & RTL Notes  \\n19. Limitations & Future Extensions  \\n20.\
  \ Revision History  \\n21. Errata  \\n22. Appendix: PlantUML Diagrams  \\n1. Document\
  \ Control  \\n1.1 Title / ID  \\nTitle : Weighted Round Robin Arbiter Micro -Architecture\
  \ Specification  \\nDocument ID : WRR -MAS -001  \\n1.2 Version / Revision  \\n\\\
  u2022 Version : v1.2  \\n\\u2022 Date : 2025 -04-22 \\n1.3 Owner / Authors  \\n\\\
  u2022 Primary Owner : MooresLabAI RTL Design Team  \\n\\u2022 Contributors : Micro\
  \ -Architecture Group  \\n1.4 Approvals  \\n\\u2022 Design Lead: Pending   \\n\\\
  u2022 Verification Lead: Pending   \\n\\u2022 System Architect: Pending  \\n1.5\
  \ Distribution / Confidentiality  \\n\\u2022 Internal Use Only  \\n\\u2022 Confidential\
  \ and proprietary \\u2014 Not for external distribution  \\n2. Introduction  \\\
  n2.1 Purpose and Scope  \\nThis document provides a complete specification of the\
  \ internal logic and operation of the \\nWeighted Round Robin (WRR) arbitration\
  \ IP. It defines the architectural components, \\ncontrol paths, data paths, parameterization,\
  \ and runtime behavior necessary to im plement \\nand verify the IP.  \\nThe WRR\
  \ arbiter provides fair, weighted access arbitration across multiple requestors.\
  \ It is \\nsuitable for use in Network -on-Chip (NoC) routers, memory controllers,\
  \ shared buses, and \\nother interconnect scenarios where bandwidth differentiation\
  \ and fairness are required.  \\n2.2 References  \\n\\u2022 IEEE JSAC Paper: \\\"\
  Weighted Round -Robin Cell Multiplexing in a General -Purpose \\nATM Switch Chip\\\
  \"  \\n2.3 Document Organization  \\n\\u2022 Sections 1 \\u20133 provide context\
  \ and motivation.  \\n\\u2022 Sections 4 \\u201316 detail the functional behavior\
  \ and structural design.  \\n\\u2022 Sections 17 \\u201321 offer test scenarios,\
  \ implementation notes, and historical changes.  \\n\\u2022 Section 22 provides\
  \ visualization diagrams using PlantUML.  \\n3. Contents Overview  \\nDesign Goals\
  \  \\n\\u2022 Fairness : Guarantee all requestors receive proportional bandwidth\
  \ access  \\n\\u2022 Flexibility : Support runtime updates of requestor priorities\
  \  \\n\\u2022 Efficiency : Ensure minimal arbitration latency (1 cycle typical)\
  \  \\n\\u2022 Scalability : Enable support for 4 to 64 requestors without architectural\
  \ changes  \\nKey Features  \\n\\u2022 Weighted round -robin scheduling algorithm\
  \  \\n\\u2022 Priority (weight) update interface  \\n\\u2022 Round -robin pointer\
  \ for fairness  \\n\\u2022 8-bit per -requestor credit counters to enforce weight\
  \ -based scheduling  \\n\\u2022 One -hot and encoded ID grant outputs  \\n\\u2022\
  \ Arbitration result within 1 cycle under typical conditions  \\n\\u2022 Refill\
  \ credit logic for zero -starvation guarantee  \\n4. High -Level IP Overview  \\\
  n4.1 Key Features  \\n\\u2022 Weight -Based Arbitration : Each requestor has a priority/weight\
  \ influencing how \\nfrequently it is granted access.  \\n\\u2022 Runtime Priority\
  \ Update : Priorities can be updated on -the-fly without stalling \\narbitration.\
  \  \\n\\u2022 Credit -Based Scheduling : Credits are decremented upon grant and\
  \ refilled when \\nexhausted.  \\n\\u2022 Zero -Starvation : The round -robin pointer\
  \ ensures all requestors will eventually be \\ngranted.  \\n\\u2022 Combinational\
  \ Arbitration : Arbitration is purely combinational for low -latency \\nscheduling.\
  \  \\n4.2 Top -Level Block Diagram  \\n \\n \\n \\n4.3 Module / File Hierarchy \
  \ \\n\\u2022 wrr_arbiter.sv: Top -level arbiter and interface wrapper  \\n\\u2022\
  \ wrr_priority_mgr.sv: Handles the priority register updates  \\n\\u2022 wrr_credit_logic.sv:\
  \ Tracks credit counters and performs replenishment  \\n\\n\\u2022 wrr_arbitration.sv:\
  \ Combinational arbiter with round -robin rotation  \\n4.4 Design Constraints  \\\
  n\\u2022 Must operate within a single synchronous domain  \\n\\u2022 Should maintain\
  \ cycle -accurate grant latency  \\n\\u2022 Should not exceed critical path delay\
  \ for target frequency (e.g., < 1 ns for 1 GHz)  \\n5. IP Input/Output Ports  \\\
  nThis section describes each input and output port, including signal width, function,\
  \ and \\ntiming characteristics.  \\nSignal  Dir Width  Description  \\nclk in 1\
  \ Clock signal. Rising edge driven synchronous design.  \\nrst in 1 Active -high\
  \ synchronous reset.  \\nreq in N Requestor request lines. One bit per requestor.\
  \  \\nack  in 1 Acknowledgment that current grant was accepted.  \\nprio  in PRIORITY_W\
  \  New priority value to be written to prio_reg.  \\nprio_id  in ID_BITS  Address\
  \ of the requestor to which new priority is set.  \\nprio_upt  in 1 Priority update\
  \ strobe signal.  \\ngnt_w  out N One -hot vector indicating which requestor is\
  \ granted.  \\ngnt_id  out ID_BITS  Encoded ID of the requestor granted this cycle.\
  \  \\nTiming Description:  \\n\\u2022 Inputs are sampled on the rising edge of clk.\
  \  \\n\\u2022 Outputs are valid during the same cycle as their corresponding inputs.\
  \  \\n\\u2022 Arbitration occurs every cycle. Priority updates and ack can be asserted\
  \ \\nsimultaneously without functional hazard.  \\n6. Internal Sub -Block Descriptions\
  \  \\n6.1 Priority Register File  \\nFunction :  \\n\\u2022 Stores a 4-bit weight\
  \ (priority) per requestor.  \\n\\u2022 Controls how often a requestor can be granted\
  \ relative to others.  \\n\\u2022 Affects credit replenishment.  \\nImplementation\
  \ :  \\n\\u2022 Implemented as a register array: logic [PRIORITY_W -1:0] prio_reg[N\
  \ -1:0]  \\nParameterization :  \\n\\u2022 Width: PRIORITY_W (typically 4)  \\n\\\
  u2022 Depth: N (default 32)  \\nUpdate :  \\n\\u2022 Triggered by prio_upt  \\n\\\
  u2022 Updated entry is determined by prio_id  \\n\\u2022 Simultaneous prio_upt and\
  \ ack is allowed  \\n6.2 Credit Manager  \\nFunction :  \\n\\u2022 Manages internal\
  \ credit counters for each requestor.  \\n\\u2022 Each grant reduces the corresponding\
  \ credit by 1.  \\n\\u2022 When no requestor is eligible, all credits are replenished\
  \ to prio + 1.  \\nImplementation :  \\n\\u2022 Implemented as a register array:\
  \ logic [CREDIT_W -1:0] credit_r[N -1:0]  \\nParameterization :  \\n\\u2022 Width:\
  \ CREDIT_W (typically 8)  \\n\\u2022 Depth: N (default 32)  \\nBehavior : \\n\\\
  u2022 Credit decremented only for the granted requestor upon ack=1.  \\n\\u2022\
  \ Credits are replenished when no eligible requestor is found.  \\n6.3 Arbiter Logic\
  \ (Grant Generator)  \\nFunction :  \\n\\u2022 Determines which requestor gets access\
  \ each cycle.  \\n\\u2022 Uses a rotating pointer and credit eligibility.  \\nImplementation\
  \ :  \\n\\u2022 Rotating pointer scanned for (req[i] == 1 && credit[i] > 0)  \\\
  n\\u2022 If found, gnt_id = i and gnt_w[i] = 1  \\n\\u2022 Pointer moves to (i +\
  \ 1) % N for next cycle  \\nFSM States : \\n\\u2022 ARBITRATION: Regular match and\
  \ grant generation  \\n\\u2022 REPLENISH: Triggered when no eligible requestor \
  \ \\n7. Data Path Details  \\n7.1 Data Flow  \\n \\n \\n1. Incoming req[N -1:0]\
  \ sampled each cycle.  \\n2. Combinational logic checks credit + request.  \\n3.\
  \ If match:  \\na. Decrement credit, issue grant.  \\n4. If no match:  \\na. Refill\
  \ credit with prio + 1, no grant.  \\n5. Always increment pointer after decision.\
  \  \\n\\n7.2 Bit Widths & Encodings  \\nSignal  Width  Notes  \\nreq N One -hot\
  \ per requestor  \\ngnt_w  N One -hot vector output  \\ngnt_id  ID_BITS  Binary\
  \ encoded ID  \\ncredit  CREDIT_W  8-bit unsigned counter  \\npriority  PRIORITY_W\
  \  4-bit unsigned priority per requestor  \\n7.3 Buffering / Queues  \\n\\u2022\
  \ No FIFOs or queues are used.  \\n\\u2022 State held entirely in synchronous flip\
  \ -flops.  \\n8. Control Path Details  \\n8.1 Status / Debug  \\nThe WRR arbiter\
  \ provides visibility into its internal operational state. For debug and \\nobservability\
  \ purposes, the following signals can be probed:  \\n\\u2022 credit_r[N -1:0]: Current\
  \ credit value for each requestor  \\n\\u2022 prio_reg[N -1:0]: Priority register\
  \ value for each requestor  \\n\\u2022 pointer_r: Current position of round -robin\
  \ pointer  \\n\\u2022 gnt_w, gnt_id: Current grant decision  \\nAll these signals\
  \ can optionally be exposed to a debug bus or system -level trace \\nmechanism.\
  \  \\n8.2 Global Control FSM  \\nThe WRR arbiter operates with a simple, two -mode\
  \ FSM:  \\nState  Description  \\nARBITRATION  Checks req and credit arrays to find\
  \ eligible requestor.  \\nREPLENISH  Triggered when no requestor is eligible. Refills\
  \ all credits from prio+1.  \\nTransition Logic:  \\n\\u2022 If at least one (req[i]\
  \ && credit[i] > 0) is found \\u2192 remain in ARBITRATION  \\n\\u2022 Else \\u2192\
  \ enter REPLENISH  \\n\\u2022 FSM resets to ARBITRATION after refill  \\n \\n \\\
  n \\n \\n8.3 Error / Security Handling  \\nThe IP does not include explicit security\
  \ features, ECC, or error reporting. Integrators are \\nencouraged to wrap the module\
  \ with any of the following (if required):  \\n\\u2022 Range checkers for prio_id\
  \  \\n\\n\\u2022 Debug assertions for illegal values  \\n\\u2022 Wrapper -based\
  \ boundary checks on configuration inputs  \\n9. Pipeline & Timing  \\n9.1 Pipeline\
  \ Stage Breakdown  \\nStage  Function  \\n0 Combinational arbitration  \\n1 Sequential\
  \ update of credits, pointer  \\nThe output grant signals (gnt_w, gnt_id) are produced\
  \ in Stage 0.  \\n9.2 Latency  \\n\\u2022 Best -case latency : 1 cycle from req\
  \ to gnt  \\n\\u2022 Worst -case latency : 2 cycles if credit refill is needed \
  \ \\n9.3 Hazards & Ordering  \\n\\u2022 No transaction ordering is required  \\\
  n\\u2022 All requestors are treated independently  \\n\\u2022 Hazard -free credit\
  \ update due to sequential flopping  \\n9.4 Multi -Power or Multi -Voltage Domains\
  \  \\n\\u2022 Not supported  \\n\\u2022 Module is designed for single clock, single\
  \ power domain operation  \\n10. Clocking & Reset  \\n10.1 Clock Domains  \\n\\\
  u2022 Only a single clock domain is supported  \\n\\u2022 No crossing logic or asynchronous\
  \ FIFOs  \\n10.2 Reset Types  \\n\\u2022 Synchronous reset (rst) active high  \\\
  n\\u2022 All internal state (credits, priorities, pointer) is reset synchronously\
  \  \\n10.3 Reset / Startup Sequence  \\nCycle  Signal  Value/Action  \\n0 rst=1\
  \  Priority registers cleared (0)  \\n  Credit registers initialized to 1  \\n \
  \ Pointer reset to 0  \\n1 rst=0  Ready to begin arbitration cycle  \\n11. Registers\
  \ & Configuration  \\n11.1 Configuration  \\n\\u2022 The WRR arbiter is configured\
  \ entirely via sideband signals:  \\no prio, prio_id, and prio_upt  \\n\\u2022 Priority\
  \ updates can happen at any time and do not interfere with arbitration  \\n\\u2022\
  \ No memory -mapped configuration interface is present  \\n11.2 Register Map  \\\
  nRegister  Description  Access Type  Width  \\nN/A  Configuration via wires only\
  \  N/A  N/A  \\nFor integration into register -based systems, a wrapper may be created\
  \ externally.  \\n12. Performance  \\n12.1 Throughput / Bandwidth  \\n\\u2022 Capable\
  \ of granting one request per cycle  \\n\\u2022 Arbitration is pipelined such that\
  \ input is accepted every cycle  \\n12.2 Latency  \\nCondition  Latency (cycles)\
  \  \\nNormal operation  1 \\nCredit refill  2 \\n12.3 Resource Utilization  \\nComponent\
  \  Approx. Resources  \\nPriority registers  N \\u00d7 4 bits  \\nCredit counters\
  \  N \\u00d7 8 bits  \\nPointer register  log2(N) bits  \\n12.4 Scalability  \\\
  n\\u2022 Works efficiently up to N = 64  \\n\\u2022 For higher N, hierarchical WRR\
  \ or pipelined arbitration layers are recommended  \\n13. Error Correction / Security\
  \ / Safety  \\n13.1 ECC or Data Integrity  \\nThe WRR arbiter IP does not implement\
  \ any ECC or parity protection over its internal \\nstorage arrays, including: \
  \ \\n\\u2022 Priority registers (prio_reg)  \\n\\u2022 Credit counters (credit_r)\
  \  \\nBecause the IP uses only small, flip -flop based storage per requestor (e.g.,\
  \ 4 -bit priority \\nand 8 -bit credit), the design assumes that soft error rates\
  \ are negligible in target processes \\nand applications. If used in environments\
  \ with high radiation exposur e (e.g., aerospace), \\nwrapper -level ECC is recommended.\
  \  \\n13.2 Security Model  \\nThis IP does not differentiate secure vs. non -secure\
  \ domains, nor does it support \\nencryption, authentication, or isolation mechanisms.\
  \ All configuration and control \\ninterfaces are treated equally and lack access\
  \ protection.  \\nIntegration suggestions for secure contexts:  \\n\\u2022 Route\
  \ control interfaces through a trust zone or secure controller.  \\n\\u2022 Include\
  \ access qualifiers in upper -level memory maps if exposed via register \\nwrappers.\
  \  \\n13.3 Functional Safety  \\nThe arbiter does not implement fault containment,\
  \ fault detection, or recovery logic. It \\ndoes not support ISO 26262 or ASIL compliance\
  \ features internally. If used in safety -\\ncritical applications, the following\
  \ must be handled externally:  \\n\\u2022 Fault detection and reporting  \\n\\u2022\
  \ Redundant path arbitration (dual lock -step modules)  \\n\\u2022 Diagnostic test\
  \ sequences for pointer, credit, and priority logic  \\n14. Advanced Debug & QoS\
  \  \\n14.1 Debug / Trace  \\nThe WRR IP is optionally compatible with system debug\
  \ strategies. Although it does not \\ninclude built -in trace logic, designers may\
  \ expose the following for debug:  \\n\\u2022 gnt_w: Active grant vector  \\n\\\
  u2022 gnt_id: Active grant encoded ID  \\n\\u2022 pointer_r: Round -robin pointer\
  \ position  \\n\\u2022 prio_reg[N]: Priority values per requestor  \\n\\u2022 credit_r[N]:\
  \ Current credit per requestor  \\nOptional counters (add -on):  \\n\\u2022 grant_count[N]:\
  \ Per -requestor grant counts for QoS accounting  \\nDebug outputs may be used to\
  \ create live QoS dashboards or validate WRR fairness over \\nsimulation cycles.\
  \  \\n14.2 QoS / Scheduling  \\nThis IP enforces a weighted round robin  (WRR) policy\
  \ where each requestor receives a \\nnumber of grants proportional to its priority\
  \ weight.  \\nScheduling strategy:  \\n\\u2022 Each requestor is credited with prio\
  \ + 1 tokens when its credit reaches 0.  \\n\\u2022 Requestors consume 1 credit\
  \ per grant.  \\n\\u2022 Round -robin pointer ensures even high -weight requestors\
  \ don\\u2019t monopolize \\nbandwidth.  \\nFairness is built -in: \\n\\u2022 Requestors\
  \ with priority = 0 do not get replenished (unless explicitly updated).  \\n\\u2022\
  \ No starvation due to pointer advancement even during refill.  \\nThis model ensures\
  \ proportional access across bursty and latency -sensitive traffic \\npatterns.\
  \  \\n15. Parameterization & Configurability  \\nParameter  Description  Default\
  \  \\nN Number of requestors supported  32 \\nPRIORITY_W  Width of priority register\
  \ (bits)  4 \\nCREDIT_W  Width of credit counters  8 \\nID_BITS  Number of bits\
  \ required to encode N requestors  5 \\nParameter Constraints  \\n\\u2022 N must\
  \ be a power of 2 for pointer wraparound logic.  \\n\\u2022 CREDIT_W must be wide\
  \ enough to handle expected max weights.  \\n\\u2022 PRIORITY_W \\u2265 2 is recommended\
  \ to allow more than binary weight assignment.  \\nEffects  \\nParameter  Effect\
  \ on Design  \\nHigher N  Increases area and logic fanout  \\nWider PRIORITY_W \
  \ Enables finer -grained bandwidth control  \\nWider CREDIT_W  Allows higher sustained\
  \ weights without overflow  \\n16. Error Handling & Debug Hooks  \\n16.1 Assertions\
  \ / Monitors  \\nThe following assertions are recommended for integration -level\
  \ or formal verification:  \\n\\u2022 assert(!(prio_upt && prio_id >= N));  \\nEnsures\
  \ no out -of-bounds writes to the priority register.  \\n\\u2022 assert(req != 0\
  \ -> gnt_w != 0);  \\nGuarantees progress: if requestors are active, eventually\
  \ a grant must be issued.  \\n\\u2022 assert(gnt_w[gnt_id] == 1);  \\nVerifies that\
  \ the encoded ID matches the one -hot grant.  \\n\\u2022 assert(pointer_r < N);\
  \  \\nEnsures the pointer never exceeds the valid range.  \\nThese assertions may\
  \ be embedded in RTL testbenches or formal environments.  \\n16.2 Error Reporting\
  \  \\nThere are no error output signals in the default IP. If required, integrators\
  \ may:  \\n\\u2022 Add a prio_update_error output if prio_id >= N  \\n\\u2022 Add\
  \ an illegal_ack output if grant is acknowledged while inactive  \\n16.3 Integration\
  \ with System Debug  \\nFor SoC -level debug, WRR state may be exposed via:  \\\
  n\\u2022 JTAG -based register snapshots (e.g., dbg_gnt_id, dbg_pointer, etc.)  \\\
  n\\u2022 AXI/APB sideband debug registers (with read -only priority/credit counters)\
  \  \\n\\u2022 Trace logs capturing gnt_id, req, and ack across time for bandwidth\
  \ profiling  \\n17. Example Scenarios & Waveforms  \\nThis section illustrates cycle\
  \ -by-cycle arbitration and dynamic behavior under various \\nrequest and configuration\
  \ patterns.  \\nScenario A \\u2014 Basic Arbitration with Multiple Requests  \\\
  nInitial Conditions : \\n\\u2022 Priorities: #0=4, #1=4, #2=4  \\n\\u2022 Credits:\
  \ All initialized to 1  \\n\\u2022 Requests: Multiple active  \\nCycle  clk req\
  \ ack  prio_up t prio_id  prio  gnt_w  gnt_id  Notes  \\n0 \\u2191 0110  0 0 --\
  \ -- 0010  0x1 #1 has credit and \\nrequests  \\n1 \\u2191 0110  1 0 -- -- 0100\
  \  0x2 #1 acked, #2 gets grant  \\n2 \\u2191 0110  1 0 -- -- 0000  0x0 No eligible\
  \ req \\u2192 refill  \\n3 \\u2191 0110  0 0 -- -- 0010  0x1 Credit refilled, cycle\
  \ \\nrestarts  \\nScenario B \\u2014 Mid -Stream Priority Update  \\nInitial Conditions\
  \ : \\n\\u2022 Priorities: #0=2, #1=2, #2=2  \\nCycl\\ne clk Edge  req ack  prio_upt\
  \  prio_id  prio  gnt_w  gnt_id  Notes  \\n0 Rising  0101  0 0 -- -- 0001  0x0 #0\
  \ granted first  \\n1 Falling  0101  0 1 2 8 0001  0x0 Update #2\\u2019s \\npriority\
  \ to 8  \\n2 Rising  0101  1 0 -- -- 0100  0x2 #2 now has \\nhigher weight \\nand\
  \ wins next  \\nScenario C \\u2014 Priority Update During ack  \\nCycle  clk req\
  \ ack  prio_upt  prio_id  prio  gnt_id  Notes  \\n0 \\u2191 0011  1 1 1 6 0x0 Valid\
  \ priority update during \\nack  \\n1 \\u2191 0011  0 0 -- -- 0x1 #1 is now higher\
  \ weight, gets \\ngrant  \\nScenario D \\u2014 Weighted Round Robin  \\nPriorities\
  \ :  \\n\\u2022 #0=2, #1=8, #2=1  \\nBehavior : #1 gets more frequent grants due\
  \ to higher weight.  \\nCycle  clk req ack  gnt_w  gnt_id  Notes  \\n0 \\u2191 111\
  \  0 0010  0x1 #1 wins \\u2014 highest weight  \\n1 \\u2191 111  1 0001  0x0 #0\
  \ gets next  \\n2 \\u2191 111  1 0100  0x2 #2 gets a turn  \\n3 \\u2191 111  0 0010\
  \  0x1 #1 back due to higher weight  \\nScenario E \\u2014 Dynamic Weight Update\
  \ Under Load  \\nCycle  clk req ack  prio_id  prio  prio_upt  gnt_w  gnt_id  Notes\
  \  \\n0 \\u2191 111  0 -- -- 0 0010  0x1 Initial \\u2014 #1 wins  \\n1 \\u2191 111\
  \  1 0 8 1 0100  0x2 #0 boosted to \\nhigh weight  \\n2 \\u2191 111  0 1 1 1 0001\
  \  0x0 #1 deprioritized  \\n3 \\u2191 111  1 -- -- 0 0001  0x0 #0 repeatedly \\\
  nwins now  \\n18. Implementation & RTL Notes  \\n18.1 Coding Style & Synthesis \
  \ \\n\\u2022 RTL uses always_comb for next -state and arbitration logic  \\n\\u2022\
  \ All state (pointers, credits, prio_reg) is stored using always_ff @ (posedge clk)\
  \  \\n\\u2022 Lint -clean under standard tools  \\n18.2 Power Optimization  \\n\\\
  u2022 Idle state detection for clock gating can be added externally  \\n\\u2022\
  \ All logic is active as long as any req is active  \\n18.3 DFT & Test  \\n\\u2022\
  \ No internal memory \\u2192 no BIST required  \\n\\u2022 Fully scan -friendly \
  \ \\n\\u2022 Credit, prio, and pointer registers are DFT -visible  \\n19. Limitations\
  \ & Future Extensions  \\nKnown Limitations  \\n\\u2022 Does not scale well beyond\
  \ 128 requestors without tree or multi -stage WRR  \\n\\u2022 No support for burst\
  \ mode grants or fixed -latency slots  \\n\\u2022 No built -in test/debug trace\
  \ mechanisms  \\nFuture Work  \\n\\u2022 Hierarchical WRR for large -scale arbitration\
  \  \\n\\u2022 Integration of optional APB interface for config/debug  \\n\\u2022\
  \ Trust -level separation for secure/unsecure request domains  \\n\\u2022 Programmable\
  \ credit step (currently fixed as prio + 1)  \\n20. Revision History  \\nVersio\\\
  nn Date  Author(s)  Changes  \\nv1.0  2025 -03-\\n25 Architecture \\nTeam  Initial\
  \ specification  \\nv1.1  2025 -04-\\n11 Simon  Fixed credit logic, pointer, ack+prio\
  \ allowed  \\nv1.2  2025 -04-\\n28 Juliet  Fully verbose MAS with diagrams, inline\
  \ \\ntables  \\n21. Errata  \\n\\u2022 None  as of v1.2\"\n}"
uvm_timeout: '3000000'
eda_vendor: SYNOPSYS
