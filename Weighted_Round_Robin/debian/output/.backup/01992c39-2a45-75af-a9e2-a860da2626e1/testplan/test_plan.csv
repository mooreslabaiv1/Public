Name,Description,Steps,Checkers,Goals,Related_Feature,Citations
fsm_synchronous_reset_and_initialization_arbitration_basic,"Verify that asserting the synchronous reset (rst=1) on clk rising edge correctly initializes all internal FSM and module state: priority registers to 0, credit counters to 1, round-robin pointer to 0, and outputs (gnt_w, gnt_id) to reset values (typically 0). Confirm that after deasserting reset (rst=0), the FSM transitions to the ARBITRATION state and the module is ready to arbitrate requests and issue grants as per normal operation. Ensure that a valid grant is issued to an active requestor immediately after reset deassertion, and that no grants are issued during reset.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for at least 2 clk cycles.
3) During rst=1, drive all other inputs (req, ack, prio, prio_id, prio_upt) to 0.
4) Observe that outputs gnt_w and gnt_id are at reset values (typically 0).
5) Deassert rst (rst=0) on a clk rising edge.
6) Immediately after rst=0, drive req with a single active bit (e.g., req[0]=1, others=0), keep ack=0 and other inputs at 0.
7) Observe gnt_w and gnt_id for at least 2 cycles after reset deassertion.","1) During rst=1:
   - gnt_w == 0 (no grants issued)
   - gnt_id == 0 (or a defined reset value per spec)
2) On first clk after rst=0:
   - FSM is in ARBITRATION state
   - A grant is issued to the active req (gnt_w one-hot, gnt_id matches index)
3) Confirm that no grant is issued during rst=1.
4) Confirm that the FSM does not enter REPLENISH state immediately after reset.
5) No spurious or invalid gnt_w/gnt_id values during or immediately after reset.","Functional coverage:
  - cp_rst: bins {asserted, deasserted} on rst.
  - cp_gnt_w_reset: bin {gnt_w==0 during rst=1}
  - cp_gnt_id_reset: bin {gnt_id==0 during rst=1}
  - cp_gnt_on_first_cycle: bins {grant_issued, no_grant} on first cycle after rst=0.
  - cp_req_pattern: bins {single_active, all_zero} for req input after reset.
  - cp_gnt_w_postreset: bin {gnt_w==1 for req[0]=1 after rst=0}
  - cp_gnt_id_postreset: bin {gnt_id==0 for req[0]=1 after rst=0}
Cross coverage:
  - cross_rst_x_req: cp_rst × cp_req_pattern.
  - cross_rst_x_gnt: cp_rst × {cp_gnt_w_reset, cp_gnt_id_reset, cp_gnt_w_postreset, cp_gnt_id_postreset}
Code coverage:
  - FSM state encoding and transition on reset and first arbitration.
  - Statement/branch/toggle coverage of reset and arbitration logic.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 13)]"
no_grant_when_no_requests,Verify that the arbiter does not issue any grants when all request signals are deasserted (no active requests).,"1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) Set prio_upt=1, prio_id=0, prio=2; wait 1 cycle.
   Set prio_upt=1, prio_id=1, prio=2; wait 1 cycle.
   Set prio_upt=1, prio_id=2, prio=2; wait 1 cycle.
   Deassert prio_upt=0.
4) Drive req=3'b000 (no requestors active) for at least 8 cycles.
5) Observe gnt_w and gnt_id throughout.","1) For all cycles with req=3'b000, check that gnt_w==0 and gnt_id==0 (or a defined idle value).
2) Ensure that no spurious grants are issued when there are no requests.","Functional coverage:
- cp_req_pattern: bins {none_active=3'b000}.
- cp_gnt_w: bins {zero}.
- cp_gnt_id: bins {zero}.
Code coverage:
- Statement/branch/toggle of grant logic for no-request case.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
absence_of_error_correction_and_security_nominal_observation,"Verify that the WRR arbiter does not implement any internal error correction, parity, or security features, and that all interfaces are unprotected, as specified. Confirm that all observable behavior is consistent with a lack of ECC, parity, or access protection.","1) Drive clk continuously.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter (per reset/startup sequence).
3) For several cycles, drive req with various one-hot and multi-hot patterns (e.g., req=0, req=1, req=2, req=4, req=8, req=0xF, etc.), and observe gnt_w and gnt_id outputs.
4) Optionally, perform priority updates by driving prio_upt=1, prio_id with a valid requestor ID, and prio with a valid 4-bit value, then deassert prio_upt.
5) For each transaction, drive ack=1 or ack=0 as appropriate to handshake grants.
6) Throughout, do not drive any signals or sequences that would indicate error injection or security access (since only nominal operation is required).","1) At no point do any outputs (gnt_w, gnt_id) indicate error, parity, or security status (i.e., no error flags, no parity bits, no security/lockout signals are present or asserted).
2) All grants and priority updates proceed as described in the spec, with no observable error correction or security-related behavior.
3) Confirm that all input values (including out-of-range or multi-hot req) are accepted without error or protection response.
4) Confirm that configuration via prio/prio_id/prio_upt is always accepted, with no access protection or privilege checks observable on outputs.","Functional coverage:
  - cp_req_patterns: bins {zero, one_hot, multi_hot, all_ones} on req[N-1:0].
  - cp_prio_update: bins {no_update, single_update, multiple_updates} on prio_upt.
  - cp_ack: bins {ack_0, ack_1} on ack.
  - cp_outputs: bins {gnt_w_active, gnt_w_idle} on gnt_w.
Cross coverage:
  - cross_req_x_ack: cp_req_patterns × cp_ack.
  - cross_prio_update_x_outputs: cp_prio_update × cp_outputs.
Code coverage:
  - Statement/branch/toggle coverage of all datapath and control logic, especially any blocks that could implement error correction or security (should be absent).",Absence of Built-in Error Correction or Security Verification,"[('weighted_round_robin_mas.pdf', 11)]"
sideband_only_configuration_nominal,"Verify that all configuration of the WRR arbiter is performed exclusively via sideband signals (prio, prio_id, prio_upt), and that no memory-mapped register access is required or possible. Confirm that priority updates are effective only through these sideband inputs, as per the specification.","1) Drive clk continuously.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter.
3) For a selected requestor (e.g., prio_id=5), drive prio=4'b1010 and prio_upt=1 for one clk cycle to update its priority.
4) Deassert prio_upt=0 and hold prio/prio_id stable or to X for subsequent cycles.
5) Drive req[N-1:0] such that req[5]=1 and at least one other req[i]=1 (i≠5), others 0.
6) Observe gnt_w and gnt_id for grant behavior in subsequent cycles.
7) Repeat steps 3-6 for at least two different requestors and priority values (e.g., prio_id=10, prio=4'b0011).
8) Do not attempt any register read/write operations (since no such ports exist).","1) For each prio/prio_id/prio_upt transaction, check that the corresponding requestor's grant frequency changes in accordance with the new priority value (as observed on gnt_w/gnt_id when req is asserted).
2) Confirm that no configuration or behavior can be affected by any means other than the sideband signals (i.e., no memory-mapped register access is possible, as there are no such ports).
3) For each priority update, verify that only the targeted requestor's grant behavior is affected, and that other requestors remain unchanged unless their priorities are also updated.","Functional coverage:
  - cp_prio_id: bins for at least two distinct prio_id values (e.g., 5, 10).
  - cp_prio_val: bins for at least two distinct prio values (e.g., 4'b1010, 4'b0011).
  - cp_prio_upt: bin for prio_upt=1 event.
  - cp_req: bins for req with single and multiple bits set.
  - cp_gnt_id: bins for gnt_id matching updated prio_id after update.
Cross coverage:
  - cross_prio_id_x_prio_val: prio_id × prio value.
  - cross_prio_id_x_gnt_id: prio_id × observed gnt_id after update.
Code coverage:
  - Statement/branch/toggle coverage of priority update logic and grant selection.",Sideband Configuration Interface Verification,"[('weighted_round_robin_mas.pdf', 13)]"
basic_no_internal_queues_fifo_observation,"Verify that the WRR arbiter maintains all state in synchronous flip-flops with no internal buffering or queueing, ensuring deterministic, cycle-accurate arbitration and grant behavior as specified. This scenario checks that arbitration and grant outputs are always determined by current synchronous state (credits, priorities, pointer) and inputs (req, ack, prio/prio_id/prio_upt), with no evidence of queueing or delayed grant effects.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize all state (priority registers, credit counters, pointer) as per reset/startup sequence.
3) For N=32, PRIORITY_W=4, CREDIT_W=8, ID_BITS=5:
   a) On cycle 0 after reset, drive req[2:0]=3'b011 (requestors #1 and #2 active), all other req=0.
   b) Observe gnt_w and gnt_id each cycle; do not assert ack yet.
   c) On cycle 1, assert ack=1 (simulate grant acceptance by current winner), keep req unchanged.
   d) On cycle 2, keep ack=1, req unchanged.
   e) On cycle 3, deassert ack=0, req unchanged.
   f) On cycle 4, assert prio_upt=1, prio_id=2, prio=4'b1000 (raise #2's priority), then deassert prio_upt in next cycle.
   g) Continue for several cycles, toggling ack and prio_upt as above, always observing gnt_w/gnt_id.
4) At no point drive any input that would require or imply queueing (e.g., do not pulse req for only a single cycle).","1) For every cycle, check that gnt_w and gnt_id reflect only the current synchronous state (req, credits, priorities, pointer) and not any delayed or queued requests.
2) After each ack=1, verify that the next grant is issued to the next eligible requestor in round-robin/weighted order, with no skipped or repeated grants unless dictated by credit/prio state.
3) After prio_upt, verify that the effect is visible in the very next arbitration cycle (no delayed effect).
4) Confirm that when all req=0, gnt_w=0 and gnt_id=0 (no spurious grants).
5) Confirm that when credits are exhausted, refill occurs as per spec, and grant resumes immediately after refill (no extra cycles of grant suppression).","Functional coverage:
- cp_req_pattern: bins {single_active, dual_active, all_zero, all_active} on req[N-1:0].
- cp_ack: bins {ack_0, ack_1}.
- cp_prio_upt: bins {no_update, update_mid, update_max} on prio/prio_id/prio_upt.
- cp_gnt_id: bins {min=0, mid=16, max=31}.
- cp_gnt_w: bins {one_hot_0, one_hot_1, ... one_hot_31}.
Cross coverage:
- cross_req_pattern_x_gnt_id: cp_req_pattern × cp_gnt_id.
- cross_prio_upt_x_gnt_id: cp_prio_upt × cp_gnt_id.
Timing coverage:
- cp_latency: bins {1_cycle, 2_cycle} for grant response after ack/prio_upt.
Code coverage:
- Statement/branch/toggle of arbitration, credit update, and priority update logic.",No Internal Queues or FIFOs Verification,"[('weighted_round_robin_mas.pdf', 13)]"
grant_encoding_consistency_verification,"Verify that, in every arbitration cycle, the one-hot grant output (gnt_w) and the encoded grant ID output (gnt_id) always correspond to the same granted requestor. This ensures that for every grant, the one-hot and encoded outputs are consistent and correctly represent the granted requestor, as required by the Grant Encoding Consistency feature.","1) Drive clk continuously at a nominal frequency.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter (per reset/startup sequence).
3) For at least 4 cycles after reset, drive req with a single active bit (one-hot) at a time, cycling through all possible requestors (i from 0 to N-1):
   a) For each i, set req[i]=1 and all other req[j!=i]=0.
   b) Set ack=0.
   c) Hold prio, prio_id, prio_upt at 0 (no priority updates).
   d) Wait for 1 cycle, then advance to next i.
4) For at least 4 cycles, drive req with multiple active bits (multi-hot), e.g., req=3'b011, 3'b101, 3'b110, etc., and observe which requestor is granted.
   a) For each pattern, set ack=0.
   b) Hold prio, prio_id, prio_upt at 0.
   c) Wait for 1 cycle per pattern.
5) For at least 2 cycles, set req=0 (no requests), observe outputs.
6) Optionally, repeat steps 3-4 with ack=1 for one cycle after each grant to simulate grant acceptance and pointer/credit update.
7) Optionally, set prio=2 for all requestors via prio/prio_id/prio_upt handshake and drive req[2:0]=3'b111 (all three requestors active) continuously, observing gnt_w and gnt_id for at least 10 grant cycles.","1) For every cycle where gnt_w != 0 (i.e., a grant is issued):
   a) Identify the index k where gnt_w[k]==1 (one-hot position).
   b) Check that gnt_id == k (binary encoding matches one-hot position).
2) For each grant, verify that exactly one bit of gnt_w is high (one-hot).
3) For cycles where gnt_w == 0 (no grant), gnt_id may be 0 or undefined (per spec, no grant).
4) For multi-hot req patterns, check that the granted requestor (as indicated by gnt_w and gnt_id) is one of the active requestors in req.
5) No cycles where both gnt_w and gnt_id are nonzero but do not correspond to the same requestor index.
6) No grants should occur with gnt_w=0 except during credit refill (if applicable).","Functional coverage:
  - cp_req_pattern: bins {single_hot, multi_hot, all_zero} on req.
  - cp_gnt_w: bins for each possible one-hot position (0..N-1) and zero.
  - cp_gnt_id: bins for each possible value (0..N-1) and zero.
  - cp_gnt_w_onehot: bins for number of bits set in gnt_w {0,1}.
  - cp_match: bin for cycles where gnt_w and gnt_id match; illegal bin for mismatch.
Cross coverage:
  - cross_req_pattern_x_gnt: cp_req_pattern × cp_gnt_w.
  - cross_gnt_w_x_gnt_id: cp_gnt_w × cp_gnt_id (expect only diagonal bins to be hit).
Code coverage:
  - Statement/branch/toggle coverage of grant encoding logic.",Grant Encoding Consistency Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 10)]"
basic_internal_state_observability_grant_and_priority,"Verify that the externally observable grant outputs (gnt_w, gnt_id) reflect the internal state of the arbiter (credits, priorities, pointer) under nominal operation, demonstrating functional observability as required for debug and QoS monitoring.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for 4 cycles to initialize all internal state (priority registers cleared, credits set to 1, pointer reset to 0).
3) Deassert rst (rst=0) to begin normal operation.
4) For cycles 0-2:
   - Drive req = 0110 (requestors #1 and #2 active).
   - Keep ack=0 (no grant accepted yet).
   - prio_upt=0 (no priority update).
5) On cycle 3:
   - Drive ack=1 (grant accepted by previous winner).
   - Continue req=0110, prio_upt=0.
6) Continue for 2 more cycles, toggling ack as needed to observe grant rotation and refill behavior.","1) For each cycle, record gnt_w and gnt_id.
2) Check that gnt_w is one-hot and matches the expected requestor based on round-robin and credit logic (per spec Table: Cycle-by-cycle arbitration).
3) Check that gnt_id matches the index of the asserted bit in gnt_w.
4) After all credits are exhausted (no eligible requestor), check that gnt_w=0 and gnt_id=0, indicating refill state.
5) After refill, check that grants resume in round-robin order, reflecting pointer update.","Functional coverage:
  - cp_gnt_id: bins for gnt_id = 0, 1, 2 (min, mid, max requestor IDs used in scenario).
  - cp_gnt_w: bins for each one-hot value observed (0010, 0100, 0000).
  - cp_ack: bins for ack=0, ack=1.
  - cp_refill: bin for cycle(s) where gnt_w=0 (no eligible requestor, refill event).
Cross coverage:
  - cross_gnt_id_x_ack: cp_gnt_id × cp_ack.
  - cross_gnt_id_x_refill: cp_gnt_id × cp_refill.
Code coverage:
  - Statement/branch/toggle of grant, pointer, and refill logic.",Internal State Observability Verification,"[('weighted_round_robin_mas.pdf', 10)]"
basic_grant_acknowledge_protocol_nominal,"Verify that the grant acknowledge input (ack) correctly triggers the internal state update and enables issuance of the next grant as per the WRR protocol. This scenario checks that, upon receiving ack=1, the arbiter advances to grant the next eligible requestor, and that the grant outputs (gnt_w, gnt_id) update accordingly.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 to initialize the arbiter (per Table 10.3 Reset/Startup Sequence).
3) After reset, drive req with two or more bits set (e.g., req=0110 for requestors #1 and #2 active).
4) Observe gnt_w and gnt_id: on the first arbitration cycle, the arbiter should grant to the first eligible requestor (e.g., #1).
5) On the next clk rising edge, drive ack=1 (with req unchanged) to acknowledge the current grant.
6) Observe that on the following cycle, the arbiter advances the grant to the next eligible requestor (e.g., #2), updating gnt_w and gnt_id accordingly.
7) Repeat the ack=1 step for the next grant, and observe the grant outputs update or credit refill if no eligible requestors remain.","1) After ack=1 is driven, check that gnt_w and gnt_id update to reflect the next eligible requestor per round-robin and credit rules.
2) Ensure that only one bit in gnt_w is set (one-hot), and gnt_id matches the granted requestor.
3) If all credits are exhausted, check that no grant is issued (gnt_w=0) and that credits are refilled in the next cycle (per Table 9.1 and FSM description).
4) Confirm that the grant is not advanced unless ack=1 is asserted.
5) For each grant, verify that the grant is only issued to a requestor with req=1 and available credit.","Functional coverage:
  - cp_ack: bins {0,1} for ack input.
  - cp_req: bins for single, dual, and all requestors active (e.g., req=0001, 0110, 1111).
  - cp_gnt_id: bins for all possible granted IDs (0..N-1, here at least 0,1,2 for exercised requestors).
  - cp_gnt_w: bins for all one-hot positions corresponding to active requestors.
  - cp_ack_x_gnt: cross of ack × gnt_id to ensure grant advances only on ack=1.
  - cp_credit_refill: bin for cycle where no grant is issued and credits are refilled.
Code coverage:
  - Statement/branch/toggle of grant acknowledge, pointer advance, and credit update logic.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9)]"
basic_arbitration_pipeline_latency_throughput_nominal,"Verify that the two-stage arbitration pipeline achieves 1-cycle best-case and 2-cycle worst-case latency, and sustains one grant per cycle throughput for up to 32 requestors under nominal operation.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 to initialize the arbiter (per reset/startup sequence).
3) For N=32, select a subset (e.g., req[0], req[1], req[2]) for clarity, but scenario is valid for any/all requestors.
4) At cycle 2, drive req[1]=1, req[2]=1, all others 0. Hold ack=0.
5) Observe gnt_w and gnt_id each cycle.
6) At cycle 3, assert ack=1 (grant accepted), keep req[1]=1, req[2]=1.
7) At cycle 4, keep ack=1, req[1]=1, req[2]=1.
8) At cycle 5, keep ack=1, req[1]=1, req[2]=1.
9) Continue for several cycles to observe grant rotation and refill behavior.
10) Optionally, at a later cycle, deassert all req to trigger credit refill path.","1) For each grant (gnt_w, gnt_id), check that only one-hot gnt_w is asserted and gnt_id matches the granted requestor.
2) Measure latency from req asserted to gnt_w/gnt_id asserted: must be 1 cycle in normal operation (Table: Latency Under Different Conditions).
3) When all credits are exhausted (no eligible req), verify that latency to next grant is 2 cycles (credit refill path).
4) Check that at most one grant is issued per cycle (throughput), and that grants rotate among eligible requestors as per round-robin fairness.
5) Confirm that after reset, the first grant is issued after 1 cycle (per reset/startup sequence).","Functional coverage:
  - cp_latency: bins {1,2} for observed grant latency (from req to gnt_w/gnt_id).
  - cp_throughput: bins {1 grant/cycle, 0 grant/cycle (refill)}.
  - cp_req_pattern: bins for {single req, multiple req, all req}.
  - cp_ack: bins {ack=0, ack=1}.
Cross coverage:
  - cross_latency_x_req_pattern: cp_latency × cp_req_pattern.
  - cross_ack_x_latency: cp_ack × cp_latency.
Code coverage:
  - Statement/branch/toggle of arbitration, pipeline, and refill logic.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
parameterization_nominal_limits_basic,"Verify correct operation of the WRR arbiter at its top-level parameterization (N=32, PRIORITY_W=4, CREDIT_W=8, ID_BITS=5), including correct handling of requestor count, priority/credit widths, and resource utilization up to the supported limits. Ensures that all requestors can be granted, priorities can be updated across full range, and credits are managed per spec.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For each requestor i in 0..31:
   a) Drive req[i]=1, all others 0, for 1 cycle.
   b) Observe gnt_w and gnt_id; drive ack=1 when grant is observed.
   c) Repeat for all i to ensure all requestors can be granted.
4) For each requestor i in 0..31:
   a) Drive prio_id=i, prio=15 (max 4-bit value), prio_upt=1 for 1 cycle, then prio_upt=0.
   b) Drive req[i]=1, all others 0, for 1 cycle; observe grant.
   c) Drive prio_id=i, prio=0 (min value), prio_upt=1 for 1 cycle, then prio_upt=0.
   d) Drive req[i]=1, all others 0, for 1 cycle; observe grant.
5) For each requestor i in 0..31:
   a) Issue enough grants (by driving req[i]=1, ack=1) to decrement credit to 0, then observe that credit is refilled from prio+1 and grant resumes per spec.","1) For each i in 0..31, check that when req[i]=1 and all others 0, gnt_w[i]=1 and gnt_id==i within 1 cycle after rst deassertion.
2) After prio update to max/min, check that grant behavior reflects updated priority (higher priority requestors win when multiple requests).
3) After credit exhaustion, check that grant is paused for that requestor until credit is refilled from prio+1, then resumes.
4) Ensure no out-of-bounds access on prio/prio_id (all indices in 0..31).
5) Confirm that all outputs (gnt_w, gnt_id) are within declared widths and encodings.","Functional coverage:
- cp_reqor: bins for all 32 requestors (0..31) being granted at least once.
- cp_prio_val: bins for prio=0, prio=15 (min/max 4-bit values) on prio input.
- cp_credit: bins for credit=0 (exhausted), credit=1 (init), credit=255 (max, if possible).
- cp_cross_reqor_prio: cross of cp_reqor × cp_prio_val.
- cp_grant_latency: bins for 1-cycle and 2-cycle (credit refill) grant latency.
Code coverage:
- Statement/branch/toggle of grant, credit, and priority update logic.",Parameterization and Resource Utilization Verification,"[('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
basic_weighted_round_robin_arbitration_and_fairness_nominal,"Verify that during normal operation, the arbitration FSM remains in ARBITRATION state as long as at least one requestor is eligible, and that the arbiter issues grants every cycle with 1-cycle latency. Additionally, verify that the arbiter grants requests in proportion to their programmed weights (priorities) using the weighted round robin algorithm, ensuring fairness and zero starvation among all active requestors.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 (reset/startup sequence).
3) For all requestors (N=32), set initial priorities via prio/prio_id/prio_upt handshake per port definition. For example, set prio=2 for #0, prio=8 for #1, prio=1 for #2, prio=2 for #3..#31.
4) For at least 3 requestors (#0, #1, #2), drive req[2:0]=3'b111 continuously (all three requestors active). Optionally, repeat with single and multiple active bits (e.g., req=32'b000...1, req=32'b000...11, req=32'b111...1).
5) For each grant (gnt_w/gnt_id), drive ack=1 for one cycle after grant is observed, then ack=0 until next grant.
6) Continue for enough cycles to observe multiple grants per requestor (e.g., 16 cycles), covering pointer wraparound and proportionality.","1) For each cycle with eligible req, check that gnt_w is one-hot and gnt_id matches granted requestor.
2) Confirm that grant is issued every cycle (no gaps) as long as eligible req exists, with 1-cycle latency from req to grant.
3) Scoreboard: For each requestor, count number of times gnt_w[i]==1 and gnt_id==i over the window; check that the ratio of grants matches the ratio of programmed priorities (e.g., #1 receives ~8x, #0 ~2x, #2 ~1x as many grants).
4) Ensure no requestor is starved (each active requestor receives at least one grant in the window).
5) Check that grants rotate among requestors (fairness), i.e., no requestor monopolizes the grant for more cycles than its weight allows.","Functional coverage:
  - cp_req_pattern: bins {single_active, double_active, all_active}.
  - cp_prio: bins for prio values {1,2,8} as programmed.
  - cp_gnt_id: bins for gnt_id {0,1,2} (at least these three requestors).
  - cp_gnt_ratio: bins for observed grant ratios matching priority weights.
  - cp_ack: bins for ack {0,1}.
  - cp_latency: bins {1} (normal operation).
  - cp_pointer_wrap: bin for pointer wrapping at least once.
Cross coverage:
  - cross_req_x_ack: cp_req_pattern × cp_ack.
  - cross_prio_x_gnt: cp_prio × cp_gnt_id (each priority value observed as a grant).
Timing coverage:
  - cp_grant_latency: bins for grant latency {1,2} cycles (normal, refill).
Code coverage:
  - Statement/branch/toggle of arbitration, credit, and pointer logic.
  - FSM remains in ARBITRATION state as long as eligible req exists.",Weighted Round Robin Arbitration Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10)]"
weighted_grant_distribution_with_distinct_priorities,"Verify that, with distinct priorities assigned to each requestor, the grant distribution over multiple refill cycles matches the expected weighted round robin behavior.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) Set priorities: prio=8 for #1 (prio_id=1, prio=8, prio_upt=1), prio=2 for #0 (prio_id=0, prio=2, prio_upt=1), prio=1 for #2 (prio_id=2, prio=1, prio_upt=1).
4) Deassert prio_upt.
5) Drive req[2:0]=3'b111 (all three requestors active).
6) For at least two full credit refill cycles, grant and ack as per normal operation (ack=1 when gnt_w!=0, else ack=0).","1) For each refill cycle, count the number of grants per requestor.
2) Verify that #1 receives 9 grants, #0 receives 3 grants, and #2 receives 2 grants per refill cycle (prio+1 for each).
3) Confirm that the round-robin pointer rotates among eligible requestors and no requestor monopolizes the grants.
4) Ensure that after each refill, the grant pattern repeats according to the assigned priorities.","Functional coverage:
  - cp_priority_combinations: bins for (prio0=2, prio1=8, prio2=1).
  - cp_grant_distribution: bins for number of grants per requestor per cycle (e.g., 9, 3, 2).
  - cp_multiple_refills: bin for observing at least two refill cycles.
Cross coverage:
  - cross_priority_x_grant: cp_priority_combinations × cp_grant_distribution.
  - cross_refill_x_grant: cp_multiple_refills × cp_grant_distribution.
Code coverage:
  - Statement/branch/toggle of weighted grant and refill logic.",Credit-Based Scheduling and Refill Verification,"[('weighted_round_robin_mas.pdf', 4)]"
credit_decrement_refill_and_zero_starvation_nominal,"Verify that each requestor's credit counter is decremented upon grant and refilled from its priority value plus one when exhausted, ensuring proportional access and zero starvation. When all credits are exhausted, the arbiter refills credits from prio+1 and resumes granting, ensuring no requestor is starved (zero-starvation guarantee).","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 to initialize the system (per Table 10.3 Reset/Startup Sequence).
3) For requestors #0, #1, and #2:
   - Set initial priorities by driving prio_id and prio with values (e.g., prio=2 for all, prio_id=0/1/2, prio_upt=1 for one cycle each).
4) Deassert prio_upt.
5) Drive req[2:0]=3'b111 (all three requestors active) continuously.
6) For each grant, drive ack=1 for one cycle after grant is observed, then ack=0.
7) Continue for enough cycles to exhaust all credits (at least prio+1 grants per requestor), then observe refill and resumption of grants. Continue until all requestors have been granted at least once and a credit refill event is observed (i.e., no eligible requestor, gnt_w=0, then next cycle grants resume).","1) For each grant (gnt_w != 0), record which requestor is granted (decode gnt_id and gnt_w).
2) Track the number of grants per requestor between refills; verify that no requestor receives more grants than its priority+1 before credits are refilled.
3) Track credit usage per requestor (based on grants observed).
4) When no eligible requestor (all credits zero), check that no grant is issued for one cycle (gnt_w=0), then credits are refilled from prio+1 and granting resumes.
5) After refill, verify that all requestors again receive grants (no starvation).
6) For each grant, verify gnt_w is one-hot and gnt_id matches granted index.
7) Ensure that every requestor receives at least one grant per refill cycle (zero starvation).","Functional coverage:
  - cp_grant_per_requestor: bins for each requestor receiving a grant.
  - cp_credit_refill: bin for observing at least one credit refill event (gnt_w=0 followed by resumption).
  - cp_priority_value: bins for prio values used (e.g., min=1, mid=2, max=8).
  - cp_credit_exhaust: bin for all credits zero.
  - cp_gnt_id: bins for gnt_id {0,1,2} after refill.
Cross coverage:
  - cross_requestor_x_priority: cp_grant_per_requestor × cp_priority_value.
  - cross_refill_x_requestor: cp_credit_refill × cp_grant_per_requestor.
  - cross_credit_refill_x_gnt: cp_credit_refill × cp_gnt_id.
Timing coverage:
  - cp_refill_latency: bins for latency {2 cycles} (per spec Table 1).
Code coverage:
  - Statement/branch/toggle of credit decrement, refill, and grant logic.",Credit-Based Scheduling and Refill Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4)]"
grant_progress_and_zero_starvation,"Verify that the arbiter guarantees progress and zero starvation: every active requestor receives at least one grant within a bounded window, regardless of priority configuration.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) Set priorities: prio_upt=1, prio_id=0, prio=1; wait 1 cycle.
   prio_upt=1, prio_id=1, prio=8; wait 1 cycle.
   prio_upt=1, prio_id=2, prio=1; wait 1 cycle.
   Deassert prio_upt=0.
4) Drive req=3'b111 (all requestors active) for at least 24 cycles (enough for pointer to wrap multiple times).
5) For each grant, assert ack=1 for one cycle after grant is observed, then deassert ack=0 until next grant.","1) Track grants per requestor; verify that every active requestor receives at least one grant within a window of (sum of all priorities + N) cycles (per pointer and credit logic).
2) No requestor is starved, even if its priority is lower than others.
3) gnt_w is always one-hot and matches gnt_id.","Functional coverage:
- cp_prio: bins {prio0=1, prio1=8, prio2=1}.
- cp_req_pattern: bins {all_active=3'b111}.
- cp_gnt_id: bins {0,1,2}.
- cp_starvation_window: bins for window sizes up to pointer wrap.
Cross coverage:
- cross_prio_x_gnt: cp_prio × cp_gnt_id.
Code coverage:
- Statement/branch/toggle of pointer, credit, and grant logic.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
fsm_arbitration_to_replenish_transition_basic,"Verify FSM transition from ARBITRATION to REPLENISH state when no requestor is eligible (all credits exhausted), and correct behavior of grant outputs and latency.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For N=32, drive req=0 for 2 cycles after reset (no requests).
4) Then, drive req with a pattern where all requestors are active (req=32'hFFFFFFFF), and simulate enough grant/ack cycles to exhaust all credits (i.e., for each requestor, drive ack=1 when granted, until all credits are used up).
5) After all credits are exhausted, keep req=32'hFFFFFFFF and ack=1.
6) Observe gnt_w and gnt_id for at least 3 cycles after credits are exhausted.","1) Confirm that after all credits are exhausted, no grant is issued (gnt_w=0, gnt_id=0) for 1 cycle (ARBITRATION detects no eligible requestor).
2) Confirm that on the next cycle, credits are refilled (REPLENISH state entered), and on the following cycle, arbitration resumes and a grant is issued (latency=2 cycles for credit refill, per spec).
3) Confirm that FSM transitions from ARBITRATION to REPLENISH and back to ARBITRATION as per spec triggers (observable via grant outputs and latency).","Functional coverage:
  - cp_fsm_state: bins {arbitration, replenish} inferred from grant output patterns.
  - cp_credit_exhaustion: bins {not_exhausted, exhausted}.
  - cp_latency: bins {1,2} cycles between last grant and next grant after refill.
Cross coverage:
  - cross_state_x_latency: cp_fsm_state × cp_latency.
Code coverage:
  - FSM state transitions ARBITRATION→REPLENISH→ARBITRATION.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10)]"
basic_dynamic_priority_update_observability_under_varied_load,"Verify that dynamic updates to priorities (via prio/prio_id/prio_upt) for different requestors, both in light and heavy load conditions, are reflected in the externally observable grant outputs (gnt_w, gnt_id). This demonstrates that internal priority state changes are observable through output behavior, supporting debug and QoS monitoring.","1) Drive clk continuously.
2) Assert rst=1 for 4 cycles, then deassert rst=0.
3) Set up two phases:
   Phase 1 (light load):
     - Set initial req = 0101 (requestors #0 and #2 active), ack=0.
     - On cycle 0: prio_upt=0 (no update).
     - On cycle 1 (falling edge): prio_upt=1, prio_id=2, prio=8 (update requestor #2's priority to 8), ack=0, req=0101.
     - On cycle 2 (rising edge): prio_upt=0, ack=1 (accept grant), req=0101.
     - Continue for 2 more cycles, observing grant outputs.
   Phase 2 (heavy load):
     - For cycles 0-3: req=111 (all three requestors active).
     - On cycle 0: prio_upt=0, ack=0.
     - On cycle 1: prio_upt=1, prio_id=0, prio=8 (boost #0's priority), ack=1.
     - On cycle 2: prio_upt=1, prio_id=1, prio=1 (deprioritize #1), ack=0.
     - On cycle 3: prio_upt=0, ack=1.
4) Observe gnt_w and gnt_id each cycle.","1) For each cycle, record gnt_w and gnt_id.
2) After each priority update (prio_upt=1 for a given prio_id), check that the corresponding requestor is granted next if its priority is now highest.
3) Before updates, check that grant outputs match expected winners based on initial priorities.
4) After boosting a requestor's priority, check that it wins repeatedly; after deprioritizing, check that it does not win.
5) Confirm that grant outputs change in response to dynamic priority updates, reflecting internal state changes.","Functional coverage:
  - cp_prio_upt: bins for prio_upt=0, prio_upt=1.
  - cp_prio_val: bins for prio=1, 2, 8 (min, mid, max values used in scenarios).
  - cp_gnt_id: bins for gnt_id=0, 1, 2 (all requestors).
Cross coverage:
  - cross_prio_upt_x_gnt_id: cp_prio_upt × cp_gnt_id.
  - cross_prio_val_x_gnt_id: cp_prio_val × cp_gnt_id.
Code coverage:
  - Statement/branch/toggle of priority update and grant selection logic.",Internal State Observability Verification,"[('weighted_round_robin_mas.pdf', 10)]"
dynamic_priority_update_runtime_effect,"Verify that updating a requestor's priority (weight) at runtime via prio/prio_id/prio_upt immediately affects the grant pattern, and that the arbiter responds to dynamic changes without stalling, starvation, or disruption. The test covers multiple requestors, updates to different requestors, and ensures that subsequent grants reflect the new weights.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) Set initial priorities for all requestors (e.g., #0, #1, #2) to prio=2 via prio/prio_id/prio_upt handshake, each for 1 cycle.
4) Drive req to activate a subset of requestors (e.g., req=3'b011 for #0 and #1, or req=3'b101 for #0 and #2).
5) Observe grants for several cycles to establish baseline (should alternate between active requestors with equal priority).
6) While grants are ongoing, update the priority of one active requestor (e.g., prio=8, prio_id=1 or 2, prio_upt=1 for one cycle), then deassert prio_upt.
7) Continue driving the same req pattern and observe grants for several more cycles.","1) Before priority update, check that grants alternate between active requestors (equal priority).
2) After priority update, check that the updated requestor receives more frequent grants, proportional to its new priority.
3) Ensure that the grant pattern changes within 1-2 cycles of the priority update (per latency spec).
4) For each grant, verify gnt_w is one-hot and gnt_id matches granted index.
5) Ensure no requestor is starved, and no stalling or missed grants occur during or after the update.","Functional coverage:
- cp_prio_update: bins for prio_upt {0,1} and before/after update.
- cp_prio_value: bins for prio values before and after update (e.g., {2,8}).
- cp_gnt_id: bins for granted requestor IDs.
- cp_grant_ratio: bins for grant ratio before (e.g., 1:1) and after (e.g., 1:4) update.
Cross coverage:
- cross_prio_update_x_gnt: cp_prio_update × cp_gnt_id.
Timing coverage:
- cp_update_timing: bins for cycles before, during, and after prio update.
Code coverage:
- Statement/branch/toggle of priority update and arbitration logic.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
simultaneous_priority_update_and_grant_acknowledge_basic,"Verify that the WRR arbiter correctly and hazard-free processes a priority update (prio/prio_id/prio_upt) and a grant acknowledge (ack) on the same clock cycle, ensuring both the priority register and credit/pointer logic update as specified, and that the grant outputs (gnt_w, gnt_id) reflect the correct arbitration result.","1) Drive clk continuously.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter (per Table 10.3 Reset / Startup Sequence).
3) After reset, drive req to activate at least two requestors (e.g., req=0011 for requestors #0 and #1).
4) On cycle N, simultaneously:
   - Assert ack=1 (to acknowledge the current grant).
   - Assert prio_upt=1, prio_id=1, prio=6 (to update requestor #1's priority to 6).
5) On subsequent cycles, continue to drive req as before, deassert prio_upt and ack as appropriate.
6) Observe gnt_w and gnt_id each cycle to determine which requestor is granted.","1) Check that the priority register for prio_id=1 is updated to prio=6 after the prio_upt strobe.
2) Check that the grant acknowledge (ack=1) causes the credit for the previously granted requestor to decrement and the pointer to advance as per spec.
3) Check that the next grant (gnt_w, gnt_id) reflects the updated priority for requestor #1 (i.e., #1 should win the next arbitration if its priority is now higher than others and its req is still asserted).
4) Ensure no cycles are missed (no grant or lost update) and that both operations are processed in the same cycle without hazard (per Table: Scenario C and Section 9.3 Hazards & Ordering).","Functional coverage:
- cp_prio_upt: bins {prio_upt=1, prio_upt=0}.
- cp_ack: bins {ack=1, ack=0}.
- cp_simultaneous: bin where prio_upt=1 and ack=1 in the same cycle.
- cp_gnt_id: bins for all possible granted IDs (at least #0 and #1 in this scenario).
Cross coverage:
- cross_simultaneous_x_gnt: cp_simultaneous × cp_gnt_id (ensure that simultaneous update/ack can result in grant to updated requestor).
Code coverage:
- Statement/branch/toggle coverage of priority update, credit decrement, pointer advance, and grant logic.",Simultaneous Priority Update and Grant Acknowledge Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 21)]"
runtime_priority_update_and_credit_refill_behavior,"Verify that updating a requestor's priority at runtime via prio/prio_id/prio_upt does not stall or interfere with ongoing arbitration or grant cycles, and that the new priority dynamically changes the requestor's credit refill value. Confirm that the new priority takes effect for subsequent arbitration and refill cycles, and that grants reflect the updated weights and refill counts.","1) Drive clk continuously.
2) Assert rst=1 for 4 cycles, then deassert rst=0.
3) After reset, drive req[2:0]=3'b111 (all three requestors active) for the duration of the test.
4) Set initial priorities for requestors #0, #1, #2 to prio=2 (default after reset or via prio_id/prio/prio_upt).
5) Wait for at least one grant cycle to observe baseline behavior (e.g., #0, #1, #2 each get a turn).
6) For several cycles, grant and ack as in the previous scenario, until a credit refill event is about to occur.
7) On a rising clk edge, drive prio_upt=1, prio_id=1, prio=8 (boost #1's priority to max), then deassert prio_upt=0 next cycle.
8) Observe the next refill event and subsequent grant cycles.
9) On a subsequent rising clk edge, drive prio_upt=1, prio_id=0, prio=1 (lower #0's priority), then deassert prio_upt=0 next cycle.
10) Continue observing grants and refill events for several more cycles.","1) Before any priority update, check that grants (gnt_w, gnt_id) rotate fairly among requestors (round robin, since all priorities equal).
2) After boosting #1's priority, check that #1 receives more frequent grants (gnt_id==1) compared to others, proportional to its new weight, and that after the next credit refill, #1 receives prio+1=9 grants per refill cycle.
3) After lowering #0's priority, check that #0 receives fewer grants (gnt_id==0) compared to others, proportional to its new weight, and that after the next refill, #0 receives prio+1=2 grants per refill cycle.
4) At no point does the grant output (gnt_w, gnt_id) stall or skip cycles due to the priority update (i.e., arbitration continues every cycle).
5) Confirm that prio/prio_id/prio_upt changes only affect subsequent arbitration cycles and refill events, not the current one if update occurs during a grant or refill.
6) Ensure that no requestor is starved and that the refill logic uses the latest priority value.","Functional coverage:
  - cp_prio_id: bins {0, 1, 2} (requestor IDs updated).
  - cp_prio_val: bins {1, 2, 8} (min, default, max priority values).
  - cp_update_timing: bins {update_during_grant, update_between_grants} (priority update coincides with ack or not).
  - cp_gnt_id: bins {0, 1, 2} (all requestors granted at least once after update).
  - cp_priority_update: bins for priority update events (prio_upt=1) for each requestor.
  - cp_grant_count_after_update: bins for number of grants per requestor after priority update.
  - cp_refill_with_updated_priority: bin for observing a refill event after a priority update.
Cross coverage:
  - cross_prio_id_x_prio_val: cp_prio_id × cp_prio_val.
  - cross_update_timing_x_gnt_id: cp_update_timing × cp_gnt_id.
  - cross_priority_update_x_refill: cp_priority_update × cp_refill_with_updated_priority.
  - cross_requestor_x_priority_update: cp_priority_update × cp_grant_count_after_update.
Code coverage:
  - Statement/branch/toggle of priority update, arbitration, and credit refill logic.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 4)]"
basic_assertion_coverage_grant_priority_credit_mechanisms,"Verify that functional assertions comprehensively cover grant progress, correct grant encoding, pointer range, dynamic priority updates, prevention of out-of-bounds accesses, and the credit refill mechanism during nominal and edge arbitration cycles. This ensures that for valid requests, the arbiter issues a one-hot grant, the encoded grant ID matches the granted requestor, the pointer cycles within range, only valid prio_id values update priorities, grants reflect updated priorities, and that when all credits are exhausted, the arbiter refills credits and resumes granting as per protocol.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For 4 consecutive cycles:
   a) Drive req with a single active bit (one-hot) at positions 0, 1, 2, 3 in turn.
   b) For each cycle, observe gnt_w and gnt_id.
   c) Drive ack=1 in the cycle after grant is observed to simulate acceptance.
4) For 2 cycles, drive req=0001 (requestor 0 active), ack=0.
5) On cycle 2, drive prio_upt=1, prio_id=2, prio=8 (update priority of requestor 2 to 8).
6) On cycle 3, drive req=0100 (requestor 2 active), ack=0.
7) For N cycles, drive req=111...1 (all requestors active), ack=1 each cycle to consume credits until no grant is issued (all credits exhausted).
8) Observe that in the next cycle, no grant is issued (gnt_w=0, gnt_id=0).
9) Wait one cycle (credit refill should occur).
10) Continue driving req=111...1, ack=0, and observe that grants resume (gnt_w!=0).
11) Idle req and ack for 2 cycles.","1) For each cycle where req[i]=1, check that gnt_w has exactly one bit set (one-hot) and that the position matches the requesting index.
2) Check that gnt_id equals the binary encoding of the granted requestor (matches the index of the one-hot in gnt_w).
3) Ensure that the pointer cycles through 0..N-1 without exceeding range.
4) No grants are issued when req=0.
5) Check that priority update only occurs for prio_id in range 0..N-1 (no out-of-bounds update).
6) After prio_upt, verify that requestor 2 is granted when it requests (gnt_w[2]=1, gnt_id=2).
7) Confirm that no grant is issued to an out-of-range prio_id.
8) Ensure that grant reflects updated priority.
9) After all credits are exhausted, check that no grant is issued (gnt_w=0, gnt_id=0).
10) In the following cycle, verify that credits are refilled and grants resume (gnt_w!=0).
11) Ensure that the refill occurs only when no eligible requestor exists.
12) Confirm that grants after refill are valid (one-hot, correct gnt_id).","Functional coverage:
  - cp_req_idx: bins for req[i]=1, i in {0,1,2,3}.
  - cp_gnt_w: bins for each one-hot position in gnt_w and for gnt_w=0 (no grant).
  - cp_gnt_id: bins for each value 0..3 (matching gnt_w position).
  - cp_ack: bins {0,1}.
  - cp_prio_id: bins for prio_id={0,2}.
  - cp_prio: bins for prio={default, updated=8}.
  - cp_prio_upt: bins {0,1}.
  - cp_credits: bins {full, exhausted, refilled}.
  - cp_fsm_state: bins {ARBITRATION, REPLENISH} (implied by grant/refill behavior).
Cross coverage:
  - cross_req_idx_x_gnt_id: cp_req_idx × cp_gnt_id.
  - cross_gnt_w_x_gnt_id: cp_gnt_w × cp_gnt_id.
  - cross_prio_id_x_gnt_id: cp_prio_id × cp_gnt_id.
  - cross_prio_upt_x_gnt_id: cp_prio_upt × cp_gnt_id.
  - cross_credits_x_gnt_w: cp_credits × cp_gnt_w.
  - cross_fsm_state_x_gnt_w: cp_fsm_state × cp_gnt_w.
Code coverage:
  - Statement/branch/toggle of grant generation, encoding, priority update, credit refill, and FSM transition logic.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 17)]"
stress_synchronous_reset_during_sustained_load,"Exercise the synchronous reset and initialization logic under sustained, high-load conditions. Verify that all internal state (priority registers, credit counters, round-robin pointer) is correctly initialized on rst assertion, and that the module resumes arbitration deterministically and at full throughput immediately after rst deassertion. Stress the reset by asserting it during continuous back-to-back requests from all requestors.","1) Set N=32, PRIORITY_W=4, ID_BITS=5, CREDIT_W=8 as per top RTL.
2) Apply clk with normal frequency. Assert rst=1 for at least 2 cycles while driving all other inputs (req, prio, prio_id, prio_upt, ack) to random legal values.
3) During rst=1, drive req[N-1:0]=all 1's (all requestors active), prio/prio_id/prio_upt to random values, ack=0.
4) After 2 cycles, deassert rst (rst=0) and immediately begin driving req[N-1:0]=all 1's, ack=1 every cycle (continuous acceptance), prio/prio_id/prio_upt=0 (no updates).
5) Sustain this pattern for at least 10,000 cycles to stress startup and long-run stability.
6) Optionally, repeat with rst asserted mid-stream (after 5,000 cycles) to test recovery under load.","1) On every rst=1 rising edge, observe that gnt_w=0, gnt_id=0 for at least one cycle after rst assertion.
2) After rst deassertion, verify that the first arbitration cycle occurs within 1 cycle (per spec), and that grants are issued to requestors as per round-robin/weight logic.
3) Confirm that no grants are issued during rst=1.
4) Check that after reset, all requestors are eligible (credits=1, priorities=0, pointer=0 per spec Table 10.3).
5) No protocol violations: all handshakes legal, no deadlock, no dropped requests.
6) Throughput after reset matches normal operation (≥31 grants per 32 cycles for N=32, assuming all requestors active and ack=1).","Functional:
  - cp_rst_timing: bins {short, long} rst pulse durations.
  - cp_post_rst_latency: bins {1,2,3+} cycles to first grant after rst deassertion.
  - cp_grant_pattern: bins {first grant to #0, #1, ... #31} after reset.
  - cp_midstream_rst: bins {reset at idle, reset during max load}.
Cross:
  - cross_rst_x_grant: cp_rst_timing × cp_grant_pattern.
Code:
  - Coverage of all resettable state (priority, credit, pointer) and arbitration logic after reset.",Synchronous Reset and Initialization Verification,"[('weighted_round_robin_mas.pdf', 13)]"
stress_sustained_arbitration_fsm_state_transitions,"Exercise the Arbitration FSM under sustained, high-load conditions with continuous requests from all requestors. The goal is to maximize the number of ARBITRATION↔REPLENISH state transitions, verifying correct operation, no deadlock, and adherence to latency bounds (1 cycle for arbitration, 2 cycles for credit refill per spec).","1) Assert rst high for 1 cycle, then deassert to initialize all state (priority=0, credit=1, pointer=0).
2) On every clk rising edge, drive req[N-1:0]=all_ones (all requestors active) for at least 10,000 cycles.
3) For each grant (gnt_w, gnt_id), immediately assert ack=1 to accept the grant every cycle.
4) Do not drive prio_upt/prio/prio_id (keep at 0) to avoid priority changes during this scenario.
5) Observe gnt_w, gnt_id to track which requestor is granted each cycle.
6) Continue until at least 100 full ARBITRATION→REPLENISH→ARBITRATION FSM cycles are observed (i.e., all credits exhausted and refilled multiple times).","1) No cycle is missed: for every cycle, either a grant is issued or a refill occurs as per FSM spec.
2) FSM transitions: After all credits are exhausted (no eligible req), REPLENISH state is entered for exactly 2 cycles, then returns to ARBITRATION.
3) Latency: Arbitration grants are issued with 1-cycle latency; credit refill takes 2 cycles (per Section 12.2).
4) No deadlock: System always returns to ARBITRATION and resumes granting after REPLENISH.
5) No protocol violations: gnt_w is one-hot or zero; gnt_id matches gnt_w; ack is accepted only when grant is present.","Functional:
  - cp_fsm_state: bins {ARBITRATION, REPLENISH}.
  - cp_transition: bins {ARBITRATION→REPLENISH, REPLENISH→ARBITRATION}.
  - cp_latency: bins {1,2} (arbitration, refill).
  - cp_grant: bins {each requestor ID}.
Cross:
  - cross_state_x_latency: cp_fsm_state × cp_latency.
  - cross_grant_x_transition: cp_grant × cp_transition.
Code:
  - FSM state and transition coverage under sustained load.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10)]"
stress_credit_refill_worst_case_latency,"Latency stress: Exercise the pipeline's worst-case path by depleting all credits simultaneously, forcing a credit refill event. Verify that the arbitration pipeline incurs exactly 2-cycle latency during refill, as specified, and resumes 1 grant/cycle throughput after refill.","1) Reset as per spec (rst high 1 cycle, then low).
2) Set all priorities to minimum legal value (prio=0 for all requestors) via prio/prio_id/prio_upt before starting.
3) Drive req[31:0]=32'hFFFF_FFFF (all requestors active) every cycle.
4) For each grant, assert ack=1 in the next cycle, so each requestor consumes its credit every time it is granted.
5) Continue until all credits are exhausted (after N cycles, since each starts with 1 credit).
6) Observe the pipeline as it enters the REPLENISH state (no eligible requestors), triggering credit refill.
7) Continue driving requests and acknowledgments for at least 2N cycles to observe multiple refill events.","1) When all credits are exhausted, the pipeline must enter a 2-cycle latency window (no grant for 1 cycle, then refill, then resume grants).
2) No grants are issued during the refill cycle (gnt_w=0, gnt_id=0).
3) After refill, grants resume at 1/cycle throughput.
4) No protocol violations or deadlock.
5) Latency histogram: 1-cycle for normal, 2-cycle for refill events only.","Functional:
  - cp_latency: bins {1,2} (normal and refill).
  - cp_refill_event: cover at least one full credit depletion/refill per requestor.
  - cp_grant: all requestors participate in at least one refill event.
Cross:
  - cross_latency_x_refill: cp_latency × cp_refill_event.
Code:
  - Control FSM transitions (ARBITRATION <-> REPLENISH) exercised.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
stress_burstiness_acknowledge_and_latency_extremes,"Stress test the grant acknowledge protocol and arbitration logic by alternating between long bursts of continuous requests with immediate acknowledges, short pauses with no acknowledges, and idle periods. This scenario exercises the system's ability to handle variable inter-op gaps, bursty and idle traffic, and ensures correct grant sequencing, latency behavior, fairness, and throughput under extreme conditions.","1) Apply clk and rst as per reset/startup sequence.
2) Set all prio=4 via prio, prio_id, prio_upt (if applicable).
3) For a total of 5,000 cycles, alternate between:
   a) Burst phase: For 32-100 cycles, drive req[N-1:0]=all_ones and assert ack=1 every cycle (simulate a burst of immediate acceptances).
   b) Pause phase: For 8 cycles, keep req[N-1:0]=all_ones but hold ack=0 (simulate no acceptance).
   c) Idle phase: For 50 cycles, req[N-1:0]=all_zeros, ack=0 (simulate all requestors idle).
4) Repeat burst/pause/idle pattern for the duration.
5) No priority updates (prio_upt=0) during the test.
6) Observe gnt_w, gnt_id, and grant issuance timing.","1) During burst, grant-to-grant latency is 1 cycle; during pause, no new grants are issued until ack=1 resumes.
2) No grant is issued unless ack=1 for the previous grant.
3) After pause or idle, grant issuance resumes immediately with correct sequencing.
4) No protocol violations or deadlock.
5) Grant distribution remains fair and proportional over the full scenario; no starvation.
6) gnt_w is one-hot and gnt_id matches gnt_w.
7) Grant latency within 1 cycle during bursts, up to 2 cycles after refill/idle.","Functional:
  - cp_burst_len: bins for burst lengths (short=8, long=32-100).
  - cp_ack_gap: bins {1, 8}.
  - cp_idle_len: bins for idle lengths (e.g., 50 cycles).
  - cp_grant_latency: bins {1, 2, >2 (during pause/idle)}.
Cross:
  - cross_burst_len_x_ack_gap: cp_burst_len × cp_ack_gap.
  - cross_burst_x_latency: burst length × latency.
Code:
  - Cover grant and arbitration logic under sustained, interrupted, and idle acknowledge patterns.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 9)]"
stress_sustained_max_throughput_arbitration_and_grant_consistency,"Exercise the WRR arbiter under maximum sustained load: all requestors assert requests continuously, with immediate acknowledge (ack=1 every cycle), for an extended duration. This scenario stresses the arbitration pipeline, grant encoding, and protocol logic to verify that the arbiter achieves 1 grant per cycle throughput, 1-cycle best-case latency, no internal queueing or buffering, and consistent grant encoding. It also confirms that no error correction, parity, or security features are present or engaged, and that the absence of such features does not impact functional operation or throughput/latency. The scenario ensures all state is synchronous and deterministic, arbitration remains combinational, and all interfaces remain unprotected.","1) Apply clk and assert rst for 1 cycle, then deassert rst to initialize the arbiter (per reset/startup sequence: Section 10.3).
2) For at least 10,000 cycles (long duration), drive req[N-1:0]=all_ones (all requestors active) every cycle.
3) On every cycle where gnt_w or gnt_id indicates a grant, immediately assert ack=1 for that cycle (simulate immediate acceptance).
4) Do not assert prio_upt or change priorities during this scenario; priorities remain at default.
5) Do not inject any error patterns, parity, or security-related signals, as none exist in the interface.
6) Observe gnt_w[N-1:0] and gnt_id[ID_BITS-1:0] every cycle; record grant sequence and timing.","1) For every cycle where gnt_w != 0, exactly one bit of gnt_w is set (one-hot), and gnt_id equals the index of the set bit.
2) No cycle where gnt_w is non-zero has a mismatch between the one-hot and encoded grant.
3) Grant-to-grant latency is always 1 cycle in normal operation, 2 cycles during credit refill (per spec).
4) All requestors receive grants in round-robin, weighted order (fairness and proportionality).
5) No protocol violations: ack is only asserted in response to a valid grant, and handshakes are legal.
6) No deadlock: forward progress is made every cycle.
7) No grant is issued unless ack=1 for the previous grant (protocol adherence).
8) No evidence of internal queueing or buffering: grant is always determined by current req/credit/prio, not by any internal buffering.
9) No evidence of error correction, parity, or security signaling on any port (since none exist).","Functional:
  - cp_ack_gap: bins {1} (ack asserted every cycle).
  - cp_req_pattern: bins {all_active}.
  - cp_grant_latency: bins {1,2} (normal, refill).
  - cp_grant_distribution: cover all requestors receiving grants.
  - cp_grant_encoding: bins {match, mismatch} (expect only match).
  - cp_grant_activity: bins {grant_issued, no_grant}.
  - cp_grant_fairness: bins {min, median, max grants per requestor}.
  - cp_duration: bins {short, long} (ensure long-run stability).
Cross:
  - cross_req_pattern_x_grant_latency: cp_req_pattern × cp_grant_latency.
  - cross_grant_x_latency: cp_grant_distribution × cp_grant_latency.
  - cross_grant_encoding_x_activity: cp_grant_encoding × cp_grant_activity.
Code:
  - Cover all datapath, arbitration, credit update, pointer update, and grant encoding logic under sustained load.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 11), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 14)]"
stress_observability_under_sustained_maximum_load,"Exercise the internal state observability feature by driving the WRR arbiter at sustained maximum throughput (continuous requests from all requestors) while performing frequent dynamic priority updates. Verify that all externally observable outputs (gnt_w, gnt_id) reflect the expected internal state transitions (credits, priorities, pointer) as per the spec, and that the system remains fully observable and debuggable under stress.","1) Assert rst high for 1 cycle, then deassert to initialize all internal state (see spec 10.3 Reset / Startup Sequence).
2) For at least 10,000 cycles (long duration):
   a) On every clk rising edge, drive req[N-1:0] = all 1's (all requestors continuously request).
   b) On every cycle, set ack = 1 (all grants are accepted immediately, no backpressure).
   c) Every 16 cycles, issue a dynamic priority update: set prio_upt = 1, prio_id = (cycle_count % N), prio = (cycle_count % 16), then deassert prio_upt next cycle.
3) Observe gnt_w and gnt_id every cycle; record their values for later correlation with expected internal state transitions.
4) Repeat with a different seed for prio/prio_id update order to ensure coverage (if randomization is used, document the seed).","1) For every cycle, check that gnt_w is one-hot and matches gnt_id (per spec 7.2 Bit Widths & Encodings, 16.1 Assertions).
2) After each priority update, verify that subsequent grant patterns reflect the new priorities within the next arbitration cycle (see spec 14.2 QoS / Scheduling).
3) Ensure that for every requestor, the grant frequency over the test duration is proportional to its assigned priority (within tolerance).
4) No cycles with missing or illegal grants (gnt_w == 0 except during credit refill as per FSM spec).
5) No deadlock: at least one grant per cycle except during refill (spec 8.1 Status / Debug, FSM description).","Functional:
  - cp_priority_update: bins {no_update, frequent_update, rare_update}.
  - cp_grant_distribution: bins for grant counts per requestor (low, medium, high).
  - cp_pointer_wrap: bins for pointer wraparound events.
  - cp_credit_refill: bins for cycles with/without credit refill.
Cross:
  - cross_priority_update_x_grant: cp_priority_update × cp_grant_distribution.
Code:
  - Cover all arbitration and refill FSM transitions under load and dynamic updates.",Internal State Observability Verification,"[('weighted_round_robin_mas.pdf', 10)]"
stress_dynamic_priority_update_under_load,"Stress test dynamic priority (weight) updates during continuous high-load operation. While all requestors are active and issuing requests, priorities are updated dynamically for random or selected requestors at varying intervals and frequencies, including bursty and concurrent updates. This stresses the arbitration, credit refill, and scheduling logic under changing weights, ensuring correct adaptation, no starvation, and protocol correctness. The scenario measures the impact on throughput, latency, fairness, and grant distribution, and verifies that priority changes are honored promptly without disrupting arbitration or causing deadlock.","1) Apply clk and rst as per spec (reset for 1 cycle, then deassert).
2) Initialize all priorities to a baseline (e.g., prio=2 for all requestors) using prio, prio_id, prio_upt.
3) For T_STRESS=5000 cycles:
   a) Drive req[N-1:0]=all 1's (all requestors active) every cycle.
   b) For each cycle, at varying intervals (e.g., every 8, 10, 100 cycles, or every cycle in sub-windows), select one or more requestors (random or round-robin, seed=42 for reproducibility) and update their priorities to new values (cycling or random in [1..15]) using prio, prio_id, prio_upt=1 for one cycle.
   c) Ensure some priority updates coincide with ack=1.
   d) For all grants, assert ack=1 in the next cycle.
4) Track gnt_w, gnt_id, and record grant history and timing of priority updates.
5) At the end, test with req=0 to confirm no grants are issued.","1) No protocol violations: prio/prio_id/prio_upt handshake legal, gnt_w one-hot, gnt_id matches gnt_w, grants/acks legal.
2) Throughput remains at 1 grant/cycle except during refill events.
3) Grant distribution adapts to updated priorities within 1-2 cycles (per spec latency), and higher priority requestors receive proportionally more grants.
4) Arbitration latency remains within spec (1 cycle normal, 2 cycles on refill).
5) No deadlock or starvation: all requestors eventually granted, even as priorities change.
6) No grant issued when req is all 0.
7) Priority updates do not disrupt ongoing arbitration or cause deadlock.","Functional:
  - cp_priority: bins for all legal priority values (e.g., 0..15).
  - cp_priority_update: bins for each priority value applied and for update timing (with/without ack).
  - cp_update_rate: bins for update intervals (every 1, 2, 4, 8, 10, 100 cycles, etc.).
  - cp_grant_adaptation: bins for grant count change after update and cycles-to-grant after priority change.
  - cp_credit_refill: bins for refill events during/after updates.
Cross:
  - cross_priority_x_grant: cp_priority × cp_grant.
  - cross_update_x_grant: cp_priority_update × cp_grant_adaptation.
  - cross_update_x_latency: priority update timing × grant latency.
Code:
  - Coverage of dynamic priority update datapath, arbitration, and credit refill logic under bursty and dynamic conditions.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
stress_sideband_config_varied_patterns_and_long_run,"Exercise the sideband configuration interface (prio, prio_id, prio_upt) under a variety of stress conditions: sustained high-frequency updates, alternating bursts and idle periods, and long-duration operation. Arbitration remains active throughout. This scenario stresses the DUT's ability to handle rapid, bursty, and infrequent priority changes for all requestors, ensuring configuration is always performed via sideband signals and never via memory-mapped registers. Expected behavior: all priority updates are correctly applied in real time, with no configuration loss or protocol violation, and arbitration continues without interruption or deadlock, even over extended durations.","1) Apply clk and rst; deassert rst after initialization per spec (priority registers cleared, credits initialized, pointer reset).
2) For T_STRESS = 1,000,000 cycles:
   a) Alternate between the following patterns:
      i) High-frequency updates: For 100 cycles, drive prio_upt=1 every cycle, prio_id cycling through all requestor IDs (0 to N-1), prio randomized (seed=42).
      ii) Idle: For 100 cycles, hold prio_upt=0 (no updates).
      iii) Infrequent updates: On every 10th cycle, drive prio_upt=1, prio_id cycling, prio randomized (seed=2024).
   b) Repeat the above patterns for the duration.
   c) req[N-1:0] asserted throughout; ack toggled randomly (seed=2024) or every other cycle to introduce handshake variation.
3) No memory-mapped register accesses are performed at any time.
4) Observe gnt_w and gnt_id for correct arbitration and grant behavior.","1) For every prio_upt=1, verify that the next arbitration cycle reflects the updated priority for the specified prio_id.
2) During idle, priorities remain stable; no spurious updates occur.
3) Confirm that no configuration is performed via any memory-mapped register (by construction: no such ports exist).
4) Ensure that arbitration continues without deadlock or loss of grant (gnt_w/gnt_id always valid when req is asserted).
5) No protocol violations on prio/prio_id/prio_upt handshake (one update per strobe, no double-application).
6) All requestors eventually receive grants (zero-starvation).
7) No configuration loss or corruption over long run.","Functional:
  - cp_prio_update_rate: bins {single, burst, sustained, infrequent} (frequency of prio_upt).
  - cp_burst_len: bins {short, long} (length of update bursts).
  - cp_idle_len: bins {short, long} (length of idle periods).
  - cp_prio_value: bins {min, mid, max} (prio values applied).
  - cp_duration: bins {short, medium, long} (duration of sustained operation).
  - cp_req_pattern: bins {all_active}.
Cross:
  - cross_prio_update_x_grant: cp_prio_update_rate × grant distribution per requestor.
  - cross_burst_x_idle: cp_burst_len × cp_idle_len.
  - cross_duration_x_update: cp_duration × cp_prio_update_rate.
Code:
  - Cover all priority update logic paths, burst/idle transitions, and long-run operation in configuration and arbitration logic.",Sideband Configuration Interface Verification,"[('weighted_round_robin_mas.pdf', 13)]"
stress_weighted_round_robin_max_throughput_fairness_and_dynamic_priority_update,"Sustained, back-to-back requests from all requestors with diverse priority weights to maximize throughput and exercise fairness, zero-starvation guarantees, and dynamic priority update handling. The scenario applies continuous requests from all N=32 requestors, each assigned a distinct priority (weight) spanning the full PRIORITY_W=4 range. During the run, frequent and bursty dynamic priority updates are issued to random requestors, including back-to-back updates and updates during grant/ack cycles. The test measures grant distribution, latency, ensures no requestor is starved under continuous load, and verifies that priority changes take effect immediately and arbitration remains combinational and deterministic, with no internal buffering or queueing. Credit exhaustion and refill cycles are exercised, including pointer wraparound and resource utilization at parameter extremes.","1) Apply clk and assert rst for 1 cycle, then deassert rst to initialize (per spec 10.3).
2) For each requestor i (0..31), set prio, prio_id, prio_upt to assign prio[i] a unique value in [1..15], ensuring full PRIORITY_W coverage.
3) For T_STRESS=10,000 cycles:
   a) Drive req[N-1:0] = all 1's (all requestors continuously request).
   b) On every 4th cycle, assert prio_upt=1, select prio_id randomly (seed=42 for reproducibility), and drive prio with a random value (0..15). On other cycles, prio_upt=0.
   c) For each grant (gnt_w, gnt_id), assert ack=1 every cycle (no backpressure) to maximize throughput.
   d) Intentionally allow credits to exhaust for some requestors by not acknowledging some grants for a subset of requestors (e.g., ack=0 for req[0] every 8th cycle), forcing credit refill logic to trigger.
4) Alternate between long bursts (e.g., 100 cycles all req=1) and short bursts (e.g., 10 cycles), interleaved with idle periods (req=0), to stress FSM transitions and pointer wraparound.
5) Observe gnt_w, gnt_id, grant sequence, credit counters, and pointer wrap events throughout the run.","1) No protocol violations: gnt_w one-hot, gnt_id matches granted requestor, handshakes legal, no out-of-bounds prio/prio_id accesses.
2) Per-requestor grant count is proportional to assigned weight (within ±1 per 1000 cycles); no requestor is starved (zero-starvation guarantee).
3) After each prio_upt, verify that the updated priority takes effect in the next arbitration cycle and grant distribution reflects updated priorities.
4) Credit counters decrement and refill per spec (refill to prio+1 when exhausted), and pointer wraps correctly after N grants.
5) After all credits are exhausted, there is exactly 1 cycle with no grant (gnt_w=0), matching the refill latency per spec; arbitration resumes with correct sequencing and latency.
6) No evidence of queueing or buffering: grant decisions reflect current req/prio/credit only.
7) Latency from request to grant is always ≤2 cycles (1 cycle normal, 2 cycles after credit refill).
8) All requestors eventually receive grants, even with dynamic priority changes and credit exhaustion.","Functional:
  - cp_priority: bins for all PRIORITY_W values assigned and updated.
  - cp_grant_dist: bins for grant counts per requestor (low, mid, high weight).
  - cp_prio_update: bins {no_update, update_to_low, update_to_high, back-to-back, during grant, during ack}.
  - cp_credit_state: bins {full, empty, refill}.
  - cp_latency: bins {1,2} cycles.
  - cp_pointer_wrap: bins {no_wrap, wrap_once, wrap_multiple}.
  - cp_burst_len: bins {short, long}.
Cross:
  - cross_priority_x_grant: cp_priority × cp_grant_dist.
  - cross_prio_update_x_latency: cp_prio_update × cp_latency.
  - cross_credit_state_x_latency: cp_credit_state × cp_latency.
  - cross_burst_len_x_prio_update: cp_burst_len × cp_prio_update.
Code:
  - Coverage of arbitration, credit decrement/refill, pointer wrap, priority update logic, FSM transitions, and grant outputs under sustained, bursty, and dynamic stress.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17), ('weighted_round_robin_mas.pdf', 21)]"
stress_long_duration_fsm_stability_and_counter_wrap,"Run the arbitration FSM for an extended duration (e.g., 1 million cycles) to verify long-term stability, correct ARBITRATION/REPLENISH cycling, and proper handling of internal counters (credits, pointer) including wrap-around effects.","1) Reset as per spec.
2) For 1,000,000 cycles, drive req[N-1:0]=all_ones, ack=1 every cycle.
3) Every 10,000 cycles, toggle prio_upt=1 for a random requestor (seed=99), prio=rand_val.
4) Observe gnt_w, gnt_id, and track grant patterns, FSM transitions, and any anomalies.
5) Optionally, at cycle 500,000, deassert ack for 10 cycles to simulate temporary backoff, then resume.","1) No deadlock or hang: FSM always returns to ARBITRATION after REPLENISH.
2) All requestors are granted at least once per full credit cycle (zero-starvation).
3) No protocol violations; grant/ack handshakes legal.
4) No counter overflow or misbehavior (credits, pointer wrap as per spec).
5) Latency remains within spec bounds throughout.","Functional:
  - cp_duration: bins {short, medium, long}.
  - cp_counter_wrap: bins {no_wrap, wrap_once, wrap_multiple}.
  - cp_fsm_state: bins {ARBITRATION, REPLENISH}.
Cross:
  - cross_duration_x_wrap: cp_duration × cp_counter_wrap.
Code:
  - FSM, pointer, and credit counter coverage under long-run stress.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10)]"
stress_long_duration_resource_and_counter_wraparound_with_priority_update,"Run the arbitration system for an extended period (up to 1,000,000 cycles) with all requestors active, periodic priority updates, and intentional pauses to comprehensively verify long-term stability, correct pointer and credit counter wraparound, correct grant distribution proportional to priorities, and absence of deadlock, starvation, or resource leaks. The scenario stresses all resource counters (credits, priorities, pointer), exercises runtime priority updates, and validates system behavior under maximum parameterization and long-run operation.","1) Apply clk and rst as per spec; deassert rst after initialization.
2) For N=32, drive req[31:0]=32'hFFFF_FFFF (all requestors active) for T_STRESS=1,000,000 cycles.
3) Every 256 or 1,024 cycles, update prio for prio_id=(cycle/interval)%32 to prio=(cycle/interval)%16, assert prio_upt=1 for 1 cycle (interval can be swept for coverage).
4) For each grant, assert ack=1 in the next cycle.
5) At every 65,536 cycles, pause all req for 1 cycle (req=0) to test pointer and credit reset logic.
6) At cycle T_STRESS/2, set req=0 for 100 cycles (test no-grant when idle), then resume.
7) At cycle T_STRESS*3/4, update priorities for all requestors (e.g., reverse priorities), then continue.
8) Optionally, at cycle 50,000, reset all priorities to minimum (prio=0) via prio_upt for all requestors in sequence.
9) Monitor gnt_w, gnt_id, and track per-requestor grant counts, credit counter values, pointer wraparound, and system state throughout.","1) No protocol violations, deadlock, or resource overflows at any time.
2) All counters (credits, priorities, pointer) remain within legal bounds and wrap around correctly (credits ≤ 255, priorities ≤ 15, pointer ≤ 31).
3) Credit counters decrement to zero, refill to (priority+1), and wrap around correctly; no stuck or negative values.
4) All priority updates take effect and are reflected in grant distribution within 2 cycles.
5) Grant counts per requestor are proportional to their assigned priority over long duration (within ±5%).
6) No starvation: every requestor receives at least one grant per (sum of all weights) cycles.
7) No grant issued when req=0.
8) System remains responsive and stable for full duration; no loss of state or wraparound errors after long duration.","Functional:
  - cp_duration: bins {short, medium, long (up to 1M cycles)}.
  - cp_counter_value: bins {low, mid, high, near-max} for credits, priorities, pointer.
  - cp_credit_wrap: bins for number of times each credit counter wraps.
  - cp_pointer_wrap: bins for pointer near 0, near N-1, wraparound.
  - cp_prio_update_interval: bins {256, 1, 1024} (interval between updates).
  - cp_grant_distribution: cover all requestors and proportionality to priorities.
  - cp_pause: bins {no_pause, periodic_pause}.
Cross:
  - cross_counter_value_x_duration: cp_counter_value × cp_duration.
  - cross_duration_x_prio_update_interval: cp_duration × cp_prio_update_interval.
  - cross_credit_x_pointer: cp_credit_wrap × cp_pointer_wrap.
Code:
  - Coverage of all arbitration, refill, pointer, priority update, and resource management logic under long-run stress.",Parameterization and Resource Utilization Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
reset_during_active_arbitration_and_grant_state_consistency,"Assert synchronous reset (rst=1) during an active arbitration cycle, when requests are pending and/or a grant is in progress (gnt_w/gnt_id active, ack may be 0 or 1). This scenario verifies that all internal state (priority registers, credit counters, pointer) and all observable outputs (gnt_w, gnt_id) are re-initialized per spec (Table 10.3 Reset / Startup Sequence), and that no spurious, illegal, or stale grants or outputs occur. After reset deassertion (rst=0), the module must resume arbitration from a clean state, with all state and outputs legal and consistent. No deadlock, hang, or illegal state should be exposed at any time.","1) Apply clk and assert rst=1 for at least one cycle to initialize state.
2) Deassert rst (rst=0); drive req[N-1:0] with multiple active requests; optionally drive prio/prio_id/prio_upt to update priorities; allow at least one grant (observe gnt_w/gnt_id), with ack=0 or 1.
3) While requests are still active and possibly a grant is pending or in progress, assert rst=1 synchronously for one or more cycles.
4) During rst=1, observe all outputs; after 1+ cycles, deassert rst (rst=0).
5) Resume normal operation: drive requests and observe arbitration/grant behavior; optionally drive legal priority updates and requests to confirm normal operation resumes.","1) During rst=1, all outputs (gnt_w, gnt_id) reflect reset state (no grant, ID=0 or per spec); no illegal or stale state is exposed.
2) All internal state (priority, credit, pointer) is reset per spec (observable by grant behavior or debug outputs if available).
3) After rst deassertion, arbitration resumes only after proper re-initialization: priorities=0, credits=1, pointer=0 (per Table 10.3).
4) No spurious, double, or undefined grants during or immediately after reset.
5) No deadlock or hang after reset; module is ready for new arbitration cycles; legal priority updates and requests after reset are accepted and reflected in grant behavior.","Functional:
  - cp_err_type: bins {reset_during_active, reset_during_active_grant}.
  - cp_detector: bins {gnt_w_zero, gnt_id_zero, no_spurious_grant, output_state_reset, no_stale_state, grant_behavior, debug_probe}.
  - cp_fsm_state: bins {arbitration, replenish}.
  - cp_recovery: bins {arbitration_resumes, state_cleared, reset_recovery, post_reset_arbitration, reset_sequence}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.
  - cross_err_x_state: cp_err_type × cp_fsm_state.",Synchronous Reset and Initialization Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
reset_glitch_short_pulse_negative_test,"Apply a short, single-cycle synchronous reset pulse (rst=1 for 1 clk) during normal operation to test for incomplete or partial reset. Verify that all internal state is fully re-initialized and no partial/undefined state persists. Confirm that arbitration resumes correctly after reset.","1) Apply clk; assert rst=1 for at least 1 cycle at power-up to ensure initial state.
2) Deassert rst (rst=0); drive req[N-1:0] with valid requests; allow at least one arbitration cycle to complete (observe gnt_w/gnt_id).
3) Assert rst=1 for exactly 1 clk cycle (short pulse) during normal operation.
4) Deassert rst (rst=0); continue driving requests.
5) Observe outputs and arbitration behavior post-reset.","1) After the short rst pulse, all outputs (gnt_w, gnt_id) reflect reset state for at least one cycle.
2) All internal state (priority, credit, pointer) is re-initialized per spec (priority=0, credit=1, pointer=0).
3) No undefined or partial state is observed; no spurious grants or stuck outputs.
4) Arbitration resumes cleanly after reset deassertion.","Functional:
  - cp_err_type: bins {short_reset_pulse}.
  - cp_detector: bins {state_cleared, no_partial_state}.
  - cp_recovery: bins {arbitration_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Synchronous Reset and Initialization Verification,"[('weighted_round_robin_mas.pdf', 13)]"
reset_with_priority_update_violation_negative_test,"Assert synchronous reset (rst=1) in the same cycle as a priority update strobe (prio_upt=1) and/or active priority update signals. Verify that the reset operation takes precedence, all state is cleared, and no partial or unintended priority update occurs. Confirm that after reset, priorities are zeroed and arbitration resumes from a clean state.","1) Apply clk; assert rst=1 for at least 1 cycle at power-up.
2) Deassert rst (rst=0); drive req[N-1:0] and perform at least one arbitration cycle.
3) In a cycle with prio_upt=1, prio_id and prio set to valid values, simultaneously assert rst=1.
4) Hold rst=1 for at least 1 cycle, then deassert rst (rst=0).
5) Resume normal operation and observe priorities and arbitration behavior.","1) After reset, all priorities are cleared to 0, regardless of prio/prio_id/prio_upt values during reset.
2) No partial or unintended priority update occurs as a result of prio_upt coinciding with rst.
3) Arbitration resumes with all priorities at zero and credits at 1, pointer at 0.
4) No stuck or undefined state in outputs.","Functional:
  - cp_err_type: bins {reset_with_priority_update}.
  - cp_detector: bins {priority_zeroed, no_partial_update}.
  - cp_recovery: bins {arbitration_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Synchronous Reset and Initialization Verification,"[('weighted_round_robin_mas.pdf', 13)]"
negative_reset_during_active_grant_and_credit_update,"Assert rst during an active grant and credit update (i.e., while a grant is being acknowledged and credits are being decremented). Expect that all internal state (credits, priorities, pointer) is synchronously reset, and after deasserting rst, the system resumes from a known state with all credits set to 1 and priorities cleared.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize.
2) Set prio/prio_id/prio_upt for requestor 2 (e.g., prio=4'b0101, prio_id=2, prio_upt=1).
3) Assert req[2]=1, ack=1 to trigger a grant and credit decrement.
4) On the same cycle as grant/ack, assert rst=1.
5) Hold rst=1 for at least 2 cycles, then deassert rst=0.
6) Observe that all credits are set to 1, priorities are cleared, and pointer is reset to 0.
7) Resume normal arbitration and verify correct operation.","1) All credits are set to 1, priorities cleared, and pointer reset after rst is deasserted (per Table 10.3).
2) No grant is issued during rst=1.
3) After rst, arbitration resumes normally and grants are issued as expected.
4) No data corruption or deadlock occurs during or after reset.","Functional:
  - cp_err_type: bins {reset_during_active_op}.
  - cp_detector: bins {state_reset_check}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Credit-Based Scheduling and Refill Verification,"[('weighted_round_robin_mas.pdf', 4)]"
negative_ack_during_reset_sequence,"Assert ack=1 during the reset sequence (rst=1), violating the expectation that no handshakes occur during reset. Verify that the arbiter ignores ack during reset and that all state is correctly initialized after reset is deasserted.","1) Apply clk and assert rst=1 (reset active).
2) While rst=1, assert ack=1 for one or more cycles (with any req pattern).
3) Deassert rst=0 to exit reset and begin normal operation.
4) Drive valid requests and observe grant/ack cycles.
5) At the end, assert rst=1 again to confirm recovery to known state.","1) While rst=1, ack is ignored; no state update or grant occurs.
2) After rst=0, all state is initialized as per spec (priority registers cleared, credits initialized, pointer reset).
3) Normal operation resumes with valid requests and handshakes.
4) After reset, all outputs and internal state return to initial values.","Functional:
  - cp_err_type: bins {ack_during_reset}.
  - cp_detector: bins {reset_ignore, correct_init}.
  - cp_recovery: bins {normal_resume, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9)]"
negative_priority_update_during_reset,"Attempt to perform a runtime priority update (prio_upt=1, prio_id=any_valid_value, prio=any_value) while rst=1 (active reset). Expect the arbiter to ignore the update and maintain all priority registers at reset value (0) as per the reset/startup sequence. No grant should be issued until reset is deasserted, and after reset, arbitration must start from a known state. Optionally, perform a legal priority update after reset to confirm normal operation.","1) Apply clk and assert rst=1.
2) While rst=1, drive prio_upt=1, prio_id=any_valid_value, prio=any_value for one or more cycles.
3) Keep req[N-1:0]=0 (no requests) or any pattern.
4) Deassert rst=0; drive req[N-1:0] with valid requests.
5) Optionally, perform a legal priority update after reset to confirm normal operation.
6) Observe gnt_w, gnt_id, and internal state (if observable) for correct reset behavior and absence of illegal priority update effect.","1) While rst=1, no grant is issued (gnt_w=0, gnt_id=0).
2) After rst=0, all priorities are at reset value (0), regardless of prio/prio_id/prio_upt driven during reset.
3) Arbitration starts from known state; first grant is per reset state.
4) No state corruption or unexpected behavior after reset.
5) Legal priority updates after reset are accepted and reflected in grant behavior.","Functional:
  - cp_err_type: bins {prio_update_during_reset, priority_update_during_reset}.
  - cp_detector: bins {grant_output, priority_state, update_ignored, state_cleared}.
  - cp_recovery: bins {reset_reinit, legal_update_post_reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4)]"
negative_attempt_memory_mapped_register_access,"Attempt to configure the WRR arbiter via a memory-mapped register access (which is not implemented per spec). Expect that no configuration occurs, no state changes, and no outputs indicate any configuration or error. The arbiter must ignore such accesses, as only sideband signals are supported for configuration.","1) Apply clk and rst as per reset/startup sequence (rst=1 for >=1 cycle, then rst=0).
2) Drive all sideband configuration signals (prio, prio_id, prio_upt) to legal idle values (prio_upt=0).
3) Simulate an attempt to configure the arbiter by performing a memory-mapped register write (bench-level only, as there are no such ports in the DUT).
4) Observe that no configuration occurs, and all outputs (gnt_w, gnt_id) remain unchanged.
5) Optionally, perform a legal configuration via sideband signals after the negative attempt to confirm normal operation resumes.","1) No change in arbiter state or outputs (gnt_w, gnt_id) in response to the memory-mapped register access attempt.
2) No error, status, or debug outputs are asserted (since none are defined for this case).
3) Legal configuration via sideband signals after the negative attempt is processed normally, confirming no latch-up or side effect from the illegal access.","Functional:
  - cp_err_type: bins {illegal_memmap_access}.
  - cp_detector: bins {no_effect}.
  - cp_recovery: bins {sideband_config_ok_after}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Sideband Configuration Interface Verification,"[('weighted_round_robin_mas.pdf', 13)]"
negative_no_grant_progress_deadlock_assertion_violation,"Drive a scenario where requests are present but no grant is issued for multiple cycles (e.g., by holding ack low and req high). Expect assertion or monitor to detect lack of grant progress as per feature description (grant progress coverage).","1) Apply clk and assert rst=1 for at least one cycle to initialize; deassert rst to 0.
2) Drive req=all 1's (all requestors requesting), ack=0 for more than the maximum allowed cycles without a grant (per spec, e.g., N cycles).
3) Observe gnt_w and gnt_id; confirm no grant is issued for the duration.
4) Confirm assertion/monitor fires for lack of progress.
5) Optionally, assert rst to confirm system recovery.","1) Assertion/monitor fires if no grant is issued despite active requests (as per feature description and spec section 16.1).
2) No deadlock occurs; system resumes normal operation after reset.
3) After reset, grants are issued as expected for active requests.","Functional:
  - cp_err_type: bins {no_grant_progress}.
  - cp_detector: bins {assertion, monitor}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 17)]"
negative_no_request_grant_error,"Force the arbiter to issue a grant when no request lines (req[N-1:0]) are asserted, violating the requirement that no grants are issued in the absence of requests. Expectation: No grant (gnt_w, gnt_id) should be asserted when req is all zero; any grant is an error.","1) Apply clk and assert rst=1 for at least 2 cycles to initialize all state (priority, credit, pointer).
2) Deassert rst (rst=0), wait one cycle for normal operation.
3) Drive req[N-1:0]=0 (all request lines deasserted) for multiple cycles.
4) Observe gnt_w and gnt_id outputs during this period.
5) After test, optionally assert rst again to confirm recovery to known state.","1) Check that gnt_w==0 and gnt_id is either 0 or a reserved value (per spec) whenever req==0.
2) Assert that no grant is issued (no bit in gnt_w is high) for all cycles with req==0.
3) Confirm that after reset, normal arbitration resumes with legal requests.","Functional:
  - cp_err_type: bins {grant_with_no_request}.
  - cp_detector: bins {gnt_w, gnt_id}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
negative_ack_asserted_without_active_grant_spurious_ack,"Assert ack=1 when no grant is currently active (gnt_w/gnt_id=0), violating the expected protocol. Verify that the arbiter ignores spurious ack and does not update internal state or issue new grants erroneously.","1) Apply clk and assert rst=1 for at least one cycle, then deassert rst=0 to initialize the arbiter.
2) Hold req=0 (no requests active), so gnt_w and gnt_id remain 0 (no grant issued).
3) Assert ack=1 for one or more cycles while no grant is active.
4) Resume normal operation by driving valid requests and observing grant/ack cycles.
5) Optionally, repeat with different timing or after priority updates.
6) At the end, assert rst=1 to confirm recovery to known state.","1) While no grant is active, asserting ack=1 must not cause any state update, pointer advance, or credit decrement.
2) No spurious grant or state change occurs due to spurious ack.
3) Normal operation resumes when valid requests and grants are present.
4) After reset, all outputs and internal state return to initial values.","Functional:
  - cp_err_type: bins {spurious_ack}.
  - cp_detector: bins {no_state_update, no_pointer_advance}.
  - cp_recovery: bins {normal_resume, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9)]"
negative_multiple_ack_cycles_for_single_grant,"Assert ack=1 for multiple consecutive cycles without a new grant being issued (gnt_w/gnt_id unchanged), violating the expected one-to-one grant/ack protocol. Verify that only the first ack is accepted and subsequent acks are ignored until a new grant is issued.","1) Apply clk and assert rst=1 for at least one cycle, then deassert rst=0 to initialize the arbiter.
2) Drive req such that a requestor is active and a grant is issued (observe gnt_w/gnt_id).
3) Assert ack=1 for multiple consecutive cycles while gnt_w/gnt_id remain unchanged (no new grant issued).
4) Resume normal operation by deasserting ack and allowing the arbiter to issue new grants.
5) Optionally, repeat with different requestors or after priority updates.
6) At the end, assert rst=1 to confirm recovery to known state.","1) Only the first ack for a given grant is accepted; subsequent acks while grant is unchanged are ignored (no multiple state updates).
2) No credit or pointer is updated more than once per grant.
3) Normal operation resumes after correct handshake.
4) After reset, all outputs and internal state return to initial values.","Functional:
  - cp_err_type: bins {redundant_ack}.
  - cp_detector: bins {single_update, ignore_extra_ack}.
  - cp_recovery: bins {normal_resume, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9)]"
negative_ack_handshake_violation_stuck_ack,"Hold the ack input high for multiple consecutive cycles, violating the expected handshake protocol (where ack should only be asserted for a single cycle per grant). Expectation: The arbiter must not issue multiple grants for a single requestor or skip arbitration cycles; no deadlock or grant duplication occurs.","1) Apply clk and rst; initialize as per Table 10.3.
2) Assert req[i]=1 for a single requestor (all others 0).
3) Wait for gnt_w/gnt_id to indicate grant to that requestor.
4) Instead of pulsing ack for one cycle, hold ack=1 for 3 consecutive cycles.
5) Observe gnt_w/gnt_id and internal grant sequencing.
6) Afterward, deassert ack and continue normal arbitration with new requests.
7) Optionally, apply rst to confirm recovery.","1) Only one grant is issued for the requestor per request, regardless of ack being stuck high.
2) No grant duplication or skipped arbitration cycles.
3) After ack is deasserted, arbitration resumes normally.
4) No deadlock or stuck outputs.
5) After reset, all outputs return to initial state.","Functional:
  - cp_err_type: bins {ack_stuck_high}.
  - cp_detector: bins {grant_sequence, deadlock_absence}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
negative_ack_missing_after_grant_no_progress,"Intentionally withhold the ack input after a grant is issued (gnt_w/gnt_id asserted), violating the expected handshake protocol. Verify that the arbiter does not issue a new grant or update internal state until ack is received, and that no deadlock or data corruption occurs. Confirm recovery upon resumption of correct ack behavior.","1) Apply clk and assert rst=1 for at least one cycle, then deassert rst=0 to initialize the arbiter.
2) Drive req such that at least one requestor is active (e.g., req[3]=1).
3) Observe gnt_w and gnt_id: wait for a grant to be issued.
4) Do NOT assert ack after the grant is issued; hold ack=0 for several cycles, even as req remains asserted.
5) After several cycles, resume correct protocol by asserting ack=1 for one cycle, then return to normal operation.
6) Optionally, repeat with different requestors or after priority updates.
7) At the end, assert rst=1 to confirm recovery to known state.","1) While ack=0, gnt_w and gnt_id must remain stable (no new grants issued, no pointer/credit update).
2) No deadlock: after ack=1 is asserted, arbiter resumes normal operation and issues next grant as per protocol.
3) No data corruption: only the acknowledged grant is counted as accepted.
4) After reset, all outputs and internal state return to initial values (as per reset/startup sequence).","Functional:
  - cp_err_type: bins {missing_ack}.
  - cp_detector: bins {grant_stall, no_state_update}.
  - cp_recovery: bins {resume_on_ack, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9)]"
negative_req_stuck_high_no_ack_deadlock_prevention,"Hold req[N-1:0] high for all requestors without asserting ack, simulating a scenario where all requestors are requesting but never acknowledge grants. Expect the arbiter to avoid deadlock and eventually enter credit refill state as per FSM.","1) Apply clk and rst; assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0]=all 1's (all requestors requesting).
3) Do not assert ack at any time (ack=0).
4) Observe gnt_w and gnt_id for several cycles; monitor for credit exhaustion and transition to refill state.
5) After refill, optionally assert ack for one requestor to confirm recovery.","1) Arbiter cycles through grants as credits allow; after all credits exhausted, no further grants until refill.
2) Arbiter enters refill state (no grant issued for one cycle, per spec).
3) After refill, arbitration resumes; no deadlock or hang occurs.
4) No grant is issued to a requestor with zero credit.","Functional:
  - cp_err_type: bins {no_ack_deadlock_attempt}.
  - cp_detector: bins {refill_state_entered, no_deadlock}.
  - cp_recovery: bins {arbitration_resumes_post_refill}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Weighted Round Robin Arbitration Verification,"[('weighted_round_robin_mas.pdf', 3)]"
negative_priority_update_with_out_of_range_prio_id,"Attempt to update the priority of a requestor using a prio_id value outside the valid range (i.e., prio_id >= N). The arbiter must ignore the update, not corrupt internal state, and continue normal operation. No grant should be issued to a non-existent requestor, and the system must not deadlock or hang. If assertions or monitors are defined, they should detect the illegal access. Internal state observability features must not expose any illegal state, and after a legal priority update or reset, normal operation must resume.","1) Apply clk and assert rst=1 for at least one cycle to initialize the system; deassert rst to 0.
2) Drive req[N-1:0] with at least one valid requestor active (e.g., req[0]=1), ack=0.
3) On a rising clk edge, drive prio_upt=1 with prio_id set to an out-of-range value (e.g., prio_id=N or higher), prio can be any value.
4) Hold prio_upt=1 for one cycle, then deassert.
5) Observe outputs (gnt_w, gnt_id) and internal state (if observable) for any illegal behavior or state change.
6) Optionally, perform a legal priority update (prio_upt=1, prio_id in range) and confirm normal operation resumes.
7) Optionally, assert rst again to confirm recovery to a known state.","1) No grant (gnt_w, gnt_id) is ever issued to an out-of-range prio_id; gnt_id never equals invalid prio_id; gnt_w never asserts a bit outside 0..N-1.
2) No change in priority or grant behavior for any requestor as a result of the illegal prio_id update.
3) No deadlock or hang occurs; arbitration continues for legal requests.
4) No out-of-bounds write to priority register array (as observable by grant behavior or debug outputs if available).
5) Assertion or monitor fires for out-of-bounds prio_id access if defined.
6) No illegal or out-of-bounds value appears on any output or internal state observability interface.
7) After a legal priority update or reset, normal operation and state are restored.","Functional:
  - cp_err_type: bins {illegal_prio_id, out_of_bounds_prio_id, invalid_prio_id, prio_id_out_of_range}.
  - cp_detector: bins {no_effect, grant_continues, assertion, monitor, grant_output, arbitration_continuity, grant_behavior, debug_probe, gnt_id, gnt_w, no_state_change, no_illegal_output, update_ignored, no_grant}.
  - cp_recovery: bins {legal_update_ok_after, reset, silent_ignore, normal_resume, legal_update_after_fault, soft_reset, legal_update_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Sideband Configuration Interface Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_priority_update_out_of_range_value_combined,"Attempt to update a requestor's priority with a value that exceeds the configured PRIORITY_W bit-width (e.g., drive prio input with a value > 15 when PRIORITY_W=4). Verify that the arbiter ignores, clamps, or otherwise prevents illegal state per spec. No out-of-bounds write to the priority register should occur, no illegal state should be exposed or committed, and debug/QoS monitoring must not reflect the illegal value. Arbitration must continue for legal requests, and normal operation must resume after a legal update or reset.","1) Apply clk and rst; hold rst=1 for several cycles, then deassert to 0 to initialize state.
2) Drive a legal request pattern on req; ensure prio_upt=0.
3) On a rising clk edge, drive prio_id to a valid requestor, prio_upt=1, and prio input to a value greater than allowed (e.g., 0x1F or 16 for PRIORITY_W=4).
4) Hold req, ack, and other inputs at legal idle values during this operation.
5) Observe outputs for at least one arbitration cycle to confirm no illegal state or grant occurs.
6) Optionally, perform a legal priority update afterward to confirm normal operation resumes.
7) Optionally, perform a soft reset to confirm recovery and that all state returns to initial values.","1) No out-of-bounds write to the priority register (as observable by grant behavior or debug outputs if available).
2) No illegal value appears on any output (gnt_w, gnt_id, debug/QoS probes).
3) No deadlock or hang; arbitration continues for legal requests.
4) Grant pattern does not reflect illegal priority value.
5) After a legal priority update, correct state change is observed and arbiter resumes normal operation.
6) After reset, all state returns to initial values.","Functional:
  - cp_err_type: bins {priority_overflow, illegal_prio_value, priority_out_of_range}.
  - cp_detector: bins {grant_behavior, debug_probe, no_state_change, no_illegal_output, no_grant, ignore_update}.
  - cp_recovery: bins {legal_update_after_fault, soft_reset, legal_update_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Parameterization and Resource Utilization Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_priority_update_with_stuck_prio_upt,"Drive prio_upt=1 continuously for multiple cycles (instead of a single strobe), with prio_id and prio held constant or toggled. Expect the arbiter to update the priority only once per strobe or per spec, and not to misbehave (e.g., multiple updates, state corruption, or arbitration stall).","1) Apply clk and assert rst=1 for at least one cycle; deassert rst=0.
2) Drive req[N-1:0] with at least one valid requestor active.
3) On a clock edge, drive prio_upt=1, prio_id=valid_value, prio=valid_value, and hold prio_upt=1 for several cycles.
4) Optionally, toggle prio_id/prio during the stuck prio_upt period.
5) After several cycles, deassert prio_upt=0 and continue normal arbitration.
6) Observe gnt_w, gnt_id, and arbitration behavior for correctness.","1) Priority register for prio_id is updated only once per intended strobe, or per spec-defined behavior.
2) No state corruption or multiple unintended updates.
3) Arbitration for all requestors continues without deadlock or stall.
4) No grant is issued to an unintended requestor due to stuck prio_upt.","Functional:
  - cp_err_type: bins {stuck_prio_upt}.
  - cp_detector: bins {priority_state, grant_output}.
  - cp_recovery: bins {normal_resume}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 4)]"
negative_no_security_on_priority_update_access,"Attempt to update the priority of a requestor using the prio, prio_id, and prio_upt inputs without any form of access control or authentication. The expectation is that the design does not differentiate between secure and non-secure accesses and accepts all updates without restriction or error reporting.","1) Apply clk and rst; assert rst for at least one cycle, then deassert to initialize the design.
2) Drive prio_upt=1 with prio_id and prio set to arbitrary values, simulating an unauthorized or spurious update.
3) Observe the system for any error reporting, access denial, or containment behavior.
4) Continue normal operation and observe if the update is accepted and reflected in arbitration decisions.","1) No error output, status flag, or interrupt is asserted (since none are implemented per spec).
2) The priority update is accepted and takes effect regardless of the source or context.
3) Arbitration behavior changes according to the new priority value.
4) No deadlock or hang occurs; arbitration continues.","Functional:
  - cp_err_type: bins {unauthorized_priority_update}.
  - cp_detector: bins {no_detection}.
  - cp_recovery: bins {none_needed}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Absence of Built-in Error Correction or Security Verification,"[('weighted_round_robin_mas.pdf', 11)]"
negative_no_error_detection_on_corrupted_priority_update,"Intentionally drive out-of-range or corrupted values on the priority update interface (prio, prio_id, prio_upt) to simulate a data integrity fault. Since the feature under test is the absence of error correction or security, the expectation is that the design does not detect, report, or contain the error, and the corrupted value is accepted as-is, potentially leading to incorrect arbitration behavior.","1) Apply clk and rst; assert rst for at least one cycle, then deassert to initialize the design.
2) Drive legal req and ack signals to establish normal arbitration operation.
3) Assert prio_upt=1 with prio_id set to an out-of-range value (e.g., all 1's, which is greater than N-1) and prio set to a legal value.
4) Observe the system for any error reporting, containment, or recovery behavior.
5) Optionally, repeat with prio set to an out-of-range value (e.g., all 1's, greater than allowed by PRIORITY_W).
6) After the fault injection, continue normal operation and observe if the system recovers or continues with corrupted state.","1) No error output, status flag, or interrupt is asserted (since none are implemented per spec).
2) The corrupted priority or requestor ID is accepted and used in arbitration, potentially causing incorrect grant behavior.
3) No deadlock or hang occurs; arbitration continues.
4) After reset, the system returns to a known state (priority registers cleared, credits initialized).","Functional:
  - cp_err_type: bins {corrupted_priority, out_of_range_id}.
  - cp_detector: bins {no_detection}.
  - cp_recovery: bins {reset_only}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Absence of Built-in Error Correction or Security Verification,"[('weighted_round_robin_mas.pdf', 11)]"
negative_no_fault_containment_on_corrupted_credit_counter,"Simulate a fault by causing the credit counter for a requestor to overflow or underflow via legal port operations (e.g., repeated grants or priority updates). The expectation is that the design does not detect or contain such faults, and the counter may wrap or behave incorrectly without error reporting or recovery.","1) Apply clk and rst; assert rst for at least one cycle, then deassert to initialize the design.
2) For a selected requestor, repeatedly drive req and ack to consume credits until the counter reaches zero.
3) Continue to drive grants or priority updates to attempt to cause an underflow or overflow (e.g., by updating priority to maximum and observing credit refill behavior).
4) Observe the system for any error reporting, containment, or recovery behavior.
5) After the fault, perform a reset and confirm that the system returns to a known state.","1) No error output, status flag, or interrupt is asserted (since none are implemented per spec).
2) Credit counter may wrap or behave incorrectly, but no containment or correction occurs.
3) Arbitration continues, possibly with incorrect behavior.
4) After reset, credit counters are re-initialized as specified.","Functional:
  - cp_err_type: bins {credit_overflow, credit_underflow}.
  - cp_detector: bins {no_detection}.
  - cp_recovery: bins {reset_only}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Absence of Built-in Error Correction or Security Verification,"[('weighted_round_robin_mas.pdf', 11)]"
negative_parameter_overflow_credit_width,"Attempt to update a requestor's priority to a value that would cause the credit counter to overflow CREDIT_W (e.g., set prio to 255 when CREDIT_W=8). Expect the credit refill logic to clamp or ignore values that would exceed the 8-bit credit counter, per spec. No overflow or wraparound should occur.","1) Apply clk and rst; hold rst=1 for several cycles, then deassert to 0.
2) Drive a legal request pattern on req; ensure prio_upt=0.
3) On a rising clk edge, drive prio_id to a valid requestor, prio_upt=1, and prio input to 255 (0xFF).
4) Observe arbitration cycles until credit refill occurs for that requestor.
5) Optionally, perform a legal priority update afterward to confirm normal operation resumes.","1) Credit counter for the requestor does not overflow or wrap; refill value is clamped to 8 bits (<=255).
2) No deadlock or hang; arbitration continues for legal requests.
3) Grant pattern does not reflect illegal credit values.
4) Legal priority update after fault is accepted and reflected in grant behavior.","Functional:
  - cp_err_type: bins {credit_overflow}.
  - cp_detector: bins {credit_counter_behavior, grant_behavior}.
  - cp_recovery: bins {legal_update_after_fault}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Parameterization and Resource Utilization Verification,"[('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_illegal_request_vector_width,"Drive more than N bits on the req input vector (e.g., drive 33 bits when N=32). Expect the arbiter to ignore or mask out-of-range bits and not perform any out-of-bounds access. Only the lower N bits should be considered for arbitration.","1) Apply clk and rst; hold rst=1 for several cycles, then deassert to 0.
2) On a rising clk edge, drive req input with 33 bits, with the 33rd bit set high (req[32]=1), and legal values for the lower 32 bits.
3) Observe outputs for at least one arbitration cycle.
4) Optionally, drive a legal req vector afterward to confirm normal operation resumes.","1) Only lower N=32 bits of req are considered for arbitration; no out-of-bounds access or grant to non-existent requestor.
2) No deadlock or hang; arbitration continues for legal requests.
3) Grant pattern does not reflect any change for illegal req bits.
4) Legal req vector after fault is accepted and reflected in grant behavior.","Functional:
  - cp_err_type: bins {req_vector_overflow}.
  - cp_detector: bins {grant_behavior}.
  - cp_recovery: bins {legal_req_after_fault}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Parameterization and Resource Utilization Verification,"[('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_pointer_range_violation_assertion_violation,"Force the round-robin pointer (internal, but observable via grant outputs) to wrap or increment beyond the legal range (0..N-1) by manipulating req and ack patterns. Expect assertion or monitor to detect pointer out-of-range as per feature description and spec.","1) Apply clk and assert rst=1 for at least one cycle to initialize; deassert rst to 0.
2) Drive req patterns that cause the pointer to increment each cycle (e.g., req=all 1's, ack=1 every cycle) for more than N cycles.
3) Observe grant outputs (gnt_w, gnt_id) for any indication of pointer out-of-range (e.g., grant to non-existent requestor, illegal encoding).
4) Confirm assertion/monitor fires if pointer exceeds N-1.
5) Optionally, assert rst to confirm system recovery.","1) Assertion/monitor fires if pointer exceeds legal range (as per feature description and spec section 16.1).
2) No grant is issued to non-existent requestors.
3) System continues to arbitrate for legal requestors; no deadlock.
4) After reset, pointer and outputs return to legal values.","Functional:
  - cp_err_type: bins {pointer_out_of_range}.
  - cp_detector: bins {assertion, monitor}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 17)]"
negative_credit_counter_underflow_and_no_grant_until_correct_refill,"Force a requestor's credit counter to underflow by repeatedly granting it until its credits are exhausted, then continue to assert its request and acknowledge more times than credits available. Expect that no further grants are issued to this requestor until the credit refill logic triggers, at which point credits are replenished according to the priority value. Verify that the arbiter prevents underflow, no starvation or deadlock occurs, and the refill is proportional to the assigned weight. After reset, all credits should be restored to initial values.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the system.
2) Set prio/prio_id/prio_upt to assign a known priority (e.g., prio=4'b0011 for requestor 0, prio_id=0, prio_upt=1 for one cycle).
3) Assert req[0]=1 (all others 0), ack=1 every cycle, to ensure requestor 0 is granted repeatedly.
4) Continue until credit for requestor 0 is exhausted (should be prio+1 grants).
5) Keep req[0]=1 and continue to assert ack=1 for more cycles than the credit value, simulating attempts to grant with zero credit.
6) Observe that gnt_w[0]=0 and gnt_id!=0 after credits reach zero.
7) Wait for the refill event (per FSM, REPLENISH state), then observe that credits are replenished and grants resume.
8) Optionally, repeat for other requestors or with different priorities.
9) After test, assert rst=1 to recover and confirm all credits reset to 1.","1) gnt_w and gnt_id grant to requestor only as many times as credits allow (prio+1).
2) After credits are exhausted, no further grants to the requestor until refill occurs (gnt_w[0]=0, gnt_id!=0).
3) No underflow or wraparound in grant behavior.
4) Upon refill, credits for the requestor are set to prio+1, and grants resume.
5) No deadlock: other requestors can still be granted if they have credits.
6) After rst, all credits are reset to 1 and arbitration resumes normally.
7) No data corruption or hang occurs during or after the fault injection.","Functional:
  - cp_err_type: bins {credit_underflow, credit_underflow_attempt}.
  - cp_detector: bins {grant_blocked, refill_event, no_underflow}.
  - cp_recovery: bins {credit_refill, reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Credit-Based Scheduling and Refill Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4)]"
negative_credit_refill_latency_violation,"Intentionally force the arbiter into a credit refill condition by exhausting all credits, then inject a new request immediately after refill is triggered to test if the pipeline ever exceeds the specified 2-cycle worst-case latency. Expectation: No grant is issued before refill completes, and no grant is delayed beyond 2 cycles per spec.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0 to initialize all state (per Table 10.3 Reset / Startup Sequence).
2) Drive req[N-1:0] such that all requestors are active and all credits are exhausted (simulate a long burst until credits reach 0 for all requestors).
3) Observe that the arbiter enters the REPLENISH state (per FSM spec) and triggers credit refill.
4) Immediately after refill is triggered, assert a new request on one requestor (req[i]=1) and keep all others at 0.
5) Observe gnt_w and gnt_id for the next 3 cycles.
6) After refill, return to normal operation and confirm grants resume with correct latency.
7) Optionally, apply rst again to confirm recovery to known state.","1) No grant (gnt_w, gnt_id) is issued during the refill cycle (per Table 12.2 Latency: 2 cycles for refill).
2) The first grant after refill is issued exactly 2 cycles after the refill is triggered (never more, never less).
3) No deadlock: after refill, normal arbitration resumes and grants are issued per request.
4) After reset, all outputs return to initial state (no stuck grants, no deadlock).","Functional:
  - cp_err_type: bins {credit_refill_latency_violation}.
  - cp_detector: bins {grant_timing, deadlock_absence}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
priority_update_during_credit_refill_and_replenish_state,"Apply a dynamic priority update (prio_upt=1 with valid prio/prio_id) for a requestor exactly during the credit refill or REPLENISH state, which is not a typical operation per spec examples. This tests whether the FSM, arbitration, and credit logic handle out-of-sequence or illegal timing of priority updates robustly, without corrupting state, causing deadlock, or assigning mismatched credits. Expectation: The arbiter must not miscompute credits or priorities, must resume correct arbitration after refill, and must reflect the updated priority in subsequent grants if allowed by spec.","1) Apply clk and rst; initialize as per Table 10.3.
2) Drive req such that all credits are exhausted for at least one requestor, forcing the arbiter into REPLENISH/credit refill state.
3) During the refill cycle (REPLENISH state), assert prio_upt=1, prio_id=valid, and prio=valid value for a chosen requestor for one cycle.
4) Observe gnt_w/gnt_id and arbitration behavior for the next several cycles.
5) After refill, continue with normal requests and observe grant pattern and credit assignment for the affected requestor.
6) Optionally, apply rst to confirm recovery and that all outputs and credits return to initial state.","1) FSM must not deadlock or produce undefined outputs due to priority update during REPLENISH/refill.
2) After refill, credits for the affected requestor are set to the updated prio+1 value if spec allows, or the update is ignored safely.
3) No stale or mismatched credits are assigned; grant frequency for the requestor matches the new priority if applied.
4) No deadlock or mis-sequencing of grants; arbitration resumes correctly.
5) After reset, all state and credits return to initial values.","Functional:
  - cp_err_type: bins {priority_update_during_refill, prio_update_during_replenish}.
  - cp_detector: bins {grant_pattern, credit_value, credit_value_check, grant_frequency}.
  - cp_fsm_state: bins {replenish}.
  - cp_recovery: bins {reset, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_state: cp_err_type × cp_fsm_state.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
negative_simultaneous_priority_update_and_acknowledge_hazard_injection,"Intentionally apply simultaneous assertion of prio_upt (priority update strobe) and ack (grant acknowledge) in the same clock cycle, with overlapping or conflicting target requestors, to verify that the arbiter handles both operations without functional hazards (e.g., lost update, double grant, or credit mis-accounting). Expectation: No hazard occurs, grant and priority update are both processed correctly, and system remains deadlock-free.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst to 0 to enter normal operation.
2) Drive req[N-1:0] with at least two active requests (e.g., req[1]=1, req[2]=1).
3) Allow arbitration to proceed until a grant is issued (observe gnt_w, gnt_id).
4) On the next rising clk edge, simultaneously assert ack=1 (to acknowledge the current grant) and prio_upt=1 with prio_id set to the currently granted requestor, and prio set to a new legal value (e.g., prio=4'b1000).
5) Hold prio_upt and ack for exactly one cycle, then deassert both.
6) Continue driving requests and observe outputs for several cycles to confirm correct operation.
7) Optionally, repeat with prio_id targeting a different requestor than the one being acknowledged.
8) After fault injection, optionally assert rst=1 to confirm clean recovery to initial state.","1) No deadlock or hang: gnt_w and gnt_id continue to update in subsequent cycles.
2) The priority register for prio_id is updated to the new value (can be inferred by observing subsequent grant patterns favoring the updated requestor).
3) The grant acknowledge (ack) is processed: credit is decremented for the granted requestor, and pointer advances as per spec.
4) No double grant or skipped requestor: only one grant per cycle, and all requestors eventually receive grants per round-robin fairness.
5) After reset, all state returns to initial values (priority=0, credits=1, pointer=0).","Functional:
  - cp_err_type: bins {simultaneous_prio_update_and_ack}.
  - cp_detector: bins {grant_output, priority_update_effect, credit_update, pointer_update}.
  - cp_recovery: bins {normal_progress, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Simultaneous Priority Update and Grant Acknowledge Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 21)]"
grant_encoding_mismatch_and_consistency_error_detection,"Verify that the one-hot grant output (gnt_w) and the encoded grant ID (gnt_id) always correspond to the same requestor for all legal and corner-case request patterns. Intentionally force or observe scenarios where gnt_w and gnt_id may not match, such as by driving conflicting or multiple request patterns, and confirm that the DUT either never produces such mismatches or that assertions/monitors detect and report the error. Also confirm that the system recovers to a legal state after reset.","1) Apply clk and assert rst=1 for at least one cycle to initialize; deassert rst to 0.
2) Drive a variety of legal req patterns, including single active bits (e.g., req=1<<i for i=0..N-1) and multiple simultaneous requests (e.g., req=0x3, 0xF, etc.), with ack=0.
3) For each pattern, observe gnt_w and gnt_id for several cycles, confirming correct correspondence.
4) Intentionally force or monitor for cycles where gnt_w and gnt_id do not match (e.g., gnt_w=3'b010, gnt_id=2'b00).
5) Confirm that assertion/monitor detects any mismatch, or that no such mismatch occurs.
6) Assert rst again and confirm outputs return to known, legal state.","1) Assertion/monitor fires if gnt_w and gnt_id do not match (as per spec section 16.1).
2) For every arbitration cycle, check that if gnt_w is one-hot at position i, then gnt_id equals i.
3) No illegal grant is issued; system does not deadlock or hang.
4) After reset, outputs return to legal, matching values.","Functional:
  - cp_err_type: bins {grant_encoding_mismatch, grant_encoding_inconsistency}.
  - cp_detector: bins {assertion, monitor, output_observation}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 17)]"
fsm_stuck_in_replenish_due_to_illegal_req_pattern,"Force the FSM into REPLENISH state by holding all req inputs low (no requestors active), then immediately assert all req bits high before credits are refilled. This tests whether the FSM can recover and transition back to ARBITRATION correctly, or if it becomes stuck or misbehaves due to an unexpected req pattern during REPLENISH.","1) Apply clk and assert rst=1 for at least one cycle to initialize FSM and all registers (per spec 10.3 Reset / Startup Sequence).
2) Deassert rst (rst=0), drive all req[N-1:0]=0 (no requests), ack=0, prio_upt=0.
3) Wait until FSM enters REPLENISH (no eligible requestors, per FSM spec).
4) Before credits are refilled (i.e., in the first cycle of REPLENISH), abruptly drive req[N-1:0]=all 1's (all requestors active).
5) Observe gnt_w, gnt_id for at least 2 cycles.
6) After test, assert rst=1 to recover and confirm FSM returns to initial state.","1) FSM must not remain stuck in REPLENISH; it must transition back to ARBITRATION after credit refill, even if req changes unexpectedly.
2) gnt_w and gnt_id must reflect a valid grant after recovery, with no deadlock or undefined output.
3) After reset, all outputs and FSM state must return to initial values (per spec Table 10.3).","Functional:
  - cp_err_type: bins {illegal_req_during_replenish}.
  - cp_fsm_transition: bins {replenish_to_arbitration}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_transition: cp_err_type × cp_fsm_transition.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10)]"
negative_starvation_or_unfairness_under_continuous_requests,Drive continuous requests from all requestors but manipulate priorities and acks to attempt to starve a requestor or break fairness. Expectation: Arbiter must guarantee zero starvation and fairness; all active requestors must eventually receive grants according to their weights.,"1) Apply clk and assert rst=1 for at least 2 cycles to initialize state.
2) Deassert rst (rst=0), wait one cycle.
3) Set all priorities to minimum (prio=1 for all) via prio/prio_id/prio_upt.
4) Drive req[N-1:0]=all_ones (all requestors requesting) for many cycles.
5) For a subset of requestors, never assert ack after grant (simulate a stuck requestor), while for others, always ack immediately.
6) Observe if any requestor is starved (never granted) or if grant pattern is unfair.
7) After test, assert rst to confirm recovery.","1) For all active requestors, check that each is granted within a bounded number of cycles (per fairness/zero-starvation guarantee).
2) Confirm that no requestor is permanently starved, regardless of ack behavior.
3) After reset, arbitration resumes normally for all requestors.","Functional:
  - cp_err_type: bins {starvation, unfair_grant}.
  - cp_detector: bins {grant_pattern, starvation_counter}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
negative_illegal_queueing_behavior_detection,"Attempt to provoke or detect any non-deterministic, queue-like behavior by applying rapid, overlapping requests and priority updates, then observing for any evidence of internal buffering (e.g., delayed or out-of-order grants) that would violate the 'No Internal Queues or FIFOs' feature. Expectation: The arbiter must always respond deterministically, with no evidence of internal queueing or buffering effects, as all state must be held in synchronous flip-flops only.","1) Apply clk and assert rst=1 for at least 2 cycles to ensure all state is initialized (priority registers cleared, credit registers set to 1, pointer reset to 0).
2) Deassert rst (rst=0) and begin normal arbitration cycles.
3) Simultaneously assert multiple req[N-1:0] bits (e.g., set several requestors active at once), and issue prio_upt=1 with prio/prio_id targeting a requestor whose request is also active, all in the same cycle.
4) Continue to toggle req and prio/prio_upt in rapid succession, including cycles where prio_upt and ack are asserted together, to maximize the chance of exposing any queueing or buffering.
5) Observe gnt_w and gnt_id on every cycle for deterministic, cycle-accurate response (no delayed or reordered grants).
6) After several cycles, assert rst again to confirm recovery to known state.","1) For every cycle, check that gnt_w and gnt_id reflect only the current req, prio, and credit state with no evidence of delayed or buffered requests (i.e., no grant to a requestor whose req was deasserted in a prior cycle, no grant order inversion).
2) Confirm that after rst is reasserted, all outputs return to initial state within 1 cycle (per reset/startup sequence).
3) No deadlock or hang occurs at any point.
4) No grant is issued for a requestor whose req is not currently asserted.
5) No grant is issued out of order relative to the round-robin and weight logic as defined in the spec.","Functional:
  - cp_err_type: bins {queueing_detected, deterministic_ok}.
  - cp_detector: bins {grant_order, grant_timing}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",No Internal Queues or FIFOs Verification,"[('weighted_round_robin_mas.pdf', 13)]"
corner_reset_and_extreme_req_patterns_no_and_all_requests,"Verify that after synchronous reset, the arbiter correctly handles both minimum (no requests) and maximum (all requests) legal req patterns, as well as the case where all req inputs are deasserted (0), ensuring that no spurious grants are issued when there are no requests and correct grant behavior occurs when all or one-hot requests are present. This covers the legal input range at startup and during normal operation, ensuring correct grant/no-grant behavior at these boundaries.","1) Apply clk; assert rst=1 for 4 cycles, then deassert rst=0.
2) Set all priorities to arbitrary legal values (e.g., prio=8 for all, prio_upt=1, prio_id=0..31 in sequence).
3) On the first clk rising edge after rst=0, drive req=32'b0 (all zeros); observe gnt_w and gnt_id for 100 cycles, drive ack=0 throughout.
4) On the next reset sequence, repeat with req=32'hFFFFFFFF (all ones); observe gnt_w and gnt_id.
5) Optionally, repeat with req=one_hot for each requestor (e.g., req=32'b000...1, req=32'b000...10, etc.) to check pointer/grant logic.","1) For req=all zeros, gnt_w==0 and gnt_id==0 on every cycle; confirm that no grant is issued for any requestor during the window.
2) For req=all ones, gnt_w=1 at pointer=0 (requestor 0), gnt_id=0 (grant to requestor 0, as pointer=0, credit=1, priority=0).
3) For each one-hot req, grant is to the active requestor if pointer matches.
4) No spurious grants or glitches on outputs.","Functional:
  - cp_req: bin {all_zero} for req input.
  - cp_req_pattern: bins {all_zeros, all_ones, one_hot_each} at first arbitration after reset.
  - cp_gnt: bin {all_zero} for gnt_w output.
  - cp_grant_behavior: bins {no_grant, grant_to_0, grant_to_n}.
Cross:
  - cross_req_x_gnt: cp_req × cp_gnt.
  - cross_req_pattern_x_grant_behavior.
Code:
  - Statement/branch/toggle in grant suppression logic.
  - Arbitration logic, pointer initialization, and grant output coverage.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 13)]"
corner_minimum_priority_and_credit_reset_and_refill_behavior,"Verify correct operation of the arbitration logic at the minimum legal values for priority (prio=0) and credit (credit=1 after reset), including reset/startup sequence, arbitration, credit exhaustion, and credit refill behavior. This scenario ensures that after synchronous reset, all priority registers are cleared to 0, credit registers are initialized to 1, pointer is reset to 0, and that the credit refill logic operates correctly at the lower boundary (prio=0, credit=1). Arbitration and grant logic must function as specified, including correct latency and no protocol violations.","1) Apply clk; assert rst=1 for at least 2-4 cycles to initialize all state.
2) During rst=1, observe that no grants are issued (gnt_w=0, gnt_id=0).
3) Deassert rst=0.
4) For all requestors, set prio[i]=0 via prio/prio_id/prio_upt (for i=0..N-1).
5) Drive req[0]=1, req[1..N-1]=0 (only requestor 0 active), ack=1. Observe gnt_w and gnt_id in the first arbitration cycle after reset.
6) After credit is exhausted for requestor 0 (should be after 1 grant), keep req[0]=1 and observe that no grant is issued until credit is refilled.
7) Repeat with all req[N-1:0]=1, ack=1 for N cycles to exhaust all credits. After all credits are exhausted, keep req[N-1:0]=1, ack=0, and observe that after 1 cycle with no grant (refill), a grant is issued on the next cycle, and credits are refilled to 1.","1) Confirm that after reset, only one grant is issued to #0 (gnt_w=1, gnt_id=0), and no grants are issued during rst=1.
2) gnt_id==0 only when credit is available; no grant when credit is 0.
3) Credit is refilled to prio+1=1 after exhaustion, as per spec, for all requestors.
4) After all credits are exhausted, there is exactly 1 cycle with no grant, then a grant is issued (latency=2 cycles from req to grant).
5) Ensure arbitration resumes correctly with round-robin pointer after refill.
6) No protocol violations, no underflow or negative credit values observed.","Functional:
  - cp_reset: bins {rst_active, rst_release}.
  - cp_prio_val: bins {min=0}.
  - cp_credit_init: bins {credit=1} after reset.
  - cp_credit_refill: bins {refill_to_1}.
  - cp_gnt_id: bins {0}.
Cross:
  - cross_reset_x_credit: cp_reset × cp_credit_init.
  - cross_prio_val_x_credit_val: cp_prio_val × cp_credit_init.
  - cross_prio_x_credit_refill: cp_prio_val × cp_credit_refill.
Code:
  - Reset logic, credit/priority/pointer initialization, toggle/branch in credit refill and grant logic at min values.",Weighted Round Robin Arbitration Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
corner_priority_update_id_boundary,"Verify that priority updates at the legal minimum and maximum prio_id values (0 and N-1) are accepted and correctly update the priority register, ensuring no out-of-bounds access. This exercises the legal address boundary for the prio_id field, which is a classic corner for register arrays.","1) Drive clk continuously; assert rst=1 for 4 cycles, then deassert rst=0.
2) For prio_id=0 and prio_id=N-1 (with N=32):
   a) Set prio_upt=1 for one clk cycle, prio_id to 0 (then N-1), prio to a legal value (e.g., 0x0, 0xF).
   b) Deassert prio_upt after 1 cycle.
3) For each update, issue a request (req[N-1:0]) with only the updated requestor bit set to 1, others 0.
4) Observe gnt_w and gnt_id for correct grant behavior in subsequent cycles.","1) Confirm that after each prio update, the next grant (gnt_w, gnt_id) reflects the updated priority for the correct requestor (0 or N-1).
2) Ensure no grant is ever issued to an out-of-bounds requestor (i.e., gnt_id never exceeds N-1).
3) Scoreboard: For each prio_id update, check that only the intended requestor's priority is affected (by observing grant behavior).","Functional:
  - cp_prio_id: bins {min=0, max=N-1}.
  - cp_prio_val: bins {min=0x0, max=0xF}.
Cross:
  - cross_prio_id_x_prio_val: cp_prio_id × cp_prio_val.
Code:
  - Priority register file address decode and update logic.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 17)]"
corner_sideband_config_min_max_priority_update,"Verify that the minimum and maximum legal priority values can be set for a requestor via the sideband configuration interface (prio/prio_id/prio_upt), and that the configuration is effective immediately, with no memory-mapped register access. This exercises the legal boundary of configuration via sideband only, as required by the spec.","1) Drive clk continuously; assert rst=1 for 4 cycles, then deassert rst=0.
2) For a selected requestor (e.g., prio_id=0):
   a) Set prio=0 (minimum legal value), prio_id=0, prio_upt=1 for one clk cycle.
   b) Set prio_upt=0 for at least 1 cycle.
   c) Set prio=15 (maximum legal value for PRIORITY_W=4), prio_id=0, prio_upt=1 for one clk cycle.
   d) Set prio_upt=0 for at least 1 cycle.
3) Throughout, ensure no memory-mapped register access is performed (not possible via available ports).
4) Optionally, issue req[0]=1 to observe grant behavior after each update.","1) After each prio/prio_id/prio_upt transaction, observe that the grant behavior (gnt_w, gnt_id) reflects the updated priority value for the selected requestor.
2) Confirm that no configuration is possible via any memory-mapped register (no such ports exist).
3) Check that only sideband signals (prio, prio_id, prio_upt) affect configuration.
4) Scoreboard: For each update, expected priority value is applied and reflected in arbitration outcome.","Functional:
  - cp_prio_value: bins {min=0, max=15} on prio input.
  - cp_prio_upt: bin for prio_upt pulse at each boundary value.
Cross:
  - cross_prio_value_x_gnt: cp_prio_value × observed gnt_id/gnt_w behavior.
Code:
  - Toggle/branch coverage in priority update logic and grant selection.",Sideband Configuration Interface Verification,"[('weighted_round_robin_mas.pdf', 13)]"
corner_credit_counter_min_max,"Verify that the credit counter for a requestor correctly handles the legal minimum (0) and maximum (2^CREDIT_W-1) values, and that grant/refill logic operates correctly at these boundaries. This exercises the legal range of the credit counter.","1) Drive clk; assert rst=1 for 4 cycles, then deassert rst=0.
2) For a selected requestor (e.g., req[0]=1):
   a) Set prio=0xF (max), prio_id=0, prio_upt=1 for 1 cycle to set max weight.
   b) Issue grants (ack=1) for 16 cycles to decrement credit to 0 (since initial credit=prio+1=16).
   c) Observe gnt_w/gnt_id; after credit reaches 0, confirm no grant until refill.
   d) After refill (per spec, triggered when all credits=0), confirm credit is restored to prio+1 and grants resume.
3) Repeat for prio=0x0 (min), prio_id=0, prio_upt=1, and verify min credit behavior (credit=1).","1) For prio=0xF, credit decrements from 16 to 0, then refills to 16.
2) For prio=0x0, credit decrements from 1 to 0, then refills to 1.
3) No grant is issued when credit=0 until refill.
4) After refill, grant resumes as expected.","Functional:
  - cp_credit_val: bins {min=1, max=16}.
  - cp_prio_val: bins {min=0x0, max=0xF}.
Cross:
  - cross_credit_val_x_prio_val: cp_credit_val × cp_prio_val.
Code:
  - Credit counter decrement, zero detect, and refill logic.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 17)]"
corner_grant_encoding_min_max_requestor_consistency,"Verify that at the legal extremes of requestor index (minimum ID 0 and maximum ID N-1), the one-hot grant output (gnt_w) and encoded grant ID (gnt_id) are always consistent and within range, especially when only one requestor is active. This exercises the encoding/decoding logic at the edges of the ID range, which are classic corner cases for off-by-one or width errors. The scenario ensures that gnt_w and gnt_id always correspond to the same granted requestor, with no illegal values or mismatches, and that no spurious grants or out-of-range encodings occur.","1) Drive clk; assert rst=1 for at least 2-4 cycles, then deassert rst=0.
2) For each boundary requestor (ID 0 and ID N-1):
   a) Set req to one-hot with only the boundary bit set (e.g., req[0]=1, all others 0; req[N-1]=1, all others 0).
   b) Set all other inputs (ack, prio, prio_id, prio_upt) to 0.
   c) Drive req vector accordingly for several cycles.
   d) Wait for at least 1 arbitration cycle (spec: normal latency is 1 cycle).
   e) Observe gnt_w and gnt_id on each arbitration cycle.
   f) Assert ack=1 for 1 cycle to accept the grant, then deassert; repeat with ack=0 to test grant persistence.
   g) Repeat for both min and max IDs, with at least 1 idle cycle between tests.","1) For each test, check that exactly one bit is set in gnt_w and that its position matches the expected requestor (0 or N-1).
2) Check that gnt_id equals the binary encoding of the granted requestor (0 or N-1).
3) Check that gnt_w and gnt_id always correspond to the same requestor in the same cycle.
4) No other bits in gnt_w are ever set; gnt_id never exceeds N-1.
5) Grant is only issued when req is asserted and credit is available (per spec).
6) No spurious grants (gnt_w==0) or illegal encodings (gnt_id out of range) occur.","Functional:
  - cp_req_idx / cp_req_id: bins {min=0, max=N-1}.
  - cp_gnt_id: bins {min=0, max=N-1}.
  - cp_gnt_w: bins {min=0x00000001, max=0x80000000}.
Cross:
  - cross_req_idx_x_gnt_id / cross_req_id_x_gnt_id: cp_req_idx × cp_gnt_id (should always match).
Code:
  - Statement/branch/toggle in grant encoding/decoding logic for min/max indices.
  - Grant encoding/decoding logic at array boundaries.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 17)]"
corner_pointer_and_fsm_wraparound_observability,"Verify that the round-robin pointer and arbitration FSM correctly handle wraparound at the legal maximum (N-1) back to 0, ensuring no out-of-bounds pointer values, correct grant cycling at the array boundary, no illegal FSM state or starvation, and that all transitions are observable on grant outputs (gnt_w, gnt_id). This ensures pointer stays in range, wraps at the legal boundary, and is observable for debug/QoS monitoring.","1) Drive clk; assert rst=1 for 2-4 cycles, then deassert rst=0.
2) Set all prio=1 (prio_id=0..N-1, prio=1, prio_upt=1 per requestor, one per cycle).
3) Drive req[N-1:0]=all 1's (all requestors active) for at least N+2 cycles.
4) For each grant, drive ack=1 for the granted requestor.
5) Issue grants/acks to cycle pointer through all N positions, observing gnt_id and gnt_w.
6) After pointer reaches N-1, next arbitration should wrap to 0; repeat with req[0]=1 and req[N-1]=1 to confirm wraparound at both ends.
7) Observe FSM remains in ARBITRATION throughout unless all credits are zero.","1) The sequence of gnt_id over N cycles covers all values 0..N-1 exactly once before repeating (fairness, no skips or repeats).
2) No gnt_id value ever exceeds N-1 or is negative.
3) After N cycles, the next grant is to 0 (wraparound), confirming pointer range and wrap logic.
4) No illegal gnt_id or gnt_w values.
5) No starvation: each requestor is granted in turn.
6) FSM remains in ARBITRATION (no REPLENISH unless all credits zero).
7) All pointer and grant transitions are observable on gnt_w/gnt_id outputs.","Functional:
  - cp_gnt_id_seq: bins {0..N-1}.
  - cp_wraparound: bin for transition from N-1 to 0.
  - cp_pointer: bins {min=0, max=N-1, wrap=0}.
Cross:
  - cross_gnt_id_seq_x_wrap: cp_gnt_id_seq × cp_wraparound.
  - cross_pointer_x_gnt_id: cp_pointer × cp_gnt_id.
Code:
  - Pointer increment and wrap logic.
  - FSM state holding in ARBITRATION.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 17)]"
corner_round_robin_pointer_wraparound_with_equal_priorities_or_weights,"Verify that with all requestors set to equal legal priorities or weights, the round-robin pointer wraps correctly at the legal boundary (from N-1 to 0), and each requestor is granted exactly once per N cycles. This scenario tests the pointer wraparound logic and fairness at the edge of the requestor array, ensuring no requestor is skipped or repeated and that the grant sequence is correct.","1) Apply clk; assert rst=1 for 4 cycles, then deassert rst=0.
2) For all i in 0..31:
   - Set prio_id=i, prio=1 (or prio=8), prio_upt=1 for 1 cycle (all priorities/weights equal).
3) Drive req[31:0]=all 1's (all requestors active).
4) For N=32 cycles, on each grant (gnt_w[i]==1), drive ack=1 for that cycle.
5) Observe the sequence of gnt_id and gnt_w over at least 2×N cycles to ensure pointer wraps from 31 to 0 and the pattern repeats.","1) Confirm that each requestor is granted exactly once per N cycles (no repeats, no skips, fairness).
2) Confirm that after requestor 31 is granted, the next grant is to requestor 0 (pointer wraparound).
3) Confirm that gnt_id matches the index of the asserted gnt_w bit (one-hot).
4) No grant to non-requesting requestors.","Functional:
  - cp_pointer: bins {0, 31} for pointer position and wrap events.
  - cp_grant_seq: bins {grant_0, ..., grant_31}.
  - cp_wrap: bin for pointer transition from 31→0.
Cross:
  - cross_pointer_x_grant: cp_pointer × cp_grant_seq.
  - cross_pointer_x_wrap: cp_pointer × cp_wrap.
Code:
  - Statement/branch/toggle in pointer increment, wraparound, and grant selection logic.",Arbitration Grant and Fairness Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
corner_arbitration_latency_and_grant_acknowledge_protocol_single_requestor,"Verify the arbitration pipeline's minimum (best-case) latency and the grant acknowledge protocol for a single requestor, including both minimum and maximum legal latencies between grant issuance and ack assertion. This scenario exercises the lowest legal latency path through the pipeline and the timing boundaries for the ack signal, ensuring the arbiter correctly updates internal state and issues the next grant as per protocol. It covers both the best-case 1-cycle latency and the protocol's behavior at the edges of allowed ack timing.","1) Assert rst=1 for at least 2 cycles with clk toggling; then deassert rst=0 to initialize all state (per Table 10.3 Reset / Startup Sequence).
2) Drive req[N-1:0]=0 for >=2 cycles to ensure idle state.
3) On cycle X, drive req[0]=1 (all others 0), ack=0, prio_upt=0.
4) Observe gnt_w and gnt_id on the next cycle (X+1).
5) For minimum latency case: on cycle X+1, drive ack=1 to accept the grant.
6) For maximum legal latency case: hold ack=0 for the maximum number of cycles allowed by the protocol, then assert ack=1.
7) After ack=1, optionally drive req[1]=1 (req[0]=0) to request from the next requestor and observe grant sequencing.
8) Continue to monitor outputs for at least 2 more cycles to ensure no spurious grants.","1) Check that gnt_w[0]=1 and gnt_id==0 exactly 1 cycle after req[0]=1 is asserted (latency=1 cycle).
2) Confirm no other gnt_w bits are set and gnt_id does not change until ack=1.
3) Ensure that the grant is held stable until ack=1 is observed, and only then does the arbiter update its state and issue the next grant.
4) For both min and max ack latency, verify that no grant is skipped or repeated, and that the grant acknowledge protocol is followed exactly as per spec.
5) Confirm that after ack=1, grant is removed or moves to next eligible requestor (if any), and that the latency from grant to next grant matches expected pipeline behavior.","Functional:
  - cp_req: bins {single_req=only one req[N-1:0] bit set}.
  - cp_latency: bins {latency_1=1 cycle}.
  - cp_ack_latency: bins {min=1, max=legal_max} cycles between grant and ack.
  - cp_grant_sequence: bins for grant moving from one requestor to the next.
Cross:
  - cross_req_x_latency: cp_req × cp_latency.
  - cross_ack_latency_x_grant_sequence: cp_ack_latency × cp_grant_sequence.
Code:
  - Statement/branch/toggle in arbitration, grant FSM, and ack handling logic for single requestor path.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
corner_grant_latency_bounds,"Verify that the grant latency is within the legal bounds defined by the spec: 1 cycle for normal operation, 2 cycles for credit refill. This exercises the timing boundary for arbitration and refill events.","1) Drive clk; assert rst=1 for 4 cycles, then deassert rst=0.
2) For normal operation: Issue req[0]=1, ack=0, and observe gnt_w/gnt_id; measure cycles from req assertion to grant.
3) For credit refill: Deplete all credits (e.g., set prio=0x0 for all, issue grants until all credits=0), then assert req[0]=1 and observe time from req to grant after refill is triggered.
4) Repeat for both cases to confirm latency at both boundaries.","1) For normal operation, grant is issued within 1 cycle of req assertion.
2) For credit refill, grant is issued within 2 cycles after refill is triggered.
3) No grant is issued before legal latency expires.","Functional:
  - cp_latency: bins {normal=1, refill=2}.
Cross:
  - cross_latency_x_event: cp_latency × {normal, refill}.
Code:
  - Arbitration and refill path timing.",Functional Assertion Coverage Verification,"[('weighted_round_robin_mas.pdf', 17)]"
corner_credit_refill_latency_worst_case_boundary,"Verify the arbiter's maximum (worst-case) pipeline latency and correct behavior at the legal latency boundary during credit refill. When all requestors are active and all credits are exhausted, the arbiter must enter the credit refill state, with no grant issued for exactly 1 cycle, and then resume granting within the specified maximum latency (2 cycles for refill per spec). This scenario exercises the ARBITRATION→REPLENISH→ARBITRATION FSM transition and ensures the legal upper bound on arbitration latency is met for 'credit refill' conditions.","1) Assert rst=1 for at least 2 cycles with clk toggling; then deassert rst=0 to initialize all state.
2) Set all priorities to prio=1 (minimum nonzero weight) for all requestors (if applicable).
3) Drive req[N-1:0]=1 (all requestors active), ack=1 for N cycles to consume all credits (repeat until all credits are exhausted per spec).
4) After all credits are exhausted, continue to drive req[N-1:0]=1, ack=0 (no grants can be accepted).
5) Observe that no grant is issued for exactly 1 cycle (credit refill state), then a grant is issued on the following cycle (latency=2 cycles from req to grant).
6) Monitor gnt_w and gnt_id for correct grant after refill.","1) Detect the cycle when all credits are exhausted (no eligible requestor).
2) Check that after all credits are exhausted, there is exactly 1 cycle with no grant (gnt_w==0), followed by a grant on the next cycle (latency=2 cycles from req to grant).
3) Confirm that the grant after refill matches the round-robin pointer and credit logic.
4) Ensure no grant is issued during the refill cycle.
5) Confirm that after 1 cycle, credits are refilled and grants resume to requestors.","Functional:
  - cp_credit_state: bins {all_credits_zero, refilled}.
  - cp_latency: bins {latency_2=2 cycles}.
Cross:
  - cross_credit_state_x_latency: cp_credit_state × cp_latency.
Code:
  - Statement/branch/toggle in FSM for ARBITRATION→REPLENISH transition and refill logic.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
corner_credit_counter_and_priority_boundary_and_refill_behavior,"Verify correct behavior of the credit counter and priority (weight) logic at both minimum and maximum legal values, including dynamic priority updates at the credit refill boundary, correct grant issuance, no underflow/overflow, and proper refill behavior. This scenario exercises the legal edges for credit exhaustion, refill, and priority update, ensuring correct operation for all boundary conditions and their interactions.","1) Drive clk continuously; assert rst=1 for at least 2-4 cycles, then deassert rst=0.
2) For requestor i (0 ≤ i < N):
   a) Set prio, prio_id, prio_upt to update prio[i] to MIN (0), MAX-1 (14), MAX (15), and for CREDIT_W=8, set prio=254 for max credit=255. Wait 1 cycle for update to take effect.
   b) Drive req[i]=1, all other req=0. ack=1 each cycle.
   c) Observe gnt_w and gnt_id; ensure requestor i is granted repeatedly until its credit counter is exhausted (should be prio+1 grants).
   d) After last grant (credit=0), keep req[i]=1, ack=1. On next arbitration, observe that no grant is issued (gnt_w=0) for one cycle (credit=0), then after refill, grant is re-issued with credit refilled to prio+1.
   e) On the cycle when credit=0 (no grant), simultaneously assert prio_upt=1, prio_id=i, prio=MAX (15) or prio=0 (for min/max dynamic update test). Observe that on refill, the new credit value is prio+1, and subsequent grants match the new weight.
   f) For CREDIT_W=8, set prio=254, confirm 255 consecutive grants before refill.
   g) Repeat for all relevant prio values (0, 1, 14, 15, 254).","1) For each prio value, the number of consecutive grants to requestor i before a grant gap equals prio+1 (e.g., 1, 2, 15, 16, 255).
2) After the last grant (credit=0), the next arbitration cycle issues no grant (gnt_w=0), and the following cycle refills credit and resumes granting.
3) After dynamic priority update at refill, the number of consecutive grants matches the new prio+1 value.
4) No grant is issued when credit=0 (no underflow); no overflow or wraparound in credit counter (never exceeds 8 bits).
5) After refill, credit counter is set to prio+1 (observable by number of grants before next gap).
6) gnt_id matches the granted requestor index; gnt_w is one-hot for i; no grant is given to non-requesting requestors.
7) No glitch, double grant, or protocol violation occurs at the update/refill boundary.
8) Confirm latency for refill matches spec.","Functional:
  - cp_prio: bins {min=0, minp1=1, maxm1=14, max=15, large=254}.
  - cp_credit_exhaust: bins {credit=1→0, credit=15→0, credit=255→0}.
  - cp_refill: bins {refill_after_min, refill_after_max, refill_at_max, refill_latency}.
  - cp_prio_update: bins {at_refill_min, at_refill_max}.
  - cp_credit_val: bins {max=255, min=0, just-below-max=254}.
  - cp_gnt_id: bins {all requestors exercised}.
Cross:
  - cross_prio_x_refill: cp_prio × cp_refill.
  - cross_prio_update_x_refill: cp_prio_update × cp_refill.
  - cross_credit_val_x_gnt_id: cp_credit_val × cp_gnt_id.
Code:
  - Toggle/branch coverage in credit decrement, zero detect, refill logic, and priority register update at timing boundary.",Credit-Based Scheduling and Refill Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
corner_priority_update_boundary_and_min_gap,"Verify that priority updates to values just inside the legal extremes (e.g., prio=1 and prio=14) and two consecutive updates to the same requestor separated by the minimum legal gap (1 cycle) are both accepted and reflected in grant frequency, without stalling arbitration or corrupting grant outputs. This scenario exercises both the off-by-one legal boundaries of the priority value and the minimum legal timing between updates, ensuring that runtime priority updates function correctly under these corner conditions.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0] so that at least two requestors are active (e.g., req[2]=1, req[3]=1, req[4]=1).
3) For requestor #2, at cycle Y, drive prio_id=2, prio=1, prio_upt=1 for one clk cycle; after several grants, at cycle Y+Z, drive prio_id=2, prio=14, prio_upt=1 for one clk cycle.
4) For requestor #4, at cycle M, drive prio_id=4, prio=5, prio_upt=1 for one clk cycle; at cycle M+1, drive prio_id=4, prio=10, prio_upt=1 for one clk cycle (minimum legal gap).
5) Continue to drive req[2]=1, req[3]=1, req[4]=1 throughout, with ack=1 only when the corresponding gnt_w is asserted.
6) Observe gnt_w, gnt_id, and grant pattern for #2 and #4 before and after each update.","1) Check that grants continue without stall during/after each priority update.
2) Check that all priority updates are accepted and reflected in grant frequency for the respective requestors.
3) Check that grant frequency for #2 decreases after prio=1 and increases after prio=14, compared to #3.
4) Check that grant pattern for #4 changes according to updated priorities after each consecutive update.
5) Check that no arbitration cycle is skipped or repeated due to the updates, and no grant output corruption occurs.","Functional:
  - cp_prio_val: bins {1, 5, 10, 14} for prio input.
  - cp_update_gap: bin {1 cycle} between prio_upt pulses for same requestor.
  - cp_gnt_pattern: bins {pre-update, post-update} grant frequency for #2 and #4.
Cross:
  - cross_prio_val_x_gnt: cp_prio_val × cp_gnt_pattern.
  - cross_update_gap_x_prio_val: cp_update_gap × cp_prio_val.
Code:
  - Priority register update logic, arbitration path, grant output toggling.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 4)]"
corner_priority_update_during_credit_refill,"Verify that a priority update (prio/prio_id/prio_upt) for a requestor during a credit refill cycle (when no eligible requestors exist) is accepted and reflected in the next arbitration, with correct latency and no missed grants. This is a corner because it tests the legal concurrency of update with the REPLENISH FSM state and the 2-cycle latency path.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0] so that only req[5]=1 is active.
3) Wait until gnt_w[5]=1 and gnt_id==5, then drive ack=1 to consume all credits for #5 (repeat as needed).
4) When gnt_w==0 (no eligible requestors, entering REPLENISH), in the same cycle, drive prio_id=5, prio=12, prio_upt=1.
5) Continue to drive req[5]=1 after refill, with ack=1 only when gnt_w[5]=1.
6) Observe gnt_w, gnt_id, and grant pattern for #5 before and after the update.","1) Check that the priority update is accepted during the credit refill cycle.
2) Check that after refill, grant frequency for #5 matches the updated priority (prio=12).
3) Check that no arbitration stall or missed grant occurs due to the update during refill.
4) Check that latency from refill to next grant is within the 2-cycle bound per spec.","Functional:
  - cp_update_during_refill: bin {prio_upt during REPLENISH}.
  - cp_prio_val: bin {12}.
  - cp_latency: bin {2 cycles from refill to next grant}.
Cross:
  - cross_update_during_refill_x_latency: cp_update_during_refill × cp_latency.
Code:
  - FSM transition, priority update logic, grant output path.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 4)]"
corner_credit_refill_and_priority_update_race,"Exercise the legal timing edge where a requestor's credit is refilled and its priority is updated in the same cycle, ensuring that the design deterministically applies the new priority to the refill value with no queueing or delayed effect.","1) Apply clk and rst as per spec (rst=1 for >=2 cycles, then rst=0).
2) For a chosen requestor (e.g., req[5]), set its prio to min (0) and drive req[5]=1, ack=1 every cycle, so its credit decrements to 0 as fast as possible.
3) On the exact cycle when credit reaches 0 (i.e., refill is triggered), simultaneously assert prio_upt=1, prio_id=5, prio=15 (max) to update its priority.
4) Continue driving req[5]=1, ack=1 for several more cycles to observe post-refill behavior.","1) Observe that the credit refill for requestor 5 uses the new prio value (15+1=16), not the old value, and that this is reflected immediately in the next arbitration cycle (no delayed or buffered update).
2) Confirm that gnt_w and gnt_id reflect deterministic grant to requestor 5 for the next 16 cycles (assuming no other active requests), with no skipped or repeated grants.
3) Check that no extra grants are issued in the cycle of refill (no burst), and that latency remains within spec (1 or 2 cycles).","Functional:
  - cp_prio_update_timing: bins {update_before_refill, update_at_refill, update_after_refill}.
  - cp_credit_value: bins {min=1, max=16} for credit after refill.
Cross:
  - cross_prio_update_timing_x_credit_value.
Code:
  - Toggle/branch in refill and priority update logic.",No Internal Queues or FIFOs Verification,"[('weighted_round_robin_mas.pdf', 13)]"
corner_priority_update_during_arbitration_with_ack_handshake,"Verify that a priority update (prio_upt=1) applied to a requestor during an active arbitration cycle, coinciding with an ack=1 handshake, is correctly reflected in the next grant decision. This scenario checks that the FSM remains in ARBITRATION, the grant assignment reflects the updated priority without pipeline hazard or latency violation, and no illegal state or output glitch occurs. This is a legal concurrency edge for state and datapath update, exercising both control and datapath logic at a timing edge.","1) Assert rst=1 for at least 2 cycles with clk toggling; then deassert rst=0 to initialize all state.
2) Set up two requestors (e.g., req[0]=1, req[1]=1, others=0), with initial priorities equal.
3) For 2 cycles, keep ack=0, prio_upt=0.
4) On cycle N, drive ack=1 (accept grant), and simultaneously drive prio_upt=1, prio_id=1, prio=MAX (0xF for PRIORITY_W=4).
5) On next cycle, keep req unchanged, ack=0, prio_upt=0.
6) Observe gnt_id and gnt_w for grant assignment reflecting updated priority.
7) Continue for 2 more cycles to ensure correct round-robin and priority behavior.","1) On cycle with ack=1 and prio_upt=1, grant is issued to previous winner.
2) On next cycle, grant is issued to requestor with updated (now highest) priority if its req is still active.
3) FSM remains in ARBITRATION throughout (no REPLENISH triggered).
4) No glitch or illegal transition on outputs during concurrent update.
5) Confirm that no spurious grants or pipeline hazards occur (e.g., no skipped or repeated grants).
6) Ensure latency from prio update to grant is within 1 cycle as allowed by pipeline.","Functional:
  - cp_concurrent_update: bins {prio_upt_with_ack, prio_upt_without_ack}.
  - cp_prio_value: bins {prio_min=0, prio_max=0xF}.
  - cp_grant_assignment: bins {before_update, after_update, grant_to_updated}.
Cross:
  - cross_update_x_grant: cp_concurrent_update × cp_grant_assignment.
  - cross_prio_upt_x_grant: cp_concurrent_update × cp_grant_assignment.
Code:
  - Priority update logic and FSM state holding in ARBITRATION.
  - Statement/branch/toggle in priority update and arbitration logic.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
corner_simultaneous_priority_update_and_ack_back_to_back_cycles,"Verify correct operation when a priority update (prio_upt) and grant acknowledge (ack) occur in consecutive cycles, in both possible orders (prio_upt before ack, ack before prio_upt). This tests the legal timing edge for closely spaced but not simultaneous events.","1) Assert rst=1 for at least 2 cycles with clk toggling, then deassert rst=0 to initialize.
2) For requestor j (0 ≤ j < N):
   a) Set req[j]=1, all others 0.
   b) Case 1: On cycle N, assert prio_upt=1 (with prio_id=j, prio=7), ack=0; on cycle N+1, assert ack=1, prio_upt=0.
   c) Case 2: On cycle M, assert ack=1, prio_upt=0; on cycle M+1, assert prio_upt=1 (with prio_id=j, prio=7), ack=0.
3) Observe gnt_w and gnt_id for correct grant and priority update behavior in both cases.","1) Check that grant is correctly acknowledged and priority is updated in both orderings.
2) Ensure that the updated priority is used for the next arbitration after prio_upt.
3) Confirm no hazard, lost/duplicated grant, or output glitch occurs in either ordering.","Functional:
  - cp_order: bins {prio_upt_before_ack, ack_before_prio_upt}.
  - cp_prio_val: bin {mid=7} for prio input.
Cross:
  - cross_order_x_prio_val: cp_order × cp_prio_val.
Code:
  - Sequential logic coverage for back-to-back control events.",Simultaneous Priority Update and Grant Acknowledge Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 21)]"
corner_grant_encoding_and_dynamic_priority_update_at_boundary,"Verify that grant encoding (gnt_w and gnt_id) remains consistent and correct at arbitration boundaries under two stress conditions: (1) when multiple adjacent requestors at the boundary assert requests simultaneously with minimum ack interval, and (2) after a dynamic priority update to a boundary requestor (ID 0 or N-1). This scenario stresses arbitration, encoding, and dynamic configuration logic at the legal edges, ensuring correct grant sequencing and encoding both under high concurrency and after runtime priority changes.","1) Drive clk; assert rst=1 for 2 cycles, then rst=0.
2) For concurrent requests at boundary:
   a) Set req to activate two adjacent requestors at the boundary (e.g., req=0x00000003 for IDs 0 and 1, or req=0xC0000000 for IDs 30 and 31).
   b) For PRIORITY_W=4, set prio/prio_id/prio_upt to 0 (no priority updates).
   c) For each arbitration cycle:
      i) Observe gnt_w and gnt_id.
      ii) Assert ack=1 in every cycle (minimum legal gap).
      iii) After each grant, ensure req remains asserted for both requestors for at least 2 cycles.
      iv) Repeat for both min and max boundary pairs.
   d) Idle for 2 cycles between tests.
3) For dynamic priority update at boundary:
   a) Set req to one-hot for a boundary requestor (e.g., req=0x00000001 for ID 0).
   b) In cycle 1, assert prio_upt=1, prio_id=boundary ID (0 or N-1), prio=0xF (max legal priority for PRIORITY_W=4).
   c) In cycle 2, deassert prio_upt; keep req asserted.
   d) Observe gnt_w and gnt_id in cycles 2 and 3.
   e) Assert ack=1 when grant is observed.
   f) Repeat for both min and max IDs.","1) In each cycle, only one bit in gnt_w is set, and gnt_id matches the granted requestor.
2) Over two cycles, both boundary requestors are granted in round-robin order, with gnt_w and gnt_id matching each grant.
3) No grant is skipped or duplicated; no illegal encodings.
4) After a priority update to a boundary requestor, the next grant is issued to the updated requestor if its priority is highest, with gnt_w and gnt_id matching.
5) No spurious or skipped grants; no illegal encoding after priority update.","Functional:
  - cp_req_pair: bins {min_pair=(0,1), max_pair=(N-2,N-1)}.
  - cp_ack_gap: bin {min_gap=1 cycle}.
  - cp_prio_id: bins {min=0, max=N-1}.
  - cp_prio: bins {min=0x0, max=0xF}.
  - cp_gnt_id: bins {0,1,N-2,N-1}.
Cross:
  - cross_req_pair_x_gnt_id: cp_req_pair × cp_gnt_id.
  - cross_prio_id_x_gnt_id: cp_prio_id × cp_gnt_id.
Code:
  - Toggle/branch coverage for arbitration pointer wrap, encoding logic at boundaries, and priority update logic.",Grant Encoding Consistency Verification,"[('weighted_round_robin_mas.pdf', 10)]"
corner_priority_update_during_credit_refill,"Verify that a priority update (prio/prio_id/prio_upt) for a requestor during a credit refill cycle (when no eligible requestors exist) is accepted and reflected in the next arbitration, with correct latency and no missed grants. This is a corner because it tests the legal concurrency of update with the REPLENISH FSM state and the 2-cycle latency path.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0] so that only req[5]=1 is active.
3) Wait until gnt_w[5]=1 and gnt_id==5, then drive ack=1 to consume all credits for #5 (repeat as needed).
4) When gnt_w==0 (no eligible requestors, entering REPLENISH), in the same cycle, drive prio_id=5, prio=12, prio_upt=1.
5) Continue to drive req[5]=1 after refill, with ack=1 only when gnt_w[5]=1.
6) Observe gnt_w, gnt_id, and grant pattern for #5 before and after the update.","1) Check that the priority update is accepted during the credit refill cycle.
2) Check that after refill, grant frequency for #5 matches the updated priority (prio=12).
3) Check that no arbitration stall or missed grant occurs due to the update during refill.
4) Check that latency from refill to next grant is within the 2-cycle bound per spec.","Functional:
  - cp_update_during_refill: bin {prio_upt during REPLENISH}.
  - cp_prio_val: bin {12}.
  - cp_latency: bin {2 cycles from refill to next grant}.
Cross:
  - cross_update_during_refill_x_latency: cp_update_during_refill × cp_latency.
Code:
  - FSM transition, priority update logic, grant output path.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 4)]"
corner_internal_state_observability_min_max_priority_and_credit,"Verify that the internal state observability feature exposes correct grant outputs (gnt_w, gnt_id) when requestors are configured at the minimum and maximum legal priority and credit values. This exercises the legal boundary conditions for per-requestor priority (min=0, max=15) and credit (min=0, max=255), ensuring that debug/QoS monitoring can observe correct state transitions at the edges.","1) Drive clk continuously; assert rst=1 for at least 2 cycles, then deassert rst=0.
2) For requestor 0: set prio=0 (min), prio_id=0, prio_upt=1 for one cycle; for requestor 1: set prio=15 (max), prio_id=1, prio_upt=1 for one cycle. All other requestors: set prio=7 (mid).
3) For requestor 0: drive req[0]=1; for requestor 1: drive req[1]=1; all other req=0.
4) Observe gnt_w and gnt_id for at least N cycles, with ack=1 driven only when gnt_w is asserted for the corresponding requestor.
5) After each grant, allow credit to decrement to 0 for each requestor, then observe refill behavior (credit replenished from prio+1).","1) When prio=15 (max), requestor 1 should receive more frequent grants than requestor 0 (prio=0), observable via gnt_w/gnt_id.
2) When credit for a requestor reaches 0, grant is not issued until credit is refilled (after REPLENISH state), observable as a gap in gnt_w/gnt_id.
3) After credit refill, grant pattern resumes according to priority.
4) No grants are issued to a requestor when its credit is 0, even if req is asserted.","Functional:
  - cp_prio: bins {min=0, max=15, mid=7} for prio input.
  - cp_credit: bins {min=0, max=255, mid=127} for credit (inferred via grant pattern and refill timing).
  - cp_gnt_id: bins for each requestor ID at grant.
Cross:
  - cross_prio_x_gnt: cp_prio × cp_gnt_id (e.g., max prio × grant observed).
Code:
  - Toggle/branch coverage in priority and credit update logic.",Internal State Observability Verification,"[('weighted_round_robin_mas.pdf', 10)]"
corner_weighted_round_robin_min_max_priority_zero_starvation_and_proportionality,"Verify the weighted round robin arbiter at the legal extremes of per-requestor priority (weight), including minimum (prio=0), maximum (prio=15), and mid-range priorities, with all requestors active or selected subsets. This scenario ensures: (1) zero-starvation at the lowest legal weight, (2) grant proportionality at the edges and mid-range, and (3) correct round-robin pointer rotation and credit refill logic. It exercises the arbiter's fairness, proportionality, and starvation guarantees at the legal limits of programmable weights.","1) Apply clk; assert rst=1 for 4 cycles, then deassert rst=0.
2) For all requestors (N=32):
   - Set prio_id=0, prio=0, prio_upt=1 (min priority).
   - Set prio_id=1, prio=15, prio_upt=1 (max priority).
   - For prio_id=2..31, set prio=8 (mid-range).
   - Deassert prio_upt after each update.
3) Wait 1 cycle for updates to take effect.
4) Drive req[31:0]=all 1's (all requestors active), ack=1 every cycle.
5) For 1000 cycles, observe gnt_w and gnt_id each cycle.
6) Repeat with only requestors 0 and 1 active (req[0]=1, req[1]=1, others=0) for 32 cycles to check proportionality at the edges.
7) For prio=0 and prio=1 for all requestors, observe round-robin pointer and grant distribution for N cycles each.","1) For each requestor, count number of grants (gnt_w[i]==1) over the window.
2) Check that requestor 1 (max priority) receives ~16x more grants than requestor 0 (min priority), and others are proportional to their weights.
3) For prio=0 and prio=1 (all requestors), ensure each requestor is granted exactly once (prio=0) or twice (prio=1) per N cycles, confirming zero-starvation and proportionality.
4) Ensure every requestor receives at least one grant within a bounded window (no starvation).
5) Confirm that at no time are multiple gnt_w bits asserted (one-hot grant).
6) Confirm that gnt_id matches the index of the asserted gnt_w bit.
7) Ensure no grant is given to non-requesting requestors.","Functional:
  - cp_prio: bins {min=0, minp1=1, mid=8, max=15} for prio input.
  - cp_grant_ratio: bins for grant counts per requestor (min, mid, max weight, proportionality).
  - cp_rr_pointer: bins {all N positions}.
  - cp_starvation: bin for minimum grant interval per requestor.
Cross:
  - cross_prio_x_rr: cp_prio × cp_rr_pointer.
  - cross_prio_x_grant: cp_prio × cp_grant_ratio.
Code:
  - Statement/branch/toggle in grant selection, credit update, pointer logic, and credit refill at weight edges.",Credit-Based Scheduling and Refill Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
corner_ack_with_all_requestors_active_and_max_priority_spread,"Verify grant acknowledge protocol when all requestors are active (req=all 1s) and priorities are set to minimum and maximum legal values, ensuring correct grant sequencing and state update at the legal extremes of request and priority vectors. This is a corner because it stresses the arbiter with maximal concurrency and priority spread.","1) Assert rst=1 for at least 2 clk cycles, then deassert rst=0.
2) Set prio[0]=0 (min), prio[1]=15 (max), prio[2]=0, ..., prio[31]=0 (for N=32, PRIORITY_W=4).
3) Drive req=all 1s (all requestors active).
4) Observe gnt_w and gnt_id: first grant should go to #1 (highest priority).
5) Assert ack=1 on the next clk rising edge.
6) Repeat: after each grant/ack, observe that the next highest-priority requestor is granted, and that round-robin order is respected among equal-priority requestors.
7) Optionally, after a full round, update prio[0]=15 and repeat to check round-robin fairness at priority tie.","1) Check that the grant is always issued to the highest-priority active requestor, and that ack correctly triggers the next grant.
2) Ensure that when multiple requestors have equal max priority, round-robin order is followed.
3) Confirm that no grant is skipped or repeated, and that all requestors eventually receive grants as per WRR policy.","Functional:
  - cp_req_vector: bins {single_active, all_active}.
  - cp_prio_spread: bins {all_min, all_max, one_max_rest_min}.
Cross:
  - cross_req_vector_x_prio_spread: cp_req_vector × cp_prio_spread.
Code:
  - Coverage of grant selection logic at priority and request vector extremes.",Grant Acknowledge Protocol Verification,"[('weighted_round_robin_mas.pdf', 9)]"
corner_concurrent_sideband_priority_update_and_arbitration_all_requestors,"Verify that sideband priority configuration (via prio/prio_id/prio_upt) can occur concurrently with active arbitration (req/ack handshakes) for every requestor (0 to N-1), including the legal timing edge where prio_upt and ack are asserted in the same cycle. This ensures that configuration is always via sideband, never via registers, and that no hazard or starvation occurs across the full legal range of requestor IDs (ID_BITS=5, N=32).","1) Drive clk; assert rst=1 for at least 2-4 cycles, then deassert rst=0 to initialize.
2) For each requestor k in 0..31:
   a) Set req[k]=1 (all others 0 for single requestor, or multiple for concurrency as needed).
   b) On the cycle when grant is expected for k, simultaneously assert prio_upt=1 (prio_id=k, prio=mid value, e.g., 5 or 7), and ack=1.
   c) Deassert prio_upt=0 in the next cycle; continue arbitration for several cycles to observe effect.
   d) Confirm no register access is possible or performed.
3) Repeat for all k in 0..31 and for cases where multiple requestors are active.","1) For each requestor, confirm that the priority update via sideband (prio/prio_id/prio_upt) is accepted and reflected in subsequent grant behavior, even when coincident with ack.
2) Check that no configuration is possible via any memory-mapped register.
3) Ensure that no requestor is starved or skipped due to simultaneous prio_upt and ack.
4) Scoreboard: Track expected priority and grant outcome for each requestor before and after update.
5) Ensure gnt_id matches k and gnt_w is one-hot for k in each case.","Functional:
  - cp_concurrent_update: bin for prio_upt and ack both asserted in same cycle.
  - cp_prio_value: bin for prio=mid value (e.g., 5 or 7).
  - cp_req_id: bins {all 0..31} for prio_id and gnt_id.
  - cp_simultaneous: bin {prio_upt & ack asserted together}.
Cross:
  - cross_concurrent_update_x_gnt: cp_concurrent_update × observed gnt_id/gnt_w for updated requestor.
  - cross_req_id_x_simultaneous: cp_req_id × cp_simultaneous.
Code:
  - Toggle/branch coverage in priority update and arbitration logic under concurrent events.
  - Full decode coverage for ID_BITS=5, N=32.",Sideband Configuration Interface Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 21)]"
corner_all_requestors_sideband_priority_update_and_max_concurrency,"Verify that all requestors (0..N-1) can be configured via sideband signals to both minimum and maximum legal priority values, and that the arbiter handles the legal maximum concurrency: all requestors active and all priorities updated in a single cycle, with no internal queueing or buffering. This scenario exercises the legal configuration and update range for all requestors via sideband only, and confirms arbitration remains deterministic and synchronous with no register access.","1) Apply clk and rst as per spec (rst=1 for >=2 cycles, then rst=0).
2) For each requestor i in 0..N-1:
   a) Set prio=0, prio_id=i, prio_upt=1 for one clk cycle; prio_upt=0 for at least 1 cycle.
   b) Set prio=15, prio_id=i, prio_upt=1 for one clk cycle; prio_upt=0 for at least 1 cycle.
3) On a single cycle, drive req[31:0]=all 1's (all requestors active), ack=1, prio_upt=1, prio_id cycling through all 32 values in consecutive cycles, and prio set to alternating min (0) and max (15).
4) Continue for at least N cycles, ensuring each requestor receives a priority update and is eligible for grant.
5) Confirm no register access is possible or performed.
6) Observe gnt_w and gnt_id each cycle.","1) Confirm that only one grant is issued per cycle (one-hot gnt_w), and that the grant rotates among all requestors according to updated priorities, with no skipped or repeated grants.
2) For each requestor, after each prio/prio_id/prio_upt transaction, observe that grant behavior (gnt_w, gnt_id) reflects the updated priority.
3) Check that each prio update takes effect on the next arbitration cycle for the corresponding requestor (no delayed or buffered updates).
4) Confirm that no configuration is possible via any memory-mapped register.
5) Ensure that latency from req to grant is always 1 cycle (normal operation), and that no grant is issued to a requestor whose credit is zero until refill occurs.
6) Scoreboard: For each requestor, expected priority value is applied and reflected in arbitration outcome.","Functional:
  - cp_all_active: bin where req[31:0]=all 1's.
  - cp_prio_update: bins {min, max} for prio.
  - cp_prio_id: bins for all requestors 0..N-1.
  - cp_prio_value: bins {min=0, max=15}.
  - cp_grant_rotation: bins for each requestor being granted.
Cross:
  - cross_all_active_x_prio_update.
  - cross_prio_id_x_prio_value: cp_prio_id × cp_prio_value.
  - cross_prio_id_x_gnt: cp_prio_id × observed gnt_id/gnt_w after update.
Code:
  - Statement/branch/toggle in arbitration and priority update logic for all requestors.",No Internal Queues or FIFOs Verification,"[('weighted_round_robin_mas.pdf', 13)]"
corner_max_resource_utilization_and_parameter_limits,"Verify correct operation and resource utilization at the maximum legal values for parameterized requestor count (N=32), priority width (PRIORITY_W=4), and credit width (CREDIT_W=8). This scenario exercises the upper legal boundary for resource utilization and parameterization, ensuring no overflow, correct arbitration, adherence to resource constraints, and no out-of-bounds accesses or resource over-allocation. It also checks that all resource arrays and pointers operate within legal bounds and that illegal accesses are ignored as per specification.","1) Drive clk continuously; assert rst=1 for 4 cycles, then deassert rst=0.
2) For all 32 requestors (req[31:0]), set req[i]=1 for all i (all requestors active).
3) For each requestor i, set initial priorities via prio/prio_id/prio_upt:
   a) For i=0 to 31, drive prio_id=i, prio=15 (max legal), prio_upt=1 for one clk cycle, then prio_upt=0.
4) Observe gnt_w and gnt_id for 40 cycles, with ack=1 on every cycle (all grants accepted immediately).
5) After 40 cycles, for i=0 to 31, update prio[i]=0 (min legal) via prio/prio_id/prio_upt as above.
6) Continue for 40 more cycles, with req[31:0]=1 and ack=1.
7) For i=0 to 31, set prio[i]=i (unique legal values within 4 bits) via prio/prio_id/prio_upt.
8) Attempt to update prio_id=32 (illegal, out-of-bounds) and confirm no effect (should be ignored per spec).","1) Each gnt_id cycles through all 32 requestors in round-robin order, with no skips or repeats, both at max and min priority.
2) gnt_w is one-hot and matches gnt_id encoding.
3) No grant is issued to a requestor with exhausted credit until refill occurs.
4) No overflow or wraparound in credit counters (never exceeds 8 bits).
5) After priority is set to 0, all requestors still receive grants, but at minimum weight (fairness preserved).
6) No gnt_id or prio_id value exceeds 31 (ID_BITS=5, N=32).
7) No prio or credit register is written out-of-bounds.
8) Pointer register cycles through 0..31 only.
9) All resource utilization matches N×4 bits for priorities, N×8 bits for credits, log2(N)=5 bits for pointer.
10) Out-of-bounds prio_id update (32) is ignored.","Functional:
  - cp_N: bins {N=32}
  - cp_PRIORITY_W: bins {PRIORITY_W=4}
  - cp_CREDIT_W: bins {CREDIT_W=8}
  - cp_prio_val: bins {min=0, max=15}
  - cp_gnt_id: bins {all 0..31}
  - cp_id_val: bins {min=0, max=31, out_of_bounds=32}
  - cp_pointer_val: bins {0..31}
Cross:
  - cross_prio_val_x_gnt_id: cp_prio_val × cp_gnt_id
  - cross_id_val_x_pointer_val: cp_id_val × cp_pointer_val
Code:
  - Statement/branch/toggle in parameter decode, credit update, grant logic, ID decode, pointer logic, and resource allocation at upper boundary.",Parameterization and Resource Utilization Verification,"[('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
corner_minimal_state_persistence_no_internal_buffering,"Verify that the WRR arbiter maintains all state in synchronous flip-flops only, with no internal queues or FIFOs, by exercising the legal minimum and maximum concurrency and timing edges. This scenario targets the corner where all requestors are active and priorities/credits are updated at the legal minimum interval, ensuring deterministic, non-buffered arbitration.","1) Apply clk with nominal frequency. Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize all state (per spec Table 10.3: priority registers cleared, credit registers initialized to 1, pointer reset to 0).
2) For N=32 requestors, drive req[31:0]=all 1's (all requestors active) for several cycles.
3) On each cycle, drive ack=1 (immediate acceptance of grant), ensuring no backpressure or accumulation.
4) At the legal minimum interval (every cycle), issue prio_upt=1 with prio_id cycling through all requestors and prio set to alternating min (0) and max (15) values (PRIORITY_W=4), updating priorities as fast as allowed.
5) Continue for at least 2×N cycles to ensure all requestors are exercised at both min and max priority, and all credits are decremented and refilled at least once.","1) For every cycle, observe gnt_w and gnt_id: ensure only one-hot grant per cycle, and that the grant rotates among requestors according to current priorities and credits, with no skipped or repeated grants beyond what is allowed by WRR policy.
2) Confirm that after each prio_upt, the effect is visible on the next eligible arbitration cycle (no delayed or buffered updates).
3) Check that the latency from req assertion to grant is always 1 cycle in normal operation, and at most 2 cycles during credit refill (per Table 12.2).
4) Ensure that no grant is issued to a requestor whose credit is zero until refill occurs, and that credits are refilled strictly from prio+1, with no evidence of queueing or buffering (i.e., no grant 'bursts' or delayed grants after refill).
5) Confirm that after rst, all outputs (gnt_w, gnt_id) behave deterministically from the first arbitration cycle.","Functional:
  - cp_prio: bins {min=0, max=15, mid=7, midp1=8} for prio input on prio_upt.
  - cp_req: bins {single_active, all_active, alternating_active} for req vector.
  - cp_ack: bins {always_1, always_0, alternating} for ack.
  - cp_latency: bins {1, 2} for grant latency.
Cross:
  - cross_prio_x_latency: cp_prio × cp_latency.
  - cross_req_x_ack: cp_req × cp_ack.
Code:
  - Toggle/branch coverage in credit update, priority update, and arbitration logic.",No Internal Queues or FIFOs Verification,"[('weighted_round_robin_mas.pdf', 13)]"
corner_simultaneous_and_dynamic_priority_update_at_ack_boundary_min_max_priority,"Verify hazard-free and correct operation when a requestor's priority is updated (prio/prio_id/prio_upt) to any legal value (min=0, max=15, or mid) in the same cycle as its grant is acknowledged (ack=1), exercising the legal concurrency edge. Ensure that the new priority takes effect immediately for subsequent arbitration, that no arbitration stalls, glitches, or protocol violations occur, and that grant outputs (gnt_w, gnt_id) reflect the updated priority. This scenario covers dynamic reconfiguration at the grant boundary, simultaneous protocol events, and observability of the effect on arbitration and grant sequencing.","1) Apply clk and assert rst=1 for at least 2-4 cycles, then deassert rst=0 to initialize.
2) Set initial priorities for all requestors (e.g., prio=2 for all, using prio_id and prio_upt).
3) Drive req[N-1:0] such that at least two requestors (e.g., #0 and #1) are requesting (req[0]=1, req[1]=1, others=0).
4) Wait until a grant is issued to a requestor (e.g., gnt_id==0 or 1, gnt_w asserted).
5) On the same cycle as the grant is acknowledged (ack=1), simultaneously assert prio_upt=1, prio_id=<granted requestor>, and prio=<min=0, max=15, or mid value>.
6) Continue to drive requests and observe grant outputs for several cycles after the update.
7) Repeat for both prio=0 and prio=15, and for different requestors as needed.","1) Check that the grant is correctly issued and acknowledged in the cycle of simultaneous prio_upt and ack, with no missed or duplicated grants.
2) Verify that the priority update is accepted and reflected in subsequent arbitration cycles: after prio=15, the requestor receives more frequent grants; after prio=0, the requestor is deprioritized.
3) Ensure that no arbitration stall, glitch, or protocol violation occurs during or after the concurrent update and acknowledge.
4) Confirm that grant outputs (gnt_w, gnt_id) and internal priority registers are updated atomically and are observable for debug/QoS monitoring.
5) Ensure no illegal state or output glitch occurs on gnt_w/gnt_id.","Functional:
  - cp_prio_val: bins {min=0, max=15, mid} for prio input during prio_upt.
  - cp_concurrent_update_ack: bin {prio_upt & ack in same cycle}.
  - cp_gnt_pattern: bins {pre-update, post-update} grant frequency for affected requestor.
  - cp_simultaneous: bin {prio_upt & ack asserted together}.
Cross:
  - cross_prio_val_x_simultaneous: cp_prio_val × cp_concurrent_update_ack.
  - cross_update_ack_x_gnt: cp_concurrent_update_ack × cp_gnt_pattern.
Code:
  - Toggle/branch coverage in priority update, grant acknowledge, and arbitration logic at timing edge.",Runtime Priority Update Verification,"[('weighted_round_robin_mas.pdf', 3), ('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17), ('weighted_round_robin_mas.pdf', 21)]"
corner_max_throughput_64_requestors,Verify that the arbitration pipeline achieves one grant per cycle (maximum throughput) when all 64 requestors are active and have sufficient credits. This is a corner because it exercises the legal upper bound of concurrent requestor activity and throughput as specified for N=64.,"1) Set N=64 in the testbench and DUT parameters.
2) Assert rst=1 for at least 2 cycles with clk toggling; then deassert rst=0 to initialize all state.
3) For at least 64 cycles:
   a) Drive req[N-1:0]=all 1's (all requestors active), ack=1 every cycle.
   b) prio_upt=0.
4) Observe gnt_w and gnt_id every cycle.
5) After 64 cycles, idle req and ack, and monitor for any spurious grants.","1) Check that exactly one gnt_w bit is set and gnt_id matches the granted requestor every cycle.
2) Confirm that all 64 requestors are granted in round-robin order, with no skips or repeats, and that no cycle is missed (i.e., one grant per cycle).
3) Ensure that throughput is 1 grant per cycle for all 64 cycles.","Functional:
  - cp_N: bins {N=64}.
  - cp_req_pattern: bins {all_active}.
  - cp_throughput: bins {one_grant_per_cycle}.
Cross:
  - cross_N_x_throughput: cp_N × cp_throughput.
Code:
  - Statement/branch/toggle in grant selection and pointer logic for full-width operation.",Arbitration Pipeline Latency and Throughput Verification,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
corner_no_error_correction_no_security_at_all_legal_interface_edges,"Verify at the legal operational boundaries that the design does not implement any internal error correction, parity, or security features, and that all interfaces are unprotected. This is a corner because it checks for the absence of protection at the minimum and maximum values of all relevant interface signals, ensuring no hidden protection logic is triggered at legal extremes.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the design per reset/startup sequence (see spec Table 10.3).
2) For each input port with a defined width (req[N-1:0], prio[PRIORITY_W-1:0], prio_id[ID_BITS-1:0]):
   a) Drive minimum legal value (all 0s).
   b) Drive maximum legal value (all 1s).
   c) Drive just-inside values (e.g., 1, N-2 for req; 1, PRIORITY_W-2 for prio; 1, ID_BITS-2 for prio_id).
3) For each case, toggle prio_upt and ack as appropriate to exercise the update and handshake paths.
4) Observe outputs gnt_w[N-1:0] and gnt_id[ID_BITS-1:0] for normal arbitration behavior.
5) Repeat for several cycles to cover all legal transitions and concurrent events (e.g., simultaneous prio_upt and ack).
6) Throughout, monitor for any indication of error correction, parity, or security response (e.g., stuck outputs, error patterns, or output masking).","1) No output (gnt_w, gnt_id) is masked, altered, or shows error patterns at any legal input value or transition.
2) No observable output indicates error correction, parity, or security logic (e.g., no stuck-at, no error code, no output suppression).
3) Arbitration and grant behavior matches functional spec for all legal input combinations, with no deviation at boundaries.
4) No handshake or priority update is blocked or altered due to any hidden protection logic.","Functional:
  - cp_req: bins {min=0, minp1=1, maxm1=N-2, max=N-1} for req[N-1:0].
  - cp_prio: bins {min=0, minp1=1, maxm1=PRIORITY_W-2, max=PRIORITY_W-1} for prio.
  - cp_prio_id: bins {min=0, minp1=1, maxm1=ID_BITS-2, max=ID_BITS-1} for prio_id.
  - cp_concurrent: bins for simultaneous prio_upt and ack asserted.
Cross:
  - cross_input_x_output: cp_req × cp_prio × cp_prio_id × cp_concurrent × observed gnt_w/gnt_id behavior.
Code:
  - Statement/branch/toggle in all datapath and handshake logic at input boundaries.",Absence of Built-in Error Correction or Security Verification,"[('weighted_round_robin_mas.pdf', 11)]"
corner_sync_reset_fsm_transition_and_post_reset_arbitration_with_concurrent_inputs,"Verify that synchronous reset (rst) correctly initializes all internal state (priority registers, credit counters, pointer, FSM state) regardless of concurrent input activity (prio/prio_id/prio_upt, req) and for both minimum and maximum legal reset durations. Ensure that the Arbiter FSM transitions correctly from reset to ARBITRATION state, and that the first arbitration after reset is correct per spec. This scenario covers concurrency of reset with other legal input activity, legal reset duration boundaries, and immediate post-reset readiness and arbitration.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for both legal minimum (1 clk cycle) and maximum (e.g., 16 clk cycles) durations in separate iterations.
3) During rst=1, toggle prio_upt=1 with varying prio/prio_id values on each cycle; drive req to random patterns, all zeros, or all ones in different iterations.
4) Observe that during rst=1, all outputs (gnt_w, gnt_id) remain at reset values and no priority updates are latched.
5) Deassert rst=0; on the first clk rising edge, drive req with patterns: one-hot (e.g., req[0]=1), all zeros, and all ones; prio_upt=0.
6) Optionally, assert prio_upt=1 with valid prio/prio_id immediately after rst=0 to check for correct post-reset update behavior.
7) Observe gnt_w and gnt_id for the first arbitration cycle after reset.","1) During rst=1, no priority updates are latched, and no grants are issued (gnt_w/gnt_id remain at reset values).
2) After rst=0, all internal state reflects reset values (priority=0, credit=1, pointer=0, FSM in ARBITRATION state), regardless of input activity during reset.
3) First arbitration after reset is correct: grant to requestor 0 if req[0]=1, no grant if req=all zeros, grant to pointer=0 if req=all ones.
4) If prio_upt=1 is asserted after rst=0, priority update is accepted and reflected in subsequent arbitration.
5) No spurious grants or glitches on gnt_w/gnt_id during or immediately after reset.
6) Latency from rst deassertion to first grant is exactly 1 cycle.","Functional:
  - cp_prio_upt_during_rst: bins {none, toggled}.
  - cp_req_during_rst: bins {all_zeros, all_ones, random}.
  - cp_rst_duration: bins {min=1, max=16} cycles.
  - cp_req_pattern: bins {one_hot, all_zeros, all_ones} at first arbitration.
  - cp_post_reset_grant: bins {grant_to_0, no_grant}.
  - cp_first_req: bins {req[0]=1, others=0}.
  - cp_gnt_w: bins {reset=0, first_grant=1}.
Cross:
  - cross_prio_upt_during_rst_x_post_reset_arbitration.
  - cross_rst_duration_x_req_pattern.
  - cross_rst_x_first_req.
Code:
  - Priority register write path, reset override, FSM state transition from reset to ARBITRATION, and arbitration logic coverage.",Synchronous Reset and Initialization Verification,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 13)]"
corner_fsm_arbitration_replenish_transition_and_grant_resume_min_gap,"Exercise and verify the FSM transitions from ARBITRATION to REPLENISH when all requestors have zero credits and are requesting (legal edge), and then from REPLENISH back to ARBITRATION at the minimum legal interval (immediately after credit refill). Confirm that no grant is issued when credits are zero, credits are refilled in REPLENISH, and a new grant is issued on the first eligible cycle after refill, with correct latency as per specification.","1) Drive clk; rst=0.
2) Initialize priorities and credits by issuing grants until all credits are decremented to 0 (simulate by repeatedly driving req with a single bit set and ack=1 for each requestor in turn, until all credits are exhausted).
3) On the next cycle, drive req with all bits set (all requestors requesting), ack=0.
4) Observe that gnt_w==0 and gnt_id==0 (no eligible requestor), triggering FSM transition to REPLENISH state.
5) During REPLENISH, keep req unchanged; observe that no grant is issued and credits are refilled.
6) On the cycle after REPLENISH (minimum legal gap), observe that a grant is issued (gnt_w!=0, gnt_id matches requesting index), confirming transition back to ARBITRATION and resumption of arbitration.","1) When all credits are 0 and req is nonzero, no grant is issued (gnt_w==0, gnt_id==0).
2) FSM transitions to REPLENISH (observable by grant suppression and refill behavior).
3) No grant is issued during REPLENISH (gnt_w==0, gnt_id==0).
4) On the first cycle after REPLENISH, credits are refilled and a grant is issued to an eligible requestor.
5) Latency for credit refill and FSM transitions matches specification (exactly 2 cycles for refill, 1 cycle minimum gap for grant resumption).","Functional:
  - cp_credits: bins {all_zero, just_nonzero}.
  - cp_req: bins {all_active, one_active, single_active}.
  - cp_fsm_state: bins {ARBITRATION, REPLENISH}.
  - cp_fsm_transition: bins {ARBITRATION_to_REPLENISH, REPLENISH_to_ARBITRATION}.
  - cp_grant_after_refill: bins {first_cycle, later_cycle}.
Cross:
  - cross_credits_x_req: cp_credits × cp_req.
  - cross_fsm_transition_x_grant: cp_fsm_transition × cp_grant_after_refill.
Code:
  - FSM transition ARBITRATION→REPLENISH and REPLENISH→ARBITRATION.
  - Credit refill logic coverage.
  - Grant output logic after refill.",Arbitration FSM State Transition Verification,"[('weighted_round_robin_mas.pdf', 10)]"
