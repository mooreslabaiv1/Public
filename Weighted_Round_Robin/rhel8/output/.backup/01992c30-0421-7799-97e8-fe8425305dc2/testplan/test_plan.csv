Name,Description,Steps,Checkers,Goals,Related_Feature,Citations
single_clock_domain_synchronous_reset_and_basic_operation,"Verify that the module operates entirely within a single synchronous clock and reset domain: all state is synchronously reset by rst, and all observable behavior is synchronous to clk. Ensure that asserting the synchronous reset (rst) input correctly initializes all internal state (priority registers, credit counters, round-robin pointer), and that arbitration is ready to begin immediately after reset deassertion. Confirm that all observable outputs change only on clk rising edges, and that the module is ready for arbitration and grant issuance immediately after reset.","1) Drive clk continuously at a fixed frequency throughout the test.
2) Assert rst=1 for at least 4 clk cycles to ensure synchronous reset and state initialization.
3) During rst=1, drive all other inputs (req, ack, prio, prio_id, prio_upt) to 0.
4) Observe outputs gnt_w and gnt_id during reset (should be inactive or default).
5) Deassert rst (set rst=0) on a clk rising edge.
6) On the first clk cycle after rst=0, drive req to a one-hot value (e.g., req[0]=1, all others 0) to simulate a single requestor requesting; keep ack=0, prio_upt=0, prio=0, prio_id=0.
7) Observe gnt_w and gnt_id for a valid grant corresponding to the requesting input.
8) Assert ack=1 for 1 cycle to acknowledge the grant, then deassert ack.
9) Repeat steps 6-8 for req[1]=1 and req[31]=1 (min, mid, max requestor indices).
10) Optionally, perform a priority update (set prio_upt=1, prio_id=5, prio=4'b1010) on a clk rising edge, then drive prio_upt=0, and repeat grant/ack sequence for req[5]=1.","1) During rst=1, check that gnt_w==0 and gnt_id==0 on every clk rising edge.
2) On the first clk rising edge after rst=0, if req is one-hot, gnt_w matches req and gnt_id matches the requesting index (grant is issued immediately after reset).
3) For each grant/ack sequence, verify that grants are only issued on clk rising edges, and that gnt_w/gnt_id change only synchronously with clk.
4) After priority update, verify that the grant to req[5]=1 is still synchronous and that no outputs change except on clk rising edges.
5) Confirm that no observable output (gnt_w, gnt_id) changes value except on clk rising edges (no glitches or async behavior).
6) No spurious grants or invalid gnt_w/gnt_id values during or immediately after reset.
7) Arbitration is functional on the first cycle after reset deassertion (no extra latency).","Functional coverage:
  - cp_rst: bins {asserted, deasserted} for rst.
  - cp_req_idx: bins {0, 1, 31} for req index (min, mid, max) after reset.
  - cp_req: bins {all_zero, one_hot_0, one_hot_N-1} for req input after reset.
  - cp_gnt_w: bins {all_zero, one_hot_0, one_hot_N-1} for gnt_w output after reset.
  - cp_gnt_id: bins {0, N-1} for gnt_id output after reset.
  - cp_prio_upt: bins {no_update, update} for prio_upt.
  - cp_clk_edge: bins {rising} (all observable changes must occur on rising edge).
Cross coverage:
  - cross_req_idx_x_clk: cp_req_idx × cp_clk_edge.
  - cross_prio_upt_x_req_idx: cp_prio_upt × cp_req_idx.
  - cross_rst_x_req: cp_rst × cp_req (ensure all req patterns are tested immediately after reset).
Code coverage:
  - Statement/branch/toggle coverage of reset, clocking, and grant/arbitration logic.",Single Clock and Power Domain Operation,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13)]"
no_error_reporting_no_ecc_observable_outputs,"Verify that the IP does not produce any error reporting, ECC, or parity-related outputs under nominal operation, as required by the specification. Confirm that all observable outputs are limited to the documented grant and handshake signals, with no error or integrity signals present or asserted.","1) Drive clk continuously.
2) Assert rst=1 for at least 8 cycles, then deassert rst=0 to bring the IP out of reset.
3) For 32 cycles (N=32):
   a) For each cycle, drive req with a single bit set (one-hot), cycling through all 32 requestors.
   b) For each requestor, drive prio, prio_id, and prio_upt to update its priority (prio_id = requestor index, prio = 0..15, prio_upt=1 for one cycle).
   c) For each grant, drive ack=1 for one cycle after gnt_w is asserted.
4) Throughout, monitor all outputs: gnt_id, gnt_w. Confirm that no other outputs are present or change state.","1) Confirm that only gnt_id and gnt_w change in response to req, prio, prio_id, prio_upt, and ack.
2) Confirm that no error, ECC, or parity-related outputs are present or asserted (i.e., no undocumented outputs).
3) Scoreboard: For each request, verify that the grant corresponds to the expected requestor, and that no error or integrity signals are observed.
4) Confirm that the output signals remain stable and valid, with no spurious toggling or assertion of non-existent error outputs.","Functional coverage:
  - cp_req: bins for each requestor index (0..31) being asserted.
  - cp_prio: bins for prio values {0, 7, 15} (min, mid, max) during updates.
  - cp_ack: bins for ack asserted and not asserted.
  - cp_outputs: bins for gnt_id and gnt_w changing as expected; bin for 'no error outputs observed'.
Cross coverage:
  - cross_req_x_prio: cp_req × cp_prio.
  - cross_req_x_ack: cp_req × cp_ack.
Code coverage:
  - Statement/branch/toggle coverage of all output logic, confirming no error/ECC outputs are present or toggled.",No Internal Error Reporting or ECC,"[('weighted_round_robin_mas.pdf', 14)]"
no_grant_when_no_eligible_requests_basic,"Verify that the arbiter does not assert any grant (gnt_w, gnt_id) when no eligible requestors are present (i.e., all req inputs are 0), and that grant resumes only after a new request is asserted.","1) Drive clk continuously.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter (per reset/startup sequence).
3) After reset, drive req=0 (all N bits low) for at least 4 cycles, with ack=0, prio_upt=0.
4) Observe gnt_w and gnt_id during this window.
5) On a subsequent cycle, assert req[i]=1 for a single requestor (e.g., req=0...01), keep ack=0, prio_upt=0.
6) Observe gnt_w and gnt_id for at least 2 cycles after the new request is asserted.","1) For all cycles where req==0, check that gnt_w==0 and gnt_id==0 (no grant issued).
2) After req[i]=1 is asserted, check that within 1-2 cycles, gnt_w==one-hot(i) and gnt_id==i (grant resumes to the new requestor).
3) Ensure no spurious grant is issued during the idle period (req==0).","Functional coverage:
  - cp_req: bins {all_zero, single_one, multiple_ones} on req input.
  - cp_gnt: bins {none, single, multiple} on gnt_w output.
  - cp_idle_to_active: cross of cp_req==all_zero (idle) followed by cp_req==single_one (active) and observing gnt_w transition from 0 to one-hot.
Code coverage:
  - Statement/branch/toggle coverage of grant logic for idle and active requestor cases.",No Grant When No Eligible Requests,"[('weighted_round_robin_mas.pdf', 9)]"
basic_grant_and_internal_state_observability_nominal,"Verify that the externally observable outputs (gnt_w, gnt_id) are always consistent and accurately reflect the internal state transitions of the WRR arbiter under nominal operation. This includes demonstrating that the grant decision logic, which depends on internal credits, priorities, and pointer, is externally visible for debug and QoS monitoring. Also verify that credit updates are synchronized with grant issuance and hazard-free, as observable via grant cycling and request/acknowledge handshakes. Additionally, confirm that priority updates are reflected in grant decisions and that the grant outputs are consistent (one-hot and encoded index match) for all possible single and multiple grant cases.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for at least 4 cycles, then deassert rst=0 to initialize the arbiter (per Table 10.3 Reset / Startup Sequence).
3) For cycles 5-8, drive req=0 (all zeros) to confirm idle state.
4) For each requestor i in 0..N-1:
   a) Set req[i]=1, all other req=0 (single active requestor).
   b) Wait for gnt_w and gnt_id to indicate a grant.
   c) Assert ack=1 for one cycle to acknowledge the grant.
   d) Deassert ack=0, req[i]=0.
   e) Repeat for next requestor.
5) For multi-requestor scenarios:
   a) Set req[0]=1, req[1]=1, all others=0.
   b) Observe grant cycling between requestors as credits are decremented and refilled.
   c) Acknowledge each grant with ack=1.
6) Continue for several cycles, toggling ack and req to exercise round-robin and credit logic.
7) Optionally, at cycle 15, perform a priority update: set prio_id to a requestor, prio to a new value, prio_upt=1, then deassert prio_upt in next cycle. Observe effect on subsequent grant cycling.","1) For each cycle, record gnt_w and gnt_id.
2) Check that gnt_w is one-hot and matches the expected requestor per round-robin and credit logic.
3) For every cycle where gnt_w != 0, check that exactly one bit is set in gnt_w, and that gnt_id matches the index of the set bit.
4) After priority update, verify that the grant shifts to the updated requestor as soon as its new priority is effective.
5) Confirm that after reset, the first grant is to the lowest-index active requestor (pointer=0), and that pointer advances as grants are accepted.
6) For each grant, ensure that after ack=1, the next grant cycles to the next eligible requestor (per round-robin and credit rules).
7) Ensure that when no eligible requestor remains (all credits exhausted), gnt_w=0 and gnt_id=0, and after credit refill, grants resume as expected.
8) No grant (gnt_w=0, gnt_id=0) should occur unless all credits are exhausted and refill is pending.","Functional coverage:
  - cp_req: bins for single active requestor, multiple active requestors, all idle.
  - cp_gnt_id: bins for each possible gnt_id value (0..N-1).
  - cp_gnt_w: bins for all possible one-hot gnt_w values (one for each requestor).
  - cp_priority_update: bins for prio_upt=1 with prio_id in {0, N/2, N-1} and prio in {min, mid, max}.
  - cp_ack: bins for ack=0, ack=1.
  - cp_credit_refill: bin for cycles where no grant is issued (gnt_w=0) and next cycle resumes granting.
Cross coverage:
  - cross_req_x_gnt_id: cp_req × cp_gnt_id.
  - cross_priority_update_x_gnt_id: cp_priority_update × cp_gnt_id (to show effect of priority update on grant).
  - cross_gnt_id_x_ack: cp_gnt_id × cp_ack.
  - cross_gnt_id_x_prio_upt: cp_gnt_id × cp_prio_upt.
Timing coverage:
  - cp_grant_latency: bins for 1-cycle and 2-cycle latency (normal and refill).
Code coverage:
  - Statement/branch/toggle of grant, pointer, and priority update logic.",Internal State Observability for Debug and QoS,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 17)]"
basic_weighted_round_robin_nominal_grant,"Verify that the arbiter grants requests in proportion to their configured weights (priorities), using the WRR algorithm, and that the round-robin pointer advances to prevent starvation. Only one requestor is granted per cycle, and all grants are observable on gnt_w and gnt_id.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 to initialize the arbiter (per Table 10.3 Reset / Startup Sequence).
3) For requestors #0, #1, #2, set priorities via prio/prio_id/prio_upt as follows:
   - prio_id=0, prio=2, prio_upt=1 (set #0 priority to 2)
   - prio_id=1, prio=8, prio_upt=1 (set #1 priority to 8)
   - prio_id=2, prio=1, prio_upt=1 (set #2 priority to 1)
   - Wait 1 cycle after each update.
4) Drive req[2:0]=3'b111 (all three requestors active) for at least 12 cycles.
5) For each grant (gnt_w/gnt_id), assert ack=1 in the following cycle to accept the grant.
6) Continue stimulus for enough cycles to observe multiple grants to each requestor.","1) For each cycle, check that exactly one bit of gnt_w is high (one-hot), and gnt_id matches the granted requestor.
2) Track the number of grants per requestor over a window (e.g., 11 cycles after credits refill).
3) Compare the observed grant counts: #1 should receive approximately 8 grants, #0 about 2, #2 about 1, matching their weights (proportionality).
4) Ensure that no requestor is starved: each requestor receives at least one grant per full round.
5) Check that after all credits are exhausted, credits are refilled and the pattern repeats (per FSM and Table 7.2, 14.2).","Functional coverage:
  - cp_prio: bins {prio0=2, prio1=8, prio2=1} (priority values set).
  - cp_req_pattern: bins {all_active=3'b111}.
  - cp_gnt_id: bins {0,1,2} (all requestors granted at least once).
  - cp_gnt_count: bins {min=1, max=8} (grants per requestor per round).
  - cp_credit_refill: bins {refill_event} (credit refill observed).
Cross coverage:
  - cross_prio_x_gnt: cp_prio × cp_gnt_id (each priority setting leads to expected grant).
  - cross_gnt_id_x_credit_refill: cp_gnt_id × cp_credit_refill (each requestor granted before/after refill).
Code coverage:
  - Statement/branch/toggle of arbitration, credit, and pointer logic.",Weighted Round Robin Arbitration and Fairness,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 16)]"
basic_credit_decrement_and_replenish_nominal,"Verify that each requestor's credit counter is decremented on grant (ack=1) and replenished to prio+1 when exhausted, enforcing weight-based scheduling and preventing starvation. This scenario covers the nominal operation of the credit-based scheduling and replenishment policy.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 to initialize the IP (per Table 10.3 Reset / Startup Sequence).
3) For all requestors (N=32), set initial priorities via prio, prio_id, prio_upt if needed (default is 0 after reset, but can be set to a nonzero value for meaningful arbitration).
4) Drive req with a one-hot pattern for a single requestor (e.g., req=0x00000001) and keep ack=0 for the first cycle.
5) Observe gnt_w and gnt_id; when the grant is issued, drive ack=1 for one cycle to accept the grant.
6) Repeat the request for the same requestor until no grant is issued (credit exhausted).
7) Continue to assert req for the same requestor; observe that after one cycle of no grant, the credit is replenished to prio+1 and the grant resumes.
8) Optionally, repeat for a second requestor with a different priority value to confirm weight-based scheduling.","1) For each grant (gnt_w, gnt_id), confirm that the same requestor is granted until its credit is exhausted (number of grants equals initial prio+1).
2) After credit is exhausted, confirm that no grant is issued for one cycle (gnt_w=0, gnt_id=0).
3) On the next cycle, confirm that the grant resumes and the number of grants matches the replenished credit (prio+1).
4) If a second requestor is tested, confirm that the number of grants matches its priority weight.
5) Confirm that the grant sequence matches the expected round-robin order if multiple requestors are active.","Functional coverage:
  - cp_prio: bins {min=1, mid=8, max=15} for prio values used in replenishment.
  - cp_credit_exhaustion: bins {not_exhausted, exhausted} (grant issued vs. not issued due to credit).
  - cp_replenish: bins {replenished} (grant resumes after credit refill).
  - cp_req_id: bins for at least two distinct requestor IDs.
Cross coverage:
  - cross_prio_x_credit: cp_prio × cp_credit_exhaustion.
  - cross_req_id_x_prio: cp_req_id × cp_prio.
Code coverage:
  - Statement/branch/toggle coverage of credit decrement, exhaustion, and refill logic.",Credit-Based Scheduling and Replenishment Policy,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
basic_grant_acknowledge_and_progression,"Verify that the arbiter advances to the next eligible requestor only after the current grant is acknowledged (ack=1), and does not repeat grants to the same requestor without acknowledgment. This scenario checks the core handshake and progression behavior of the WRR arbiter.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0 to initialize the arbiter (per Table 10.3 Reset / Startup Sequence).
3) Set req[2:0]=3'b110 (requestors #1 and #2 active), all others 0.
4) For cycle 0:
   - ack=0 (no acknowledgment).
   - Observe gnt_w and gnt_id.
5) For cycle 1:
   - ack=1 (acknowledge previous grant).
   - req remains 3'b110.
   - Observe gnt_w and gnt_id.
6) For cycle 2:
   - ack=1 (acknowledge previous grant).
   - req remains 3'b110.
   - Observe gnt_w and gnt_id.
7) For cycle 3:
   - ack=0 (no acknowledgment).
   - req remains 3'b110.
   - Observe gnt_w and gnt_id.
8) Idle for 2 cycles with req=0 (no requests) to allow credit refill if needed.","1) On cycle 0, gnt_w must be one-hot for one of the active requestors (e.g., #1), and gnt_id must match.
2) On cycle 1, after ack=1, grant must advance to the next eligible requestor (e.g., #2), and gnt_id must update accordingly.
3) On cycle 2, after ack=1, if no eligible requestors remain (credits exhausted), gnt_w=0 and gnt_id=0.
4) At no point should the same requestor be granted twice in a row without an intervening ack=1.
5) If ack=0, grant must not advance to the next requestor.
6) All grant outputs must be consistent with the request and credit state as per the spec example tables.","Functional coverage:
- cp_req_pattern: bins {2'b10, 2'b11, 3'b110} (active requestor patterns).
- cp_ack: bins {ack=0, ack=1}.
- cp_gnt_id: bins {gnt_id=1, gnt_id=2, gnt_id=0} (for 3 requestors).
- cp_progression: cross of cp_ack × cp_gnt_id (ensure grant advances only on ack=1).
- cp_no_repeat: bin for no repeated grant to same requestor without ack.
Code coverage:
- Statement/branch/toggle coverage of grant, pointer, and credit update logic.",Grant Acknowledge and Progression,"[('weighted_round_robin_mas.pdf', 9)]"
basic_fsm_state_transition_and_refill_nominal,"Verify the correct operation of the two-state FSM (ARBITRATION, REPLENISH) in the WRR arbiter. Ensure that the FSM transitions from ARBITRATION to REPLENISH only when no eligible requestor is found (i.e., all credits exhausted or no requests), and that credits are refilled only in REPLENISH. Confirm that normal arbitration resumes after refill.","1) Drive clk continuously at a nominal frequency.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the design (per Table 10.3 Reset / Startup Sequence).
3) After reset, drive req[N-1:0] such that only a subset of requestors are active (e.g., req=0110 for N=3, requestors #1 and #2 active).
4) For each grant, drive ack=1 in the cycle after gnt_w indicates a grant (handshake per port description).
5) Continue granting until all credits for active requestors are exhausted (simulate by repeatedly acknowledging grants for the same requestors).
6) Once all credits are exhausted and requests remain, observe that no grant is issued (gnt_w=0), indicating FSM enters REPLENISH.
7) Maintain req asserted; observe that after one cycle, credits are refilled and arbitration resumes (gnt_w nonzero again).","1) Check that after reset, the first arbitration cycle produces a grant (gnt_w!=0) if req is asserted and credits are nonzero.
2) Check that after all credits are exhausted (i.e., after N grants with N=number of active requestors), gnt_w=0 for exactly one cycle (REPLENISH state).
3) Check that in the cycle after gnt_w=0, gnt_w becomes nonzero again, indicating arbitration resumes (FSM returns to ARBITRATION).
4) Confirm that the grant sequence after refill is consistent with the round-robin pointer and refilled credits.
5) Optionally, check that gnt_id matches the granted requestor index per gnt_w.","Functional coverage:
  - cp_fsm_state: bins {arbitration, replenish} inferred from gnt_w (nonzero/zero).
  - cp_refill_trigger: bin for cycle where gnt_w=0 and req is asserted (REPLENISH entry).
  - cp_refill_exit: bin for cycle after gnt_w=0 where gnt_w!=0 (ARBITRATION resumes).
  - cp_grant_sequence: bins for each requestor being granted before and after refill.
Cross coverage:
  - cross_fsm_state_x_req: cp_fsm_state × req pattern (e.g., all req asserted, single req asserted).
Timing coverage:
  - cp_refill_latency: bins {min=1, max=2} cycles between last grant and next grant after refill (per Table 12.2 Latency).",Global Arbitration FSM State Machine Operation,"[('weighted_round_robin_mas.pdf', 10)]"
basic_zero_starvation_round_robin_all_requestors,"Verify that, under continuous requests from all requestors, every requestor is eventually granted access (no starvation), regardless of initial priority configuration.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For all cycles, drive req[N-1:0]=all_ones (all requestors active).
4) For all cycles, drive ack=1 (every grant is accepted immediately).
5) Do not drive prio_upt, prio_id, or prio (keep priorities at reset/default).
6) Observe gnt_w and gnt_id each cycle for at least N*4 cycles (to allow multiple full round-robin passes).","1) For each requestor i (0..N-1), check that gnt_w[i]==1 and gnt_id==i is observed at least once within the observation window.
2) Check that no requestor is skipped indefinitely (i.e., the maximum gap between grants to any requestor is bounded by N*max_weight cycles).
3) Ensure that only one bit of gnt_w is high per cycle (one-hot grant).","Functional coverage:
  - cp_grant_id: coverpoint on gnt_id, bins for each value 0..N-1.
  - cp_grant_seq: coverpoint on sequence of gnt_id, bins for all possible consecutive pairs (i,j).
  - cp_grant_gap: coverpoint on number of cycles between consecutive grants to the same requestor, bins {min=1, max=N*max_weight}.
Cross coverage:
  - cross_grant_id_x_req: cp_grant_id × req[i]=1.
Code coverage:
  - Statement/branch/toggle of arbitration, pointer, and credit logic.",Zero-Starvation Guarantee,"[('weighted_round_robin_mas.pdf', 4)]"
zero_starvation_with_sparse_requests,"Verify that the zero-starvation guarantee holds even when only a subset of requestors are active at any time, and that inactive requestors are not granted until they request.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For cycles 0-15: drive req[0]=1, req[1]=1, all other req[i]=0.
4) For cycles 16-31: drive req[2]=1, req[3]=1, all other req[i]=0.
5) For cycles 32-47: drive req[0]=1, req[2]=1, all other req[i]=0.
6) For all cycles, drive ack=1.
7) Do not drive prio_upt, prio_id, or prio (keep priorities at default).
8) Observe gnt_w and gnt_id for at least 48 cycles.","1) For each active requestor in each window, check that it receives at least one grant.
2) For inactive requestors (req[i]=0), check that gnt_w[i]==0 and gnt_id!=i.
3) Ensure only one-hot gnt_w per cycle.","Functional coverage:
  - cp_active_req_set: coverpoint on which subset of req[N-1:0] is active, bins for all pairs and triplets.
  - cp_grant_id: coverpoint on gnt_id, bins for all active requestors in each window.
  - cp_inactive_no_grant: coverpoint on cycles where req[i]=0 and gnt_w[i]=0.
Cross coverage:
  - cross_active_req_x_grant_id: cp_active_req_set × cp_grant_id.
Code coverage:
  - Statement/branch/toggle of arbitration logic for partial request sets.",Zero-Starvation Guarantee,"[('weighted_round_robin_mas.pdf', 4)]"
zero_starvation_with_credit_refill,"Verify that when all credits are exhausted, the credit refill mechanism restores eligibility and all requestors are eventually granted again (no starvation after refill).","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For all cycles, drive req[N-1:0]=all_ones (all requestors active).
4) For all cycles, drive ack=1.
5) Optionally, set all priorities to a low value (e.g., prio=1 for all) at the start using prio_upt/prio_id/prio.
6) Observe gnt_w and gnt_id for at least N*4 cycles, ensuring that after N grants, all credits are exhausted and a refill occurs (as per FSM: ARBITRATION→REPLENISH→ARBITRATION).
7) Continue observing grants after refill.","1) Check that after the credit refill event (no eligible requestor, refill triggered), all requestors become eligible again and are granted within the next N cycles.
2) Ensure that the grant sequence resumes as expected after refill (no starvation).
3) Only one-hot gnt_w per cycle.","Functional coverage:
  - cp_credit_refill_event: coverpoint on cycles where no grant is issued (gnt_w==0), indicating refill.
  - cp_grant_after_refill: coverpoint on gnt_id in cycles after refill, bins for all requestors.
  - cp_grant_seq_across_refill: coverpoint on grant sequence before and after refill.
Cross coverage:
  - cross_credit_refill_x_grant_id: cp_credit_refill_event × cp_grant_after_refill.
Code coverage:
  - Statement/branch/toggle of credit refill and arbitration logic.",Zero-Starvation Guarantee,"[('weighted_round_robin_mas.pdf', 4)]"
zero_starvation_with_dynamic_priority_update,"Verify that dynamic priority (weight) updates do not cause starvation: after changing priorities at runtime, all requestors still eventually receive grants.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) For all cycles, drive req[N-1:0]=all_ones (all requestors active).
4) For cycles 10, 20, 30, ... (every 10 cycles), drive prio_upt=1 for one cycle, prio_id=target_id, prio=new_weight (cycle through all requestors and assign varying priorities, e.g., alternate between min and max allowed values).
5) For all other cycles, prio_upt=0.
6) Always drive ack=1.
7) Observe gnt_w and gnt_id for at least N*8 cycles.","1) For each requestor, check that after any priority update, the requestor still receives a grant within a bounded window (no starvation).
2) Check that grant frequency changes in accordance with updated priorities (higher weight → more frequent grants), but all requestors are still granted.
3) Ensure only one-hot gnt_w per cycle.","Functional coverage:
  - cp_prio_value: coverpoint on prio value applied, bins {min=1, max=15}.
  - cp_prio_update_id: coverpoint on prio_id, bins for each requestor.
  - cp_grant_id: coverpoint on gnt_id, bins for each requestor.
  - cp_grant_after_update: coverpoint on cycles between prio_upt and next grant to that requestor, bins {min, max}.
Cross coverage:
  - cross_prio_value_x_grant_id: cp_prio_value × cp_grant_id.
Code coverage:
  - Statement/branch/toggle of priority update and arbitration logic.",Zero-Starvation Guarantee,"[('weighted_round_robin_mas.pdf', 4)]"
parameterization_nominal_operation_coverage,"Verify correct WRR arbiter operation and observable outputs for the top-level parameter set (N=32, PRIORITY_W=4, CREDIT_W=8, ID_BITS=5), ensuring all parameter-driven port widths and behaviors are exercised under nominal conditions.","1) Drive clk continuously.
2) Assert rst=1 for 4 cycles, then deassert rst=0.
3) After reset, for 4 cycles, drive req=32'b0000_0000_0000_0000_0000_0000_0000_0011 (requestors #0 and #1 active), ack=0, prio_upt=0.
4) Observe gnt_w and gnt_id each cycle.
5) On cycle 5, drive ack=1 (accept grant), keep req unchanged.
6) Continue for 4 more cycles, toggling ack=1 every other cycle.
7) At cycle 10, drive prio_upt=1, prio_id=5'b00001 (requestor #1), prio=4'b1010 (set priority to 10), then prio_upt=0 next cycle.
8) Continue driving req for both requestors, observe grant rotation and effect of priority update.","1) After reset, confirm gnt_w and gnt_id are only asserted for active requestors (matching req).
2) Confirm that only one bit of gnt_w is set per cycle (one-hot), and gnt_id matches the granted requestor.
3) After prio update, verify that requestor #1 receives more frequent grants (proportional to new priority).
4) Confirm that no grant is issued when no req bits are set.
5) Confirm that all port widths match parameter values (e.g., gnt_w is 32 bits, gnt_id is 5 bits, prio is 4 bits).","Functional coverage:
  - cp_req: bins {single_active, dual_active, all_inactive} on req[31:0].
  - cp_gnt_id: bins {min=0, mid=15, max=31} on gnt_id.
  - cp_prio: bins {min=0, mid=8, max=15} on prio during update.
  - cp_ack: bins {0,1}.
  - cp_prio_upt: bins {0,1}.
Cross coverage:
  - cross_prio_x_gnt: cp_prio × cp_gnt_id (priority update vs. grant result).
  - cross_req_x_gnt: cp_req × cp_gnt_id.
Code coverage:
  - Statement/branch/toggle for all parameter-driven logic (array indexing, width decode, grant selection).",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
parameterization_min_max_widths_coverage,"Verify that the WRR arbiter correctly handles minimum and maximum legal values on all parameter-driven ports (req, gnt_w, gnt_id, prio, prio_id), ensuring no out-of-bounds or width violations occur for the assigned parameter set.","1) Drive clk continuously.
2) Assert rst=1 for 4 cycles, then deassert rst=0.
3) For 2 cycles, drive req=32'b0 (all inactive), ack=0, prio_upt=0. Observe that no grant is issued.
4) For next 2 cycles, drive req=32'b1 (only requestor #0 active), ack=0. Observe gnt_w and gnt_id.
5) For next 2 cycles, drive req=32'h8000_0000 (only requestor #31 active), ack=0. Observe gnt_w and gnt_id.
6) For next 2 cycles, drive prio_upt=1, prio_id=5'b11111 (requestor #31), prio=4'b1111 (max priority), then prio_upt=0.
7) For next 2 cycles, drive prio_upt=1, prio_id=5'b00000 (requestor #0), prio=4'b0000 (min priority), then prio_upt=0.
8) Observe all outputs for correct width and encoding.","1) Confirm that gnt_w is always 32 bits wide, only one bit set when grant is issued.
2) Confirm that gnt_id is always 5 bits wide, matches the granted requestor (0 or 31 as appropriate).
3) Confirm that prio and prio_id are always 4 and 5 bits wide, respectively, and updates only affect the targeted requestor.
4) Confirm that no grant is issued when req=0.
5) Confirm that no out-of-bounds access or assertion occurs for any port.","Functional coverage:
  - cp_req: bins {all_zero, only_0, only_31} on req[31:0].
  - cp_gnt_id: bins {min=0, max=31} on gnt_id.
  - cp_prio: bins {min=0, max=15} on prio.
  - cp_prio_id: bins {min=0, max=31} on prio_id.
Cross coverage:
  - cross_prio_id_x_prio: cp_prio_id × cp_prio (all combinations of min/max).
Code coverage:
  - Statement/branch/toggle for all min/max width logic and array bounds.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
parameterization_dynamic_priority_update_coverage,"Verify that dynamic priority updates via prio, prio_id, and prio_upt are correctly handled for all legal parameter-driven values, and that the effect is observable on grant outputs (gnt_w, gnt_id) under nominal operation.","1) Drive clk continuously.
2) Assert rst=1 for 4 cycles, then deassert rst=0.
3) After reset, drive req=32'b0000_0000_0000_0000_0000_0000_0000_0111 (requestors #0, #1, #2 active), ack=0.
4) For 2 cycles, observe grant rotation among active requestors.
5) On cycle 3, drive prio_upt=1, prio_id=5'b00010 (requestor #2), prio=4'b1111 (max priority), then prio_upt=0.
6) Continue driving req for all three, observe that requestor #2 is now granted more frequently.
7) On cycle 6, drive prio_upt=1, prio_id=5'b00001 (requestor #1), prio=4'b0001 (low priority), then prio_upt=0.
8) Continue for 4 more cycles, observe grant distribution.","1) Confirm that after prio update, the targeted requestor's grant frequency changes proportionally to new priority.
2) Confirm that prio/prio_id/prio_upt only affect the intended requestor.
3) Confirm that gnt_w and gnt_id reflect the updated priorities in grant selection.
4) Confirm that no grant is issued to inactive requestors.","Functional coverage:
  - cp_prio: bins {min=0, mid=8, max=15} on prio.
  - cp_prio_id: bins {0,1,2} (for exercised requestors).
  - cp_gnt_id: bins {0,1,2} (for observed grants).
  - cp_prio_upt: bins {0,1}.
Cross coverage:
  - cross_prio_id_x_prio: cp_prio_id × cp_prio.
  - cross_prio_x_gnt: cp_prio × cp_gnt_id.
Code coverage:
  - Statement/branch/toggle for dynamic priority update logic and grant selection.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
basic_arbitration_latency_and_pipeline_test,"Verify that the arbitration logic produces a grant (gnt_w, gnt_id) with 1-cycle latency under normal operation (credits available, no refill needed) for any requesting input, and that the sequential update of credits and pointer occurs in the following cycle as per the two-stage pipeline specification. Also verify correct behavior for multiple requestors, round-robin/weighted arbitration, and dynamic priority updates.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for 2-4 cycles to initialize the IP, then deassert rst=0.
3) Wait 1 cycle for initialization (per reset/startup sequence).
4) Drive req with a single bit set (e.g., req=32'b000...1) to requestor 0; all other inputs (ack, prio, prio_id, prio_upt) held at 0.
5) Observe gnt_w and gnt_id on the next cycle; expect a grant matching the requestor.
6) For each, assert ack=1 in the cycle after grant is observed, then deassert ack=0.
7) Repeat for at least one other requestor (e.g., req=32'b000...10 for requestor 1).
8) Repeat with multiple requestors (e.g., req=32'h0000_0003) to observe round-robin and weighted arbitration.
9) Optionally, update priorities using prio_upt=1, prio_id, and prio to test dynamic priority effect on arbitration (ensure prio_upt is asserted with valid prio_id and prio during a cycle).","1) For each req presented, check that gnt_w and gnt_id reflect the correct granted requestor exactly 1 cycle later (normal operation).
2) Confirm that the grant is one-hot and matches the requesting bit.
3) Confirm that no grant is issued before the 1-cycle latency.
4) After ack=1, verify that the credit for the granted requestor is decremented (inferred by observing grant rotation or lack of grant if credit exhausted), and that the grant moves to the next eligible requestor if multiple requests are present.
5) If all credits are exhausted (no eligible requestors), verify that no grant is issued for 1 cycle, then grants resume after credit refill (2-cycle latency for refill path).
6) If prio_upt is asserted, verify that the next arbitration reflects the updated priority (i.e., higher priority requestor wins if requests are simultaneous).","Functional coverage:
  - cp_req_idx: bins for at least two distinct requestor indices (e.g., 0 and 1).
  - cp_req: bins for single requestor, multiple requestors, all requestors.
  - cp_gnt: bins for each possible gnt_id value (0..31).
  - cp_latency: bins for 1-cycle (normal) and 2-cycle (credit refill) latency.
  - cp_ack: bins {ack_0, ack_1} to cover both grant acceptance and idle.
  - cp_prio_update: bins for prio_upt=0 (no update) and prio_upt=1 (update during arbitration).
Cross coverage:
  - cross_req_idx_x_latency: cp_req_idx × cp_latency.
  - cross_req_x_gnt: cp_req × cp_gnt.
  - cross_prio_update_x_gnt: cp_prio_update × cp_gnt.
Code coverage:
  - Statement/branch/toggle of arbitration, grant, and sequential update logic for at least two requestors.",Arbitration Latency Envelope and Pipelining,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
arbitration_latency_and_credit_refill_with_priority_update,"Verify that the arbitration latency envelope (1 cycle under normal operation, 2 cycles on credit refill) is maintained, including when dynamic priority updates (prio, prio_id, prio_upt) occur during operation. Ensure that after all credits are exhausted and a credit refill is triggered, the arbiter produces a grant within 2 cycles, and that priority updates do not introduce spurious delays or skipped grants.","1) Drive clk continuously.
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) Wait 1 cycle for initialization.
4) For at least two requestors (e.g., 0 and 1), assert req for both (e.g., req=32'b...11).
5) On the first grant, assert ack=1 and simultaneously drive prio_upt=1, prio_id to the granted requestor, and prio to a new value (e.g., prio=4'b1000). Deassert prio_upt after 1 cycle; keep req asserted for both requestors.
6) For one requestor, repeatedly assert req and ack=1 for CREDIT_W+1 cycles to exhaust its credit (simulate grants until credit runs out). On the cycle after credit is exhausted, keep req asserted and ack=0.
7) Observe gnt_w and gnt_id for subsequent grants, especially after credit exhaustion and priority update.
8) Repeat with priority update for another requestor during grant/ack and with credit exhaustion/refill for both requestors.","1) Check that grant is issued within 1 cycle under normal operation, even when priority update occurs.
2) Confirm that after credit exhaustion, no grant is issued in the first cycle (refill triggered), but a grant is issued within 2 cycles after exhaustion.
3) Confirm that after priority update, the next grant reflects the new priority (higher weight requestor wins more often).
4) Confirm that gnt_w and gnt_id match the requesting input after refill and/or priority update.
5) Confirm that no spurious delay or skipped grant occurs due to priority update or credit refill.
6) Confirm that the refill occurs only when all credits are exhausted and no eligible requestor is found.","Functional coverage:
  - cp_credit_state: bins {credit_available, credit_exhausted}.
  - cp_prio_upt: bins {no_update, update_during_ack}.
  - cp_latency: bins {1_cycle, 2_cycles} for both normal and refill paths.
  - cp_req_idx: bins for at least two requestor indices.
Cross coverage:
  - cross_credit_state_x_latency: cp_credit_state × cp_latency.
  - cross_prio_upt_x_latency: cp_prio_upt × cp_latency.
Code coverage:
  - Statement/branch/toggle of refill logic, priority update, and arbitration FSM transitions.",Arbitration Latency Envelope and Pipelining,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
runtime_priority_update_and_grant_acknowledge_no_arbitration_interference,"Verify that the priority register file can be updated via the sideband interface (prio, prio_id, prio_upt) at any time, including simultaneously with grant acknowledgment (ack), and that arbitration/granting proceeds correctly without interruption, stalling, or misbehavior. Ensure that updating a requestor's priority at runtime does not stall or interfere with ongoing arbitration or grant cycles, and that the new priority takes effect for subsequent arbitration cycles. Specifically, confirm that simultaneous assertion of a priority update and grant acknowledge in the same clock cycle is handled correctly, with both operations processed without hazards or race conditions.","1) Drive clk continuously.
2) Assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the IP (priority registers cleared, credits initialized, pointer reset).
3) Drive req with a one-hot or multi-hot pattern (e.g., req=3'b101 or req=3'b011 for multiple requestors active).
4) Set initial priorities for all requestors to a known value (e.g., prio=4'b0010 for all, via prio/prio_id/prio_upt if required, or assume default per reset).
5) Observe gnt_w and gnt_id for a cycle to determine initial grant behavior.
6) On a cycle where a grant is expected, simultaneously assert prio_upt=1, prio_id=<valid ID>, prio=<valid 4-bit value> to update the priority of a requestor, while also asserting ack=1 to acknowledge the current grant.
7) Repeat priority updates for different prio_id/prio combinations, including updating the currently granted requestor, a non-granted but requesting requestor, and an idle requestor.
8) Deassert prio_upt and ack in the following cycle, keep req stable, and continue to observe gnt_w and gnt_id for several cycles to track grant decisions and arbitration behavior.","1) Confirm that a grant is issued every cycle (gnt_w != 0, gnt_id valid) except during documented refill cycles, and that no cycle is stalled or skipped due to prio/prio_id/prio_upt activity.
2) For each prio_upt event, check that the priority register for prio_id is updated to prio (by observing subsequent grant patterns), and that the updated requestor is granted in accordance with its new priority.
3) When prio_upt and ack are asserted in the same cycle, ensure that the grant for the current cycle is correct (matches pre-update priorities), and the next arbitration cycle reflects the updated priority.
4) Ensure that both operations (ack and prio_upt) are processed in the same cycle without observable hazards (no skipped grants, no incorrect grant IDs, no stuck outputs).
5) No spurious or missing grants: gnt_w and gnt_id must always correspond to a valid, requesting, and credited requestor. No requestor is starved or skipped due to priority update.","Functional coverage:
  - cp_prio_upt: bins {0,1} on prio_upt.
  - cp_prio_id: bins for min, mid, max requestor IDs.
  - cp_prio_val: bins for min, low, max priority values.
  - cp_ack: bins {0,1} on ack during prio_upt.
  - cp_simultaneous: bin for cycles where both ack=1 and prio_upt=1.
  - cp_req_pattern: bins for single, dual, and all requestors active.
  - cp_grant_seq: bins for grant sequences before and after priority update.
Cross coverage:
  - cross_prio_upt_x_grant: cp_prio_upt × cp_grant_seq.
  - cross_prio_id_x_grant: cp_prio_id × cp_grant_seq.
  - cross_prio_id_x_prio_val: cp_prio_id × cp_prio_val.
  - cross_prio_upt_ack_overlap_x_req_pattern: cp_prio_upt × ack × req pattern.
  - cross_simultaneous_x_gnt: cp_simultaneous × cp_grant_seq.
Code coverage:
  - Statement/branch/toggle coverage of priority update, arbitration, and grant acknowledge logic.",Runtime Priority Update Without Arbitration Interference,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 21)]"
stress_no_internal_error_reporting_ecc_long_run,"Exercise all observable interfaces under sustained, high-load operation to confirm the absence of any error reporting, ECC, or parity protection features. The scenario stresses the design by maximizing legal activity on all ports, ensuring that no error-related outputs or behaviors are present, and that the design remains silent regarding internal errors regardless of traffic patterns or duration.","1) Apply clk and rst as per normal operation; ensure rst is deasserted after a legal reset period.
2) For at least 10,000 cycles:
   a) Continuously drive req[N-1:0] with random, legal request patterns (seed=42 for reproducibility), ensuring all requestors are exercised.
   b) Randomly update priorities via prio, prio_id, and prio_upt at a high rate (every 2-10 cycles), covering all requestors and all legal priority values.
   c) Respond to gnt_w and gnt_id by asserting ack with minimum legal delay (1-2 cycles), ensuring all grants are acknowledged.
3) No error injection or illegal stimulus is applied; all traffic is within spec.
4) Observe all outputs (gnt_id, gnt_w) and monitor for any unaccounted-for output activity or signals that could indicate error reporting.","1) Assert that no output signals outside of gnt_id and gnt_w are ever driven or toggled (i.e., no error, ECC, or parity outputs exist).
2) Confirm that gnt_id and gnt_w behave as per round robin and priority update logic, with no interruptions or anomalous cycles.
3) Check that the design never asserts any error, ECC, or parity status via observable ports.
4) Ensure that the system remains responsive (no deadlock or hang) throughout the stress period.","Functional:
  - cp_req_activity: bins for each requestor being active.
  - cp_prio_update: bins for each requestor receiving a priority update.
  - cp_duration: bins for short, medium, and long sustained operation windows.
Cross:
  - cross_req_x_prio: requestor active × priority update.
Code:
  - Cover all control and datapath logic under high activity, especially any blocks that could conceivably implement error/ECC reporting.",No Internal Error Reporting or ECC,"[('weighted_round_robin_mas.pdf', 14)]"
stress_no_grant_when_no_eligible_requests_long_run,"Sustained stress test to verify that the arbiter never asserts any grant (gnt_w, gnt_id) when no eligible requests are present (i.e., all req=0 or all credits exhausted), and only resumes granting after credits are refilled or new requests are asserted. Measures latency from refill to next grant and ensures no spurious grants under high-load and idle conditions.","1) Apply clk and rst; ensure all credits and priorities are initialized per reset/startup sequence (see spec 10.3).
2) For cycles 0..T1, drive req=0 (all requestors idle). Observe that gnt_w and gnt_id remain zero for the entire interval.
3) At cycle T1, assert a single req[i]=1 (others 0), and keep ack=0. Observe grant behavior.
4) After grant is observed, drive ack=1 for one cycle, then deassert req[i].
5) Repeat steps 2-4 for all requestors, one at a time, and then with multiple simultaneous requests.
6) For cycles T2..T3, drive all req=1 and ack=1, cycling until all credits are exhausted (simulate high-load, all requestors active). Then, deassert all req and observe refill behavior.
7) After refill (per FSM), re-assert requests and verify grants resume only after credits are replenished.
8) Repeat the above for a long duration (≫N cycles) to check for stability and absence of spurious grants.","1) At all times when no eligible requests (req=0 or all credits=0), gnt_w==0 and gnt_id==0.
2) After credits are refilled and at least one req[i]=1, grant is asserted within 2 cycles (per latency spec 12.2).
3) No grant is issued unless both req[i]=1 and credit[i]>0.
4) No deadlock: after refill and new requests, forward progress is observed (grant issued).
5) No protocol violations: handshake (ack) is respected; no double grants or missed grants.
6) All grant events are accounted for; no extra grants during idle/refill.","Functional:
  - cp_idle_len: bins {short, medium, long} for duration of idle (no req).
  - cp_refill_latency: bins {1,2} cycles from refill to next grant.
  - cp_req_pattern: bins {single, multiple, all} for requestor activation.
Cross:
  - cross_idle_x_req: cp_idle_len × cp_req_pattern.
Code:
  - Coverage of ARBITRATION and REPLENISH FSM states, and transitions between them under stress.",No Grant When No Eligible Requests,"[('weighted_round_robin_mas.pdf', 9)]"
stress_synchronous_reset_under_sustained_load,"Exercise the synchronous reset (rst) under conditions of sustained, high-load request activity. Verify that all internal state (priority registers, credit counters, round-robin pointer) is correctly initialized regardless of in-flight requests, and that arbitration resumes immediately after reset deassertion with correct initial state. Stress the reset by asserting it at various points during heavy traffic, including mid-arbitration and during priority updates.","1) Apply clk at nominal frequency. Set rst=1 for at least one cycle to trigger synchronous reset.
2) While rst=1, drive req[N-1:0] with all bits high (all requestors active), prio_upt=1, prio_id and prio with random legal values (simulate in-flight priority updates), and ack toggling.
3) After one or more cycles, deassert rst (rst=0) and continue driving req[N-1:0]=all 1's for at least 1000 cycles, with ack toggling every cycle (simulate maximum throughput), and periodically issue prio_upt pulses with random prio/prio_id.
4) Repeat the above with rst asserted at different phases: (a) idle (no req), (b) mid-burst (all req, ack active), (c) during prio update, (d) just before/after grant.
5) For determinism, use seed=42 for randomization of prio/prio_id updates.","1) After rst=1, on the first clk rising edge, observe that gnt_w=0, gnt_id=0, and that the first arbitration after rst=0 produces a valid grant (gnt_w one-hot, gnt_id in [0,N-1]) within 1 cycle.
2) Confirm that after reset, all requestors start with priority=0, credit=1, pointer=0 (as observable via grant pattern).
3) No protocol violations: gnt_w is always one-hot or zero, gnt_id matches gnt_w, no grants issued while rst=1.
4) Throughput after reset matches spec: first grant within 1 cycle after rst=0, then continuous grants if req/ack are held high.
5) No deadlock: forward progress resumes immediately after reset.
6) If prio/prio_id/prio_upt are toggled during rst=1, confirm no illegal state or stuck behavior after rst=0.","Functional:
  - cp_rst_phase: bins {idle, mid_burst, prio_update, pre_grant, post_grant} (reset asserted at different phases).
  - cp_req_pattern: bins {all_zeros, all_ones, random} during reset.
  - cp_prio_update_during_rst: bins {yes, no}.
  - cp_grant_latency_after_rst: bins {1,2,>2} cycles.
Cross:
  - cross_rst_phase_x_grant_latency: cp_rst_phase × cp_grant_latency_after_rst.
Code:
  - Coverage of reset logic, state initialization, and arbitration resumption under all stress conditions.",Synchronous Reset and State Initialization,"[('weighted_round_robin_mas.pdf', 13)]"
stress_single_clock_domain_max_throughput,"Sustained, back-to-back requests from all requestors under a single clock and power domain, with synchronous reset. This scenario stresses the arbitration logic, credit counters, and priority updates to verify correct operation at maximum legal throughput, ensuring all state transitions and handshakes are synchronous to clk and rst, with no asynchronous crossings. Expected: 1-cycle arbitration latency (spec 12.2), no protocol violations, and correct grant sequencing.","1) Assert rst high for 1 cycle, then deassert (per spec 10.3: synchronous reset initializes all state).
2) Drive clk continuously at nominal frequency (single clock domain).
3) For 10,000 cycles:
   - Drive req[N-1:0] = all 1's (all requestors active).
   - On each cycle, drive ack=1 (accept every grant immediately).
   - Periodically (every 100 cycles), issue prio_upt=1 with prio_id cycling through all requestors and prio set to random legal values [0..15] (PRIORITY_W=4).
4) No manipulation of clk/rst during run; all transitions synchronous.
5) Observe gnt_w, gnt_id each cycle; record grant sequence and latency.","1) No grant issued when rst=1; all state initialized as per spec (priority=0, credit=1, pointer=0).
2) After rst=0, every requestor is granted in proportion to its priority (weighted round robin), with no starvation.
3) All grant/ack handshakes are synchronous to clk; no glitches or out-of-cycle transitions.
4) Arbitration latency is 1 cycle in normal operation, 2 cycles during credit refill (spec 12.2).
5) No protocol violations: no double grants, no missed requests, no asynchronous events.","Functional:
  - cp_req_pattern: bins {all_active, single_active, alternating} (here: all_active).
  - cp_prio_update: bins {no_update, periodic_update}.
  - cp_latency: bins {1,2} (normal, refill).
Cross:
  - cross_prio_update_x_latency: cp_prio_update × cp_latency.
Code:
  - Coverage of all synchronous state transitions (reset, arbitration, refill, priority update) under load.",Single Clock and Power Domain Operation,"[('weighted_round_robin_mas.pdf', 12)]"
stress_parameter_extremes_sustained_throughput,"Exercise the WRR arbiter at the maximum legal parameter values (N=32, PRIORITY_W=4, CREDIT_W=8, ID_BITS=5) under sustained, back-to-back request load. Assess throughput, latency, and correct grant behavior across all requestors. This scenario stresses array sizing, encoding, and arbitration logic under the highest supported configuration.","1) Apply clk and rst; hold rst high for 1 cycle, then deassert.
2) For N=32, drive req[31:0] such that all requestors are asserted (req=32'hFFFF_FFFF) for at least 10,000 cycles.
3) For each grant (gnt_w, gnt_id), assert ack in the next cycle to accept the grant immediately (no artificial backpressure).
4) Do not issue any prio_upt (priority update) during this run; all priorities remain at default (e.g., 4).
5) Record timestamps of each grant and the corresponding requestor ID.
6) Repeat for at least 10,000 cycles to ensure long-run stability and to allow for credit wrap-around and pointer cycling.","1) No protocol violations: gnt_w is one-hot or zero; gnt_id matches the granted requestor.
2) No drops: Every requestor with an asserted req is eventually granted (zero starvation).
3) Throughput: At least one grant per cycle in normal operation (spec: 1-cycle latency, Section 12.2).
4) Latency: No grant is delayed more than N cycles (due to round-robin fairness and credit refill).
5) Forward progress: No requestor is starved for more than N×(max_credit) cycles.
6) Grant distribution: Over the run, each requestor receives a number of grants proportional to its priority (all equal here).","Functional:
  - cp_req_active: bins {all_active, partial_active, single_active} (here: all_active).
  - cp_grant_latency: bins {1, 2, ..., N}.
  - cp_credit_wrap: cover at least one full credit depletion/refill per requestor.
Cross:
  - cross_req_x_grant: req_active × grant_latency.
Code:
  - Cover all grant logic, pointer wrap, and credit refill paths under max parameterization.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
stress_internal_state_observability_under_sustained_load,"Exercise the WRR arbiter under sustained, high-load conditions with dynamic priority updates to stress the observability of all internal state signals (credits, priorities, pointer, grant signals) via top-level outputs. The scenario ensures that debug and QoS monitoring can track fairness and scheduling behavior in real time, even as priorities change and credits are replenished.","1) Apply clk and rst; hold rst high for at least 2 cycles, then deassert.
2) Drive req[N-1:0] such that all requestors are continuously requesting (req = 32'hFFFF_FFFF) for at least 10,000 cycles.
3) For the first 2,000 cycles, keep priorities at default (prio_reg[i]=4 for all i).
4) At cycle 2,000, begin issuing prio_upt pulses every 100 cycles, updating prio and prio_id to random (seeded) values within [0,15] for different requestors, to simulate dynamic QoS changes.
5) Always assert ack=1 every cycle to ensure every grant is accepted immediately (no backpressure).
6) Observe gnt_w and gnt_id every cycle; record their values for later analysis.
7) Repeat for at least 10,000 cycles to ensure credit counters wrap and pointer cycles through all values multiple times.","1) For every cycle, check that gnt_w is one-hot or zero, and gnt_id matches the active bit in gnt_w.
2) No grant is issued to a requestor with zero credit (as inferred from grant patterns and priority updates).
3) After each prio_upt, verify that subsequent grant patterns reflect the new priority within CREDIT_W cycles.
4) All requestors receive at least one grant per full pointer cycle (fairness/zero-starvation).
5) No deadlock: gnt_w or gnt_id toggles at least once every N cycles.
6) Latency from request to grant is always within [1,2] cycles (per spec Table 12.2).","Functional:
  - cp_priority_update: bins {no_update, single_update, burst_updates}.
  - cp_credit_wrap: bins {no_wrap, single_wrap, multi_wrap}.
  - cp_pointer_cycle: bins {partial, full, multi_full}.
  - cp_grant_distribution: bins {uniform, skewed, dynamic}.
Cross:
  - cross_priority_update_x_credit_wrap: cp_priority_update × cp_credit_wrap.
Code:
  - Coverage over all grant outputs, pointer values, and priority/credit update logic under stress.",Internal State Observability for Debug and QoS,"[('weighted_round_robin_mas.pdf', 10)]"
stress_sustained_back_to_back_arbitration_and_replenish_cycles,"Exercise the Global Arbitration FSM by driving all requestors to continuously request service, ensuring the FSM alternates between ARBITRATION and REPLENISH states under sustained load. This scenario stresses the FSM's ability to maintain maximum throughput, trigger replenishment only when no eligible requestor exists, and recover to ARBITRATION without deadlock. Expected: 1-cycle latency in ARBITRATION, 2-cycle latency during REPLENISH (per spec).","1) Apply clk and rst; hold rst high for 2 cycles, then deassert.
2) Initialize all requestors (req[N-1:0]) to 1 (all requestors active) for the entire test duration (e.g., 10,000 cycles).
3) Set ack=1 every cycle to accept every grant immediately (no backpressure).
4) Do not assert prio_upt (prio_upt=0) to keep priorities static.
5) Observe gnt_w and gnt_id each cycle.
6) Run for enough cycles to ensure multiple full credit depletion and replenishment cycles for all requestors (at least 3×(max credit value) cycles).","1) No cycle issues more than one grant (gnt_w one-hot, gnt_id matches).
2) No grant is issued when all credits are zero (FSM must enter REPLENISH).
3) After REPLENISH, all credits are restored to prio+1 and ARBITRATION resumes.
4) Latency between request and grant is 1 cycle in ARBITRATION, 2 cycles during REPLENISH (per spec 12.2).
5) No deadlock: gnt_w/gnt_id continue to toggle, and all requestors eventually receive grants (zero starvation).
6) FSM alternates between ARBITRATION and REPLENISH as expected (can be inferred from grant gaps and credit exhaustion).","Functional:
  - cp_fsm_state: bins {ARBITRATION, REPLENISH} (inferred from grant/no-grant cycles).
  - cp_credit_depletion: bins {full, partial, zero} per requestor.
  - cp_latency: bins {1,2} (ARBITRATION, REPLENISH).
Cross:
  - cross_fsm_x_latency: cp_fsm_state × cp_latency.
Code:
  - Cover all FSM transitions and grant logic under sustained load.",Global Arbitration FSM State Machine Operation,"[('weighted_round_robin_mas.pdf', 10)]"
stress_sustained_max_throughput_arbitration_and_grant_consistency,"Sustained, back-to-back requests from all N=32 requestors to maximize throughput and exercise the arbitration, grant output, and credit update logic under continuous maximum load. All requestors assert requests every cycle for a long duration, with ack asserted every cycle to accept every grant immediately. This scenario verifies that the arbiter produces a grant every cycle (1-cycle latency) except when a credit refill is required (2-cycle latency), that gnt_w (one-hot) and gnt_id (encoded) outputs are always consistent, and that credit updates are synchronized and hazard-free. It also ensures that no grant is repeated for the same requestor without an intervening ack, all requestors are granted in turn (no starvation), and that the arbitration pipeline operates correctly under full concurrency.","1) Apply clk and rst; hold rst high for at least 1 cycle, then deassert to initialize all internal state per reset/startup sequence.
2) For at least 10,000 cycles, drive req[31:0]=32'hFFFF_FFFF (all requestors active every cycle).
3) For every cycle, drive ack=1 (accept every grant immediately, no backpressure).
4) Do not assert prio_upt (no priority changes during this scenario; priorities remain at default).
5) Monitor gnt_w and gnt_id outputs every cycle; record grant decisions, timing, and per-requestor grant counts.
6) Optionally, repeat with different initial credit and priority values to ensure coverage of refill events.","1) For every cycle where gnt_w != 0, exactly one bit of gnt_w is set, and gnt_id matches the index of the set bit.
2) No cycle where gnt_w is nonzero has a mismatch with gnt_id.
3) No grant is issued to a requestor with zero credit; credits are decremented only when grant is issued and ack=1; credits are refilled per spec when exhausted.
4) No grant (gnt_w/gnt_id) is repeated for the same requestor without an intervening ack=1.
5) Each requestor is granted in turn, following round-robin/weighted order, with no starvation.
6) Grant latency (from request to grant) is always 1 cycle (normal) or 2 cycles during credit refill (per spec Table 12.2).
7) Throughput: At least 1 grant per cycle sustained for the duration, except during refill cycles.
8) No deadlock: gnt_w/gnt_id change at least every N cycles; all requestors eventually granted.","Functional:
  - cp_ack_gap: bins {1} (ack every cycle).
  - cp_req_active: bins {all_active}.
  - cp_grant_seq: bins {no_repeat, round_robin}.
  - cp_latency: bins {1,2} (grant latency in cycles).
  - cp_refill: bins {no_refill, refill_event}.
  - cp_grant_consistency: bins {consistent, inconsistent} for gnt_w/gnt_id.
  - cp_credit_update: bins {decrement, refill} per requestor.
  - cp_grant_dist: per-requestor grant count bins (uniformity).
Cross:
  - cross_ack_gap_x_grant_seq: cp_ack_gap × cp_grant_seq.
  - cross_latency_x_refill: cp_latency × cp_refill.
  - cross_grant_x_credit: cp_grant_consistency × cp_credit_update.
Code:
  - Coverage of arbitration logic, pointer update, credit decrement/refill, grant output, and pipeline update under max load.",Grant Output and Credit Update Consistency,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 17)]"
stress_burst_idle_and_refill_latency_fsm_resilience,"Alternate between long bursts of requests (all req[N-1:0]=1) and idle periods (all req[N-1:0]=0) to stress FSM transitions, credit exhaustion/refill, and arbitration pipeline latency. This scenario ensures correct FSM entry/exit from ARBITRATION and REPLENISH, verifies that latency never exceeds 2 cycles during refill, and that the pipeline recovers to 1-cycle latency after refill. It also checks that the FSM and pipeline recover from idle without error, and that grant fairness and protocol correctness are maintained across burst, idle, and refill boundaries.","1) Apply clk and rst; hold rst high for 2 cycles, then deassert.
2) For 256 cycles, set req[N-1:0]=1 (all requestors active), ack=1.
3) For next 8 cycles, set req[N-1:0]=0 (no requests), ack=0.
4) Repeat this burst-idle pattern for at least 40 iterations (to cover multiple credit exhaustion/refill events and FSM transitions).
5) Do not assert prio_upt (prio_upt=0).
6) Observe gnt_w, gnt_id, and record grant timing and latency, especially across burst-to-idle, idle-to-burst, and refill transitions.","1) During burst: grants are issued every cycle until credits deplete, then FSM enters REPLENISH and resumes after refill; every eligible request is granted within 1 cycle except at refill boundary (max 2 cycles).
2) During idle: no grants are issued, FSM remains in ARBITRATION or REPLENISH as appropriate.
3) After idle, FSM and pipeline resume normal operation without error or deadlock.
4) No protocol violations (no grant when no request, no multiple grants, gnt_w one-hot or zero, gnt_id matches granted requestor).
5) No grant is delayed beyond 2 cycles at any time; after refill, pipeline resumes 1-cycle latency.
6) All requestors receive grants over time (fairness).
7) Latency matches spec during burst, refill, and after idle (1 or 2 cycles as appropriate).","Functional:
  - cp_burst_len: bins {short, long} (burst duration).
  - cp_idle_len: bins {short, long} (idle duration).
  - cp_latency: bins {1, 2} (latency per grant).
  - cp_fsm_state: bins {ARBITRATION, REPLENISH}.
  - cp_refill_boundary: bins {pre_refill, refill, post_refill}.
Cross:
  - cross_burst_x_fsm: cp_burst_len × cp_fsm_state.
  - cross_burst_len_x_latency: cp_burst_len × cp_latency.
  - cross_refill_x_latency: cp_refill_boundary × cp_latency.
Code:
  - Cover FSM transitions from idle to active and vice versa.
  - Coverage of refill logic, arbitration pipeline, and grant fairness during bursty operation.",Global Arbitration FSM State Machine Operation,"[('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
stress_burstiness_acknowledge_and_credit_wraparound,"This scenario stresses the arbiter with bursty request patterns, variable acknowledge (ack) gaps, and alternating idle periods to exercise credit counter depletion, refill, and wraparound logic. It verifies that the arbiter holds grants until ack is received, never advances grant without ack, and resumes progression immediately after ack. The scenario also ensures that no requestor is starved during or after bursts, that credit counters wrap and refill correctly, and that grant/credit consistency is maintained across burst boundaries and over long durations. The system's ability to recover from idle to active transitions and maintain protocol correctness under these stress conditions is validated.","1) Apply clk and rst; hold rst=1 for 2 cycles, then deassert (rst=0).
2) For N=32, alternate between burst and idle phases:
   a) Burst phase: For 100 cycles, drive req[31:0]=32'hFFFF_FFFF (all requestors active). For each grant, randomize ack gap between 1 and 4 cycles (after grant, hold ack=0 for 0–3 cycles, then ack=1 for 1 cycle; seed=42 for reproducibility).
   b) Idle phase: For 20–50 cycles, drive req[31:0]=0 (no requests), ack=0.
3) Repeat burst-idle pattern for at least 10,000 cycles to ensure credit wraparound and long-run stability.
4) Optionally, in some idle phases, update priorities for a subset of requestors to stress credit refill and pointer logic.
5) Monitor gnt_w, gnt_id, and credit behavior, especially at burst start/end and after many cycles.","1) Grant (gnt_w/gnt_id) is held for a requestor until ack=1 is received; no grant progression without ack.
2) No grant is repeated for the same requestor without ack.
3) Grant latency (from request to grant) is always ≥1 and ≤4 cycles (per ack gap).
4) No deadlock: after ack, grant advances within 1 cycle; grants resume immediately at burst start after idle.
5) Every requestor is granted at least once per burst; no starvation during or after bursts.
6) Credit counters decrement only during bursts, refill and wrap as expected (detected by grant patterns and latency).
7) No protocol violations; gnt_w/gnt_id legal at all times; no grant/ID mismatch, credit error, or illegal wraparound.","Functional:
  - cp_ack_gap: bins {1,2,3,4} (ack delay cycles).
  - cp_burst_len: bins {short, long}.
  - cp_idle_len: bins {short, long}.
  - cp_credit_wrap: bins {no_wrap, wrap}.
  - cp_refill: bins {none, single, repeated}.
  - cp_latency: bins {1,2} cycles.
Cross:
  - cross_ack_gap_x_burst_len: cp_ack_gap × cp_burst_len.
  - cross_burst_len_x_credit_wrap: burst length × credit refill events.
  - cross_burst_x_credit: cp_burst_len × cp_credit_wrap.
  - cross_burst_x_refill: cp_burst_len × cp_refill.
Code:
  - Coverage of grant hold logic, ack handshake, pointer update, credit depletion/refill/wrap, FSM transitions, and grant logic across burst/idle transitions.",Grant Acknowledge and Progression,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
stress_burst_priority_update_with_bursting_requests,Apply bursty request patterns (alternating long and short bursts of req) while simultaneously issuing bursts of priority updates to random requestors. Stress the system's ability to handle clustered configuration changes and request bursts without loss of arbitration correctness or throughput degradation.,"1) Apply clk and rst as per spec (see 10.3).
2) For 5,000 cycles:
   a) Alternate between 100-cycle bursts of req[N-1:0]=all 1s and 50-cycle idle (req=0).
   b) During each 100-cycle burst, issue 10 consecutive cycles where prio_upt=1, prio_id is a random requestor, prio is a random value (0..15), then 90 cycles with prio_upt=0.
   c) ack=1 during all active request cycles.
   d) Use fixed random seed (e.g., seed=99) for reproducibility.
3) Observe gnt_w/gnt_id and record grant distribution and arbitration latency.","1) No protocol violations or out-of-bounds priority register accesses.
2) No deadlock: gnt_w/gnt_id must change at least once every 2 cycles during active bursts.
3) Grant distribution adapts to priority updates within the burst window.
4) No drops: Every ack=1 must correspond to a valid grant.
5) System resumes correct arbitration after idle periods.","Functional:
  - cp_burst_len: bins for long (100 cycles) and short (10 cycles) bursts.
  - cp_prio_update_burst: bins for consecutive priority updates.
  - cp_idle_gap: bins for idle periods.
Cross:
  - cross_burst_len_x_prio_update: burst length × number of priority updates.
  - cross_idle_gap_x_recovery: idle gap × time to resume correct arbitration.
Code:
  - Coverage of arbitration logic under clustered priority updates and bursty requests.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 13)]"
stress_long_run_priority_update_and_counter_wrap,"Run the system for an extended duration with continuous requests and periodic priority updates to stress-test for long-run stability, counter wrap-around, and correct handling of priority changes over time. Observe for any degradation, deadlock, or protocol errors over time.","1) Apply clk and rst as per spec.
2) For 1,000,000 cycles:
   a) req[N-1:0]=all 1s every cycle.
   b) Every 1000 cycles, issue a priority update (prio_upt=1) to prio_id=(cycle/1000)%N, prio=(cycle/1000)%16; prio_upt=0 otherwise.
   c) ack=1 every cycle.
3) Observe gnt_w/gnt_id, track grant counts per requestor, and monitor for any stalls or protocol errors.","1) No protocol violations or out-of-bounds accesses.
2) No deadlock: gnt_w/gnt_id must change at least once every 2 cycles.
3) Grant counts per requestor remain proportional to their (current) priority over time.
4) No drops or missed grants.
5) No system hang or degradation over the full run.","Functional:
  - cp_long_run: bins for 10k, 100k, 1M cycles.
  - cp_prio_update_period: bins for periodic updates (every 1k cycles).
  - cp_counter_wrap: bins for grant counters wrapping (if observable).
Cross:
  - cross_long_run_x_prio_update: duration × update frequency.
Code:
  - Coverage of all arbitration and update logic over long duration.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 13)]"
stress_long_duration_zero_starvation_fairness_and_wraparound_all_requestors,"Long-duration, sustained-load stress test: All N=32 requestors assert requests continuously for an extended period (≫ credit and pointer wrap period), with priorities set to diverse values (e.g., half prio=1, half prio=15). This scenario verifies that every requestor receives at least one grant per full round (zero-starvation), that grant ratios match weights over time (fairness), and that credit counters and the round-robin pointer wrap around correctly without overflow or deadlock. Measures per-requestor grant frequency, latency, and system throughput under maximum load, and validates correct operation of sequential update pipeline and protocol adherence.","1) Apply clk and rst; initialize as per spec (priority registers cleared or set, credits initialized, pointer reset).
2) Set prio[N-1:0] such that half of requestors have prio=1, half have prio=15 (or other diverse values as needed).
3) For T_STRESS=1,000,000 cycles (or sufficiently long to ensure multiple credit/pointer wraps):
   - Drive req[N-1:0]=all 1s (all requestors active).
   - ack=1 every cycle (all grants accepted immediately).
   - No dynamic priority updates (prio_upt=0).
4) Observe gnt_w, gnt_id, and (if accessible) monitor internal credit and pointer values.
5) Log all grants per requestor for the entire duration and analyze grant counts, latency, and protocol correctness.","1) Every requestor with prio>0 receives at least one grant within N×(max_weight+1) cycles (zero-starvation guarantee).
2) Grant counts for prio=15 requestors are ~15x those for prio=1 (within tolerance; fairness).
3) No protocol violations: gnt_w/gnt_id always legal, only one grant per cycle, no grant repeated for same requestor without ack.
4) No deadlock, hang, or protocol violation at any time.
5) Credit counters and pointer wrap correctly (no overflow or stuck values).
6) System throughput: average grants per cycle ≥ 1; latency between consecutive grants to any requestor ≤ (N × max_weight) cycles.","Functional:
  - cp_grant_per_requestor: bins {all_requestors}.
  - cp_grant_interval: bins for min, median, max interval between grants per requestor.
  - cp_weight: bins {1,15} (or other priority values).
  - cp_duration: bins {short, medium, long}.
  - cp_credit_wrap: bins {no_wrap, single_wrap, multi_wrap}.
  - cp_pointer_wrap: bins {no_wrap, multi_wrap}.
  - cp_starvation: bins {starved, not_starved}.
  - cp_grant_ratio: bins for observed grant ratios.
Cross:
  - cross_priority_x_grant_interval: priority value × grant interval.
  - cross_weight_x_starvation: cp_weight × cp_starvation.
  - cross_grant_per_requestor_x_duration: cp_grant_per_requestor × cp_duration.
  - cross_credit_wrap_x_latency: cp_credit_wrap × cp_latency.
Code:
  - Coverage of pointer wrap-around, credit counter wrap, sequential update logic, and all FSM transitions under long-run sustained load.",Grant Acknowledge and Progression,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 16)]"
stress_credit_counter_wraparound_and_scaling_long_run_stability,"Stress the credit-based scheduling and replenishment logic for duration effects, counter wraparound, and resource scaling. All requestors (N=32) are active for an extended run (≫ normal test duration), with priorities set to maximum (prio=15). The scenario drives the system to exhaust and refill credits for all requestors at maximum CREDIT_W (8 bits), monitoring for correct wrap-around, no overflow, and correct operation under sustained load. Verifies that credit counters never overflow, refill correctly, and the system remains stable with no deadlock or protocol errors over long duration and at full scaling.","1) Apply clk and rst; deassert rst after 2 cycles.
2) Set all prio[i]=15 (maximum allowed) for all requestors via prio_upt, prio_id, prio (one per cycle for 32 cycles if required).
3) For T_STRESS=1,000,000 cycles, drive req[31:0]=all 1s (all requestors always requesting).
4) For each grant, assert ack=1 in the next cycle.
5) No prio_upt activity during this phase.
6) Continue for at least 2×(max_credit) cycles to ensure at least one full wrap/refill per requestor.
7) Monitor and log credit counters, exhaustion, refill events, and grant behavior for all requestors.","1) Credit counters never exceed 8-bit width (≤255); no overflow or negative values.
2) Each credit counter decrements on grant, refills to prio+1 (16) when exhausted, and cycles correctly.
3) No grant is issued to a requestor with credit=0.
4) No deadlock: at least one grant per cycle; all requestors receive grants in WRR order.
5) No protocol violations; latency remains within 1-2 cycles.
6) All requestors receive at least max_credit grants before refill.
7) System remains responsive for full duration (no hang or starvation).","Functional:
  - cp_credit_value: bins {0, 1, 8, 16, 255} (across cycles and requestors).
  - cp_duration: bins {short, medium, long} (run length).
  - cp_grant: bins {per requestor, per cycle}.
  - cp_refill_event: cover at least one refill per requestor.
Cross:
  - cross_credit_value_x_duration: cp_credit_value × cp_duration.
  - cross_credit_x_grant: credit_val × grant_latency.
Code:
  - Coverage over credit decrement/refill logic, WRR pointer, and FSM transitions under long-run stress and full scaling.",Credit-Based Scheduling and Replenishment Policy,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
stress_credit_based_weighted_round_robin_max_throughput_and_fairness,"This scenario stresses the credit-based weighted round robin (WRR) arbitration logic under maximum sustained throughput, verifying fairness, proportional grant distribution, starvation prevention, and correct credit handling. All N=32 requestors issue continuous requests (req[N-1:0]=all 1s) for a long duration, with priorities (weights) set to cover a wide range (e.g., min, mid, max values). The scenario measures per-requestor grant frequency, latency, and ensures that each requestor's credit counter is decremented on grant and replenished to prio+1 when exhausted. Optionally, priorities may be updated mid-run to test dynamic adaptation. The test ensures that the grant pattern matches the expected WRR distribution, no requestor is starved, and arbitration latency is within spec.","1) Apply clk and rst; hold rst high for at least 2 cycles, then deassert. Initialize priority registers and credits per spec (e.g., credits=1, pointer=0).
2) For all requestors (N=32), set prio[N-1:0] to a range of legal values (e.g., prio[0]=1, prio[1]=8, prio[2]=4, prio[3]=15, others=2) to cover min, mid, max weights.
3) For T_STRESS=10,000 cycles, drive req[N-1:0]=all 1s every cycle (all requestors continuously request).
4) For each grant (gnt_w, gnt_id), assert ack=1 in the next cycle (immediate acceptance, no artificial backpressure).
5) Optionally, update priorities mid-run for a subset of requestors using prio, prio_id, prio_upt to test dynamic weight adaptation.
6) No prio_upt activity during static phase; enable for dynamic phase if desired.
7) Record grant history per requestor for throughput, latency, and fairness analysis.","1) For each requestor, count number of grants over T_STRESS; verify grant ratio ≈ (prio[i]+1)/sum(prio[j]+1) within tolerance.
2) For each grant, ensure credit is decremented; when credit reaches 0, verify it is replenished to prio+1 on next eligible cycle.
3) No requestor is starved: every requestor with nonzero priority receives at least one grant per full WRR cycle.
4) Latency from request to grant is ≤ 2 cycles (per spec: 1 cycle normal, 2 cycles on refill).
5) Verify that only one grant is active per cycle (gnt_w one-hot, gnt_id matches gnt_w).
6) No protocol violations: all handshakes legal, no dropped or duplicated grants.","Functional:
  - cp_weight: bins for priority values {0,1,2,4,8,15}.
  - cp_credit: bins {full, mid, 1, 0 (replenish)}.
  - cp_latency: bins {1,2} cycles.
  - cp_grant_ratio: bins for expected WRR ratios.
  - cp_starvation: bins {starved, not_starved}.
Cross:
  - cross_weight_x_latency: cp_weight × cp_latency.
  - cross_credit_x_grant: cp_credit × grant occurrence.
Code:
  - Coverage over credit decrement, refill, pointer advancement, and grant logic under sustained load.",Credit-Based Scheduling and Replenishment Policy,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 16)]"
stress_simultaneous_priority_update_and_ack_sustained_concurrency,"Exercise the WRR arbiter under sustained, high-concurrency conditions where priority updates (prio_upt) and grant acknowledgments (ack) are asserted simultaneously and repeatedly for long durations. The scenario stresses the pipeline's ability to process both operations in the same cycle without hazards or race conditions, verifying correct grant and priority update behavior under maximal legal load.","1) Apply clk and rst; wait for reset deassertion (rst=0).
2) For at least 10,000 cycles:
   a) On every cycle, assert req[N-1:0] such that at least half of the requestors are active (randomized pattern, fixed seed for repeatability).
   b) On every cycle, assert ack=1 (grant always accepted).
   c) On every cycle, assert prio_upt=1, with prio_id cycling through all requestors (0 to N-1) and prio set to a legal value (e.g., alternate between min and max priority).
   d) Ensure prio, prio_id, and prio_upt are driven per port width and legal values.
3) Continue for a duration sufficient to wrap credit counters and exercise all requestors multiple times.
4) Record gnt_w and gnt_id on every cycle for analysis.","1) No protocol violations: prio updates and grant acks are processed without hazard (no missed or duplicated updates, no lost grants).
2) For each requestor, verify:
   - Priority register reflects the most recent legal update.
   - Grant is issued and acknowledged as expected (no starvation, no deadlock).
3) Throughput: At least one grant per cycle (unless all credits exhausted and refill in progress).
4) Latency: Grant-to-ack and prio_upt-to-prio_reg-update latency within spec (1-2 cycles per Section 12.2).
5) No deadlock or livelock: All requestors make forward progress.
6) No credit or pointer corruption (as observable via grant pattern and priority effect).","Functional:
  - cp_simul_op: bins {prio_upt_only, ack_only, both_simultaneous}.
  - cp_prio_val: bins {min, mid, max} for prio values.
  - cp_req_density: bins {low, medium, high} for number of active req.
  - cp_grant_dist: bins for each requestor (all must be granted).
Cross:
  - cross_simul_op_x_prio_val: cp_simul_op × cp_prio_val.
  - cross_req_density_x_grant_dist: cp_req_density × cp_grant_dist.
Code:
  - Cover all pipeline stages and FSM transitions under simultaneous op.
  - Cover all requestors for prio update and grant in same cycle.",Hazard-Free Simultaneous Priority Update and Grant Acknowledge,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 21)]"
stress_dynamic_priority_update_under_full_load_and_burst_updates,"Exercise the system under sustained, full-load conditions with all requestors active, while dynamically updating priorities (prio/prio_id/prio_upt) at random intervals and in bursts, including simultaneous ack and prio_upt. This stresses the arbitration pipeline, credit refill, grant output, and FSM logic under rapid and concurrent configuration changes. The scenario verifies that priority updates are accepted and reflected in grant distribution, that no protocol violations or deadlocks occur, and that arbitration latency and throughput remain within specification. Measures system response, grant redistribution, and ensures zero-starvation and hazard-free operation during rapid reconfiguration.","1) Apply clk and rst; deassert rst after initialization (hold rst high for 1-2 cycles as per spec).
2) Initialize all prio[N-1:0]=2.
3) For T_STRESS=10,000 cycles:
   - Drive req[N-1:0]=all 1s (all requestors continuously requesting).
   - Drive ack=1 every cycle (no backpressure).
   - At random intervals (every 5–200 cycles, seed=42 for reproducibility), assert prio_upt=1 for 1 cycle, set prio_id to a random requestor, prio to a random value in [0,15].
   - Every 100 cycles, issue a burst of priority updates: for 8 random requestors, set prio to 8 (high weight); for another 8, set prio to 1 (low weight).
   - Sometimes overlap prio_upt with ack=1 (to stress pipeline and hazard-free update logic).
4) Log all grants, priority updates, and credit behavior for all requestors.
5) Continue for sufficient cycles to ensure all requestors receive multiple grants and all priority values are exercised.","1) No protocol violations: prio/prio_id/prio_upt only update one requestor per cycle; no out-of-bounds accesses; gnt_w is one-hot and gnt_id matches the granted index.
2) Grant is never repeated for the same requestor without ack, even as priorities change.
3) Grant distribution adapts to updated priorities: requestors with higher priority receive proportionally more grants; after each priority update or burst, verify grant redistribution within a bounded number of cycles (≤ credit refill period).
4) No requestor with nonzero priority is starved; all requestors eventually receive grants (zero-starvation guarantee).
5) Credits are updated correctly after priority changes (refilled to prio+1 when exhausted).
6) Arbitration latency remains within spec (1 cycle normal, 2 cycles on credit refill); no deadlock or pipeline stall after priority updates.
7) No hazard or glitch in grant outputs during/after priority updates; all grants are consistent and acknowledged.","Functional:
  - cp_prio_update: bins {no update, single, burst, frequent, infrequent, overlap_ack}.
  - cp_weight: bins {0..15} (all priority values exercised).
  - cp_grant_distribution: bins for grant count per requestor before/after update.
  - cp_latency: bins {1,2}.
  - cp_fsm_state: bins {ARBITRATION, REPLENISH}.
  - cp_credit_refill: bins {refill after prio update, refill with no update}.
  - cp_grant_consistency: bins {consistent, inconsistent}.
Cross:
  - cross_prio_update_x_weight: cp_prio_update × cp_weight.
  - cross_prio_update_x_latency: cp_prio_update × cp_latency.
  - cross_update_x_grant: cp_prio_update × cp_grant_distribution.
  - cross_requestor_id_x_priority_value: cp_prio_id × cp_weight.
Code:
  - Coverage of priority update datapath, arbitration logic, FSM transitions, grant output, and credit update logic under dynamic and bursty configuration changes.",Credit-Based Scheduling and Replenishment Policy,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
glitchy_and_async_reset_robustness,"Apply both glitchy (short, toggling, or non-monotonic) and asynchronous reset pulses to the synchronous reset input (rst) to simulate timing violations, metastability, or asynchronous assertion. Expect that the IP does not partially initialize state, enter an undefined state, or show output glitches; either a full reset is performed on a legal synchronous reset or the reset is ignored as per synchronous reset design. No asynchronous state corruption or output glitches should occur, and proper synchronous reset must always recover the module to a known state.","1) Apply clk; drive rst=1 for less than one full clk period (e.g., assert and deassert rst between clk edges) to simulate a glitchy reset.
2) During this glitch, drive req, prio, prio_id, prio_upt, ack to random or toggling values.
3) After the glitch, drive rst=0 for several cycles and observe outputs.
4) Apply clk with nominal frequency; hold rst=0 for several cycles to allow normal operation.
5) During clk=0 (falling edge or mid-cycle), assert rst=1 for one half-cycle (not aligned to clk edge) to simulate asynchronous assertion.
6) Observe outputs (gnt_w, gnt_id) and internal state for any glitches or asynchronous changes.
7) Afterward, re-assert rst=1 aligned with clk rising edge for >=1 cycle, then deassert to 0 to perform a legal synchronous reset.
8) Resume normal operation and confirm recovery.","1) No partial or undefined state: outputs (gnt_w, gnt_id) must not show illegal or spurious values after glitchy or asynchronous reset.
2) If reset is not sampled on clk edge, state must remain unchanged (no partial init or async corruption).
3) No output glitches or illegal transitions during asynchronous rst assertion.
4) After a proper synchronous reset, state must be fully initialized per spec.
5) Module resumes normal arbitration with no deadlock or hang.","Functional:
  - cp_reset_glitch: bins {short_pulse, toggling, non-monotonic}.
  - cp_err_type: bins {async_reset_violation}.
  - cp_state_after_glitch: bins {unchanged, illegal, partial_init}.
  - cp_detector: bins {output_glitch, state_corruption, safe_ignore}.
  - cp_full_reset_recovery: bins {ok, fail} after proper reset.
  - cp_recovery: bins {legal_sync_reset, normal_resume}.
Cross:
  - cross_reset_glitch_x_state_after_glitch: cp_reset_glitch × cp_state_after_glitch.
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Synchronous Reset and State Initialization,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13)]"
error_reset_during_active_grant_and_credit_update,"Assert rst during an active grant and/or credit update (i.e., while gnt_w is nonzero and ack/prio_upt are asserted). Expect all outputs and internal state to be reset to known values, with no illegal or inconsistent outputs after reset is deasserted.","1) Apply clk and rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive requests and priorities to reach a state where a grant is active (gnt_w nonzero, gnt_id valid), and optionally ack=1 and/or prio_upt=1 in the same cycle.
3) While these are active, assert rst=1 for at least 2 cycles.
4) After deasserting rst=0, observe outputs for correct reset behavior (gnt_w=0, gnt_id=0, credits/priorities re-initialized).
5) Resume normal operation to confirm recovery.","1) During rst=1, all outputs must be reset as per spec (gnt_w=0, gnt_id=0, credits/priorities cleared or initialized).
2) After rst=0, arbitration resumes from known state; no illegal outputs or deadlock.
3) No spurious grants or credit corruption after reset.","Functional:
  - cp_err_type: bins {reset_during_active}.
  - cp_detector: bins {output_reset, state_reset}.
  - cp_recovery: bins {post_reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Grant Output and Credit Update Consistency,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 17)]"
negative_reset_during_active_arbitration_and_grant,"Assert rst during an active arbitration cycle, including cases where requests are pending, grants are being issued, credits are being decremented, or ack is active. This simulates an asynchronous or synchronous reset event during operation. Expectation: The arbiter must immediately reset all internal state (credits, priorities, pointer), deassert all grants, and after rst=0, resume arbitration from a known state with no residual or partial state from before the reset. After deasserting rst, arbitration must resume correctly, meeting the latency envelope for new requests, and no spurious or duplicate grants should be observed.","1) Apply clk and rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter.
2) Drive req[N-1:0] and ack to create active arbitration, including scenarios with multiple requestors, active grants, and credit updates.
3) While arbitration is ongoing (e.g., grant issued, ack=1, or credit being decremented), assert rst=1 for at least 1-2 cycles.
4) Observe that all outputs (gnt_w, gnt_id) and internal state (credits, priorities, pointer) are reset to initial values as per spec.
5) Deassert rst=0 and resume normal operation, driving new req/ack cycles.
6) Confirm that arbitration resumes from a known state, grants are issued within the specified latency envelope, and no spurious or partial grants occur across the reset boundary.","1) All outputs (gnt_w, gnt_id) are immediately deasserted or set to initial values upon rst=1.
2) No grant is issued during reset; no partial or spurious grant is observed.
3) All internal state (credits, priorities, pointer) is re-initialized per spec (credits=1, priorities=0, pointer=0).
4) After rst=0, arbitration resumes correctly, meeting latency requirements for new requests.
5) No residual or inconsistent state persists after reset; no deadlock or hang occurs.","Functional:
  - cp_err_type: bins {reset_during_active, reset_during_active_grant, reset_mid_arbitration}.
  - cp_detector: bins {output_reset, state_reset, output_clear, state_monitor, output_state_during_reset, no_spurious_grant, arbitration_restart}.
  - cp_recovery: bins {post_reset_recovery, reset_sequence, reset_recovery, normal_resume, post_reset_arbitration}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
reset_robustness_with_active_inputs_and_pending_arbitration_negative_recovery_and_starvation_check,"Assert synchronous reset (rst=1) under various challenging conditions: (a) while all request and priority update inputs are active or toggling, (b) in the middle of an active arbitration cycle (grant and ack asserted), and (c) while multiple requests are pending and some requestors have exhausted credits. Deassert reset (rst=0) and verify that all internal state (priority registers, credit counters, pointer) is initialized per spec, any in-flight arbitration is aborted, and outputs reflect reset state. After reset, arbitration must resume cleanly, all requestors must be eligible for grant (no starvation), and normal operation must continue without deadlock or illegal outputs. This scenario stresses reset logic with maximal toggling, illegal input transitions, and pending requests during reset, and checks for correct state initialization and recovery.","1) Apply clk; assert rst=1 for at least 2 cycles.
2) While rst=1, drive req[N-1:0]=all 1s, prio_upt=1, prio_id=all 1s, prio=all 1s, ack=1 (all inputs active/toggling).
3) On a rising clk edge, deassert rst (rst=0) while keeping all inputs active for 1 more cycle.
4) Allow arbitration to proceed for several cycles, driving req[i]=1 for all requestors and exhausting some credits.
5) During an active grant and ack, assert rst=1 again for at least 2 cycles; observe that in-flight arbitration is aborted and outputs reflect reset state.
6) Deassert rst=0; continue asserting req[i]=1 for all requestors.
7) Observe gnt_w and gnt_id for at least N cycles after reset to ensure all requestors are granted and no starvation occurs.
8) Optionally, repeat with different input patterns and timing of reset assertion.","1) On rst=1, all outputs (gnt_w, gnt_id) must be at reset values or held stable per spec.
2) Any in-flight arbitration/grant is aborted; no grant is issued during reset.
3) After rst=0, arbitration must begin: gnt_w and gnt_id must reflect a valid grant per initialized state (credits=1, priorities=0, pointer=0).
4) All requestors are eligible for grant after reset (no starvation); all registers re-initialized per spec.
5) No deadlock: gnt_w and gnt_id continue to change after reset.
6) No spurious or illegal grants must occur due to input toggling or pending requests during reset.
7) Normal operation resumes after reset; no state corruption.","Functional:
  - cp_reset_illegal_inputs: bins {all_inputs_active, toggling, random} during rst=1.
  - cp_reset_during_active: bins {grant, ack, prio_upt active} when rst=1.
  - cp_err_type: bins {reset_during_pending_requests}.
  - cp_post_reset_arbitration: bins {grant_issued, no_grant, illegal_grant} on first cycle after rst=0.
  - cp_state_init: bins {prio=0, credit=1, pointer=0} after reset.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_reset_illegal_inputs_x_post_reset_arbitration: cp_reset_illegal_inputs × cp_post_reset_arbitration.
  - cross_reset_during_active_x_post_reset_recovery: cp_reset_during_active × cp_post_reset_arbitration.
  - cross_err_x_detector: cp_err_type × {grant_monitor, reset_monitor}.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Synchronous Reset and State Initialization,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 13)]"
fsm_negative_reset_and_priority_update_during_replenish_state,"Test the FSM's robustness when reset and/or priority update operations occur during the REPLENISH state (i.e., while credits are being refilled after no eligible requestor). This includes: (1) asserting rst during REPLENISH and confirming all internal state (credits, priorities, pointer, FSM state) is reset as per spec, and that after deasserting rst, the FSM resumes from a known state (ARBITRATION) with correct initial values; (2) attempting to update a requestor's priority (drive prio_upt=1 with prio/prio_id) during REPLENISH, confirming that the FSM either ignores the update or applies it only after refill, and that no grant is issued until refill completes; (3) applying a priority update exactly when credits are being replenished, confirming that the replenished credit value matches the new priority (prio+1) and not the old value, and that no stale or mismatched credit value is used. Arbitration must resume with the correct, updated priorities and credits, and no deadlock or hang should occur.","1) Apply clk and rst=1 for at least 2 cycles, then deassert rst=0.
2) Initialize priorities and credits to legal values (prio/prio_id/prio_upt as needed).
3) Drive req[N-1:0]=1 and ack=1 to exhaust all credits and trigger REPLENISH (no eligible requestor).
4) On the cycle where REPLENISH is active (no grant issued, credits about to be refilled):
   a) Assert rst=1 for at least 2 cycles, then deassert rst=0 and observe outputs.
   b) Alternatively, drive prio_upt=1 with prio_id and prio set to a new value, and observe whether the update is ignored or applied after refill.
   c) For a specific requestor, on the exact cycle when credits are being replenished, assert prio_upt=1, prio_id, and prio to update the priority, and observe the replenished credit value.
5) After each operation, resume normal operation by driving req and ack as in a legal scenario and observe arbitration and grant behavior.","1) Upon rst=1, all outputs (gnt_w, gnt_id) are reset to zero; internal state (credits, priorities, pointer) is reset as per spec (credits=1, priorities=0, pointer=0).
2) FSM state returns to ARBITRATION after rst is deasserted.
3) No grant is issued during REPLENISH, even with prio_upt=1.
4) Priority update is either ignored or applied only after refill (per spec behavior).
5) After refill, arbitration resumes and grants reflect the updated priority.
6) For simultaneous priority update and credit refill, the replenished credit value matches the new priority (prio+1), not the old value.
7) No stale or old priority value is used for credit refill.
8) No deadlock or hang occurs; FSM transitions as per spec; arbitration resumes correctly.","Functional:
  - cp_fsm_state: bins {arbitration, replenish, reset}.
  - cp_reset_during_fault: bins {reset_in_replenish}.
  - cp_prio_update: bins {update_in_replenish, update_in_arbitration}.
  - cp_err_type: bins {priority_update_during_replenish}.
  - cp_detector: bins {credit_refill_value, grant_behavior}.
  - cp_recovery: bins {reset_then_arbitration, update_applied, update_ignored, normal_arbitration_resume}.
Cross:
  - cross_reset_x_state: cp_reset_during_fault × cp_fsm_state.
  - cross_prio_update_x_state: cp_prio_update × cp_fsm_state.
  - cross_err_x_detector: cp_err_type × cp_detector.",Global Arbitration FSM State Machine Operation,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10)]"
negative_pointer_nonobservable_after_reset,"After reset, the round-robin pointer must be initialized to 0. Intentionally issue requests from multiple requestors and observe if the grant sequence starts from requestor 0. If grant does not start from 0, this is a negative case for pointer state observability via outputs.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0.
2) Assert req[0]=1, req[1]=1, req[2]=1 (all others 0), ack=0.
3) Observe gnt_w and gnt_id for the first arbitration cycle after reset.
4) After test, reset the system again and confirm outputs return to default.","1) After reset, first grant must be to requestor 0 (gnt_w[0]=1, gnt_id=0).
2) If grant is not to requestor 0, flag as error.
3) After reset, outputs must return to default (no grant).
4) No deadlock or hang occurs during or after the scenario.","Functional:
  - cp_err_type: bins {pointer_reset_not_observable}.
  - cp_detector: bins {gnt_w, gnt_id}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Internal State Observability for Debug and QoS,"[('weighted_round_robin_mas.pdf', 10)]"
negative_priority_update_during_reset_or_without_strobe,"Verify that the priority update interface does not alter internal state when either (a) a priority update (prio_upt=1) is attempted during active reset (rst=1), or (b) prio and prio_id are driven without asserting the update strobe (prio_upt=0). In both cases, the IP must ignore the update and maintain all registers in their reset or previous state, with no effect on arbitration or internal state. After reset or after a legal update, arbitration and updates must work as expected.","1) Apply clk and assert rst=1.
2) While rst=1, drive prio_upt=1, prio_id=<any>, prio=<any> for one or more cycles (test update during reset).
3) Deassert rst=0 to exit reset.
4) Drive legal req and ack patterns and observe arbitration.
5) On a rising clk edge, drive prio=<new value>, prio_id=<valid ID>, but keep prio_upt=0 for several cycles (test update without strobe).
6) Observe gnt_w and gnt_id for any change in arbitration.
7) Optionally, perform a legal priority update (with prio_upt=1) and confirm arbitration changes accordingly.","1) No priority update should occur while rst=1 or when prio_upt=0; all registers must remain at reset or previous values.
2) After reset, arbitration must start from the initialized state (priorities=0, credits=1, pointer=0).
3) Arbitration remains unchanged without strobe.
4) After a legal update (with strobe and not in reset), arbitration reflects the new priority.
5) No hang or corruption after reset or after ignored updates; legal updates work as expected.","Functional:
  - cp_err_type: bins {prio_update_during_reset, missing_strobe}.
  - cp_detector: bins {update_ignored, state_at_reset, no_update, unchanged_state}.
  - cp_recovery: bins {normal_post_reset, legal_update_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 13)]"
negative_priority_update_with_out_of_range_prio_id,"Attempt to update the priority of a requestor using a prio_id value that exceeds the legal range (i.e., prio_id >= N, where N=32). This includes cases where prio_id is not mapped to any requestor or is outside the legal ID range. Expect the arbiter to ignore the update, with no out-of-bounds write, no state corruption, no grant corruption, and no deadlock. Arbitration for legal requestors must continue unaffected, and normal operation must resume after a legal priority update or reset.","1) Apply clk and rst; assert rst for at least one cycle (optionally >=2 cycles), then deassert to initialize the arbiter.
2) Drive req with a valid pattern (e.g., one-hot or multiple active requestors such as req=1010 or req=0001).
3) Assert prio_upt=1, prio_id=<illegal value> (e.g., prio_id=32 for N=32), and prio=<any legal value> for one cycle.
4) Observe gnt_w and gnt_id for any abnormal grant behavior for several cycles after the event.
5) After the illegal update, perform a legal priority update to a valid requestor to confirm recovery.
6) Optionally, assert rst to confirm reset recovery and return to a known state.","1) No grant is issued to an out-of-range requestor (gnt_w/gnt_id never indicate illegal ID).
2) No state corruption or out-of-bounds write occurs (as observable via outputs).
3) Arbitration for legal requestors continues normally; no deadlock or stall.
4) Priority update with invalid prio_id is ignored, and subsequent grants are unaffected.
5) Legal priority updates after the fault are accepted and reflected in arbitration.
6) After reset, outputs return to initial state per spec.","Functional:
  - cp_err_type: bins {illegal_prio_id, out_of_range_prio_id, invalid_prio_id}.
  - cp_detector: bins {grant_output, arbitration_continuity, ignore_update, no_state_change}.
  - cp_recovery: bins {legal_update, legal_update_after_fault, reset, reset_recovery, legal_update_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_illegal_priority_update_out_of_range_combined,"Attempt to update a requestor's priority register with a value exceeding the legal range defined by PRIORITY_W (e.g., drive prio input with a value > 2^PRIORITY_W-1, such as 5'b10000 for PRIORITY_W=4). Expect the arbiter/IP to detect and contain the illegal value, either by ignoring or clamping it, with no corruption of internal state or grant behavior. No grant should be issued based on the illegal value, arbitration must not hang or deadlock, and the system must remain operational. After the illegal update, performing a legal priority update or reset must restore normal operation.","1) Apply clk and rst; assert rst for at least one cycle (or 2 cycles), then deassert to initialize the arbiter.
2) Drive req with a valid request pattern (e.g., one-hot or multi-hot, such as req=4'b0011), and ack=0.
3) Attempt to update the priority of a requestor by asserting prio_upt=1, prio_id=<valid>, and prio=<illegal value> (e.g., prio=2^PRIORITY_W or 5'b10000 for PRIORITY_W=4).
4) Hold prio_upt=1 for one cycle, then deassert.
5) Observe gnt_w, gnt_id, and grant behavior for any abnormality or corruption.
6) After the illegal update, perform a legal priority update to the same requestor to confirm recovery.
7) Optionally, assert rst again to confirm proper reset recovery.","1) No grant is issued based on the illegal priority value (gnt_w/gnt_id remain consistent with legal operation).
2) Arbitration must not hang or deadlock; other requestors must still be serviced per their legal priorities.
3) Internal state (as observable via outputs) is not corrupted; subsequent legal updates behave as expected.
4) If the spec defines error containment (e.g., ignore update, clamp to max, or reset), check that behavior.
5) After reset or legal priority update, arbitration must proceed normally.","Functional:
  - cp_err_type: bins {illegal_priority_value, out_of_range_prio}.
  - cp_detector: bins {grant_output, arbitration_continuity, no_grant, ignore_update, clamp_max, prio_reg_monitor}.
  - cp_recovery: bins {legal_update, reset, legal_update_resumes}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_priority_update_with_reserved_priority_value,"Apply a priority update with prio set to a reserved or illegal value (e.g., all 1s if not allowed, or a value above the maximum allowed by PRIORITY_W). Expect the arbiter to ignore the update or clamp it to the maximum allowed value, with no grant corruption or deadlock. Arbitration must proceed without interruption.","1) Apply clk and rst; hold rst=1 for >=2 cycles, then deassert rst=0.
2) Drive req with multiple active requestors (e.g., req=1100) and allow normal arbitration for a few cycles.
3) Pulse prio_upt=1 for one clk cycle, with prio set to a reserved or illegal value (e.g., prio=0xF when only 0x0-0xE are legal).
4) Observe outputs for several cycles after the event.
5) Optionally, perform a legal priority update to confirm normal operation.
6) Optionally, assert rst to return to a known state.","1) No deadlock or stall: gnt_w and gnt_id continue to update each cycle per req inputs.
2) No grant corruption: gnt_w/gnt_id never reflect an illegal or out-of-range value.
3) No effect on arbitration: priority update with reserved value is ignored or clamped, and subsequent grants are unaffected.
4) Legal priority updates after the fault are accepted and reflected in arbitration.
5) After rst, all outputs return to initial state as per spec.","Functional:
  - cp_err_type: bins {reserved_priority_value}.
  - cp_detector: bins {grant_output, arbitration_continuity}.
  - cp_recovery: bins {legal_update_after_fault, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Runtime Priority Update Without Arbitration Interference,"[('weighted_round_robin_mas.pdf', 4)]"
negative_credit_counter_overflow_by_illegal_update,"Attempt to update a requestor's priority to a value that would cause its credit counter to overflow CREDIT_W (e.g., prio input set so prio+1 > 255, since CREDIT_W=8). Expect the arbiter to clamp the credit value or ignore the update, with no overflow or state corruption. Arbitration must remain correct and deadlock-free.","1) Apply clk and rst; assert rst for at least one cycle, then deassert to initialize the arbiter.
2) Drive req for a requestor.
3) Assert prio_upt=1, prio_id=<valid>, prio=<value causing prio+1 > 255> (since CREDIT_W=8).
4) Observe gnt_w and gnt_id for any abnormal grant behavior.
5) After the illegal update, perform a legal priority update to confirm recovery.
6) Optionally, assert rst to confirm reset recovery.","1) No credit counter overflow occurs (as observable via grant behavior and absence of deadlock).
2) No grant is issued based on an overflowed credit value.
3) Arbitration remains correct; system recovers with legal update or reset.","Functional:
  - cp_err_type: bins {credit_overflow}.
  - cp_detector: bins {grant_output, arbitration_continuity}.
  - cp_recovery: bins {legal_update, reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_priority_update_with_simultaneous_ack_and_multiple_updates,"Attempt to perform multiple priority updates (prio_upt=1 with different prio_id/prio values) in the same cycle as an ack=1 (grant accepted). If spec only allows one update per cycle, expect only one update to be applied and no arbitration corruption. If multiple updates are allowed, expect correct handling per spec.","1) Apply clk and assert rst=1 for at least one cycle, then deassert rst=0 to initialize.
2) Drive legal req and ack patterns.
3) On a rising clk edge, drive ack=1 and simultaneously drive prio_upt=1 with prio_id/prio changing within the same cycle (if possible via bench scheduling).
4) Observe gnt_w and gnt_id for arbitration correctness.
5) Optionally, perform a single legal update and confirm normal operation.","1) Only one priority update is applied per cycle (if spec requires), or all are handled correctly if multiple allowed.
2) Arbitration is not corrupted; no hang or deadlock.
3) Afterward, legal updates and arbitration proceed normally.","Functional:
  - cp_err_type: bins {multi_update_same_cycle}.
  - cp_detector: bins {single_update, correct_multi_update}.
  - cp_recovery: bins {normal_post_update}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 13)]"
negative_priority_update_during_arbitration_cycle_glitch,"Inject a malformed or glitchy priority update (prio_upt pulse with unstable prio/prio_id values) during an active arbitration cycle. Expect the arbiter to ignore or safely contain the update, with no stalling, deadlock, or grant corruption. No grant output (gnt_w/gnt_id) should be corrupted, and arbitration must proceed without interruption.","1) Apply clk and rst; hold rst=1 for >=2 cycles, then deassert rst=0.
2) Drive req with multiple active requestors (e.g., req=0110) and allow normal arbitration for a few cycles.
3) During an active arbitration cycle (when gnt_w is asserted), pulse prio_upt=1 for one clk cycle, but simultaneously toggle prio and prio_id inputs mid-cycle (simulate a glitch or unstable update).
4) Observe outputs for several cycles after the event.
5) Optionally, perform a legal priority update after the fault to confirm recovery.
6) Optionally, assert rst to return to a known state.","1) No deadlock or stall: gnt_w and gnt_id continue to update each cycle per req inputs.
2) No grant corruption: gnt_w/gnt_id never reflect an illegal or out-of-range value.
3) No arbitration interruption: grants are issued every cycle as per normal operation.
4) If legal priority update is performed after the glitch, it is accepted and reflected in subsequent arbitration.
5) After rst, all outputs return to initial state as per spec.","Functional:
  - cp_err_type: bins {glitchy_priority_update}.
  - cp_detector: bins {grant_output, arbitration_continuity}.
  - cp_recovery: bins {legal_update_after_fault, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Runtime Priority Update Without Arbitration Interference,"[('weighted_round_robin_mas.pdf', 4)]"
negative_observability_missing_state_transition_on_priority_update,"Intentionally apply a dynamic priority update (via prio, prio_id, prio_upt) to a requestor while it is not requesting, then immediately issue a request from that requestor. Expect the internal state (as observable via gnt_w/gnt_id) to reflect the new priority in the next arbitration cycle. If the grant does not reflect the updated priority, this indicates a failure in internal state observability or update propagation.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0.
2) Set all req=0. Wait 2 cycles.
3) Issue prio_upt=1, prio_id=X (choose a requestor), prio=MAX (set to highest priority), for one clk cycle; then deassert prio_upt.
4) Wait 1 cycle, then assert req[X]=1 (all other req=0).
5) Observe gnt_w and gnt_id for at least 2 cycles.
6) After test, reset the system (rst=1 for 2 cycles) and confirm outputs return to default.","1) After prio update and request, gnt_w and gnt_id must reflect a grant to requestor X in the next arbitration cycle.
2) If grant does not occur, or if grant is given to another requestor, flag as error.
3) After reset, gnt_w and gnt_id must return to default (no grant).
4) No deadlock or hang occurs during or after the scenario.","Functional:
  - cp_err_type: bins {priority_update_not_observable}.
  - cp_detector: bins {gnt_w, gnt_id}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Internal State Observability for Debug and QoS,"[('weighted_round_robin_mas.pdf', 10)]"
negative_credit_refill_latency_violation,"Force the arbiter into a credit refill condition by holding all credits at zero (by repeated grants and a lack of priority update), then immediately assert new requests before the sequential update stage can complete. Expect the arbiter to enforce the documented 2-cycle latency for credit refill and not issue a grant until credits are properly refilled.","1) Apply clk and rst; initialize as per spec (rst=1, then rst=0).
2) Drive req[N-1:0] such that all requestors are granted in sequence, depleting their credits to zero (simulate by repeatedly asserting req and ack for each requestor).
3) Once all credits are zero, assert req[N-1:0] for all requestors in the same cycle, before the refill completes.
4) Observe gnt_w and gnt_id: no grant should be issued until after the 2-cycle refill latency.
5) After refill, confirm that grants resume as per the new credits.
6) Optionally, assert rst to confirm recovery.","1) No grant (gnt_w, gnt_id) is issued during the refill latency (2 cycles after all credits are zero).
2) After refill, grants resume and credits are correctly replenished from prio+1.
3) No deadlock or spurious grant occurs during the refill window.
4) After reset, all state returns to initial values.","Functional:
  - cp_err_type: bins {credit_refill_latency_violation}.
  - cp_detector: bins {grant_output, refill_block}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 12)]"
negative_arbitration_latency_exceeds_envelope_no_grant_within_2_cycles,"Intentionally create a scenario where, after all credits are exhausted and a refill is triggered, the arbiter fails to produce a grant within the specified 2-cycle latency envelope. Expect the absence of grant outputs (gnt_w, gnt_id) for more than 2 cycles, violating the latency guarantee. The test checks for error containment (no deadlock), and that the arbiter resumes correct operation after recovery/reset.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter.
2) Drive req such that all requestors are active and credits are exhausted in a controlled manner (e.g., repeatedly grant and ack until all credits reach zero).
3) After entering the credit refill state (no eligible requestors), intentionally hold req active but do NOT acknowledge any grant for more than 2 cycles, simulating a stuck or delayed refill.
4) Observe that gnt_w and gnt_id remain zero for more than 2 cycles (no grant issued).
5) After the fault window, perform a legal reset (rst=1, then rst=0) to recover.
6) Resume normal operation and confirm grants are issued within the correct latency envelope.","1) Monitor gnt_w and gnt_id: If no grant is issued for more than 2 cycles after a refill is triggered, flag a latency violation.
2) Ensure that after reset, the arbiter resumes normal operation and grants are produced within 1-2 cycles as per spec.
3) Check that no deadlock or hang occurs: the arbiter must recover and continue granting after reset.
4) Confirm that no illegal or spurious grants are issued during the fault window.","Functional:
  - cp_err_type: bins {latency_exceeded}.
  - cp_detector: bins {grant_output_monitor}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Arbitration Latency Envelope and Pipelining,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
negative_premature_ack_handshake_break_arbitration_latency_violation,"Drive ack input high before any grant is issued (i.e., ack asserted with gnt_w and gnt_id both zero), violating the handshake protocol. Expect the arbiter to ignore the ack or handle it gracefully without producing a spurious grant or entering an undefined state. Confirm that arbitration latency guarantees are not violated and that the arbiter recovers to normal operation.","1) Apply clk and rst as per normal startup.
2) Hold req low (no requests active), then assert ack=1 for one or more cycles while gnt_w and gnt_id are zero (no grant issued).
3) Observe arbiter outputs for any spurious grant or protocol violation.
4) After the handshake break, drive a legal request and ack sequence to confirm normal operation resumes.
5) Optionally, perform a reset to ensure full recovery if any error is detected.","1) Confirm that no grant (gnt_w, gnt_id) is issued in response to a premature ack.
2) Ensure the arbiter does not enter a deadlock or undefined state.
3) After the fault, verify that normal arbitration resumes and latency guarantees (1-2 cycles) are met for subsequent legal requests.
4) Check that no spurious or duplicate grants are produced.","Functional:
  - cp_err_type: bins {handshake_break}.
  - cp_detector: bins {grant_output_monitor, state_monitor}.
  - cp_recovery: bins {normal_resume, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Arbitration Latency Envelope and Pipelining,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
negative_no_internal_error_reporting_or_ecc_observable_absence,"Attempt to provoke internal error conditions (e.g., by driving illegal or out-of-range values on input ports, or by violating expected handshakes) and verify that the IP does NOT report any internal error, ECC, or parity error via outputs, status, or dedicated error signals, as per the spec. Confirm that no error reporting or containment is implemented internally, and that the module continues operation or fails silently, requiring external error handling.","1) Apply clk and rst as per nominal operation; deassert rst after at least 8 cycles.
2) Configure all inputs to legal values and confirm normal operation (e.g., drive req, observe gnt_id/gnt_w).
3) Inject negative/faulted stimuli, such as:
   a) Drive prio/prio_id/prio_upt with out-of-range or reserved values (if possible within port width).
   b) Assert req with illegal one-hot patterns (e.g., multiple bits set if only one-hot is expected).
   c) Hold ack low or high for extended periods to simulate handshake abuse.
4) Observe all outputs (gnt_id, gnt_w) for any error indication or abnormal behavior.
5) After fault injection, return all inputs to legal values and optionally assert rst to recover to a known state.","1) No error output, status, or dedicated error signal is asserted (since none exist per spec).
2) No observable change in gnt_id/gnt_w that would indicate error containment or reporting.
3) Module continues operation or fails silently; no deadlock or hang occurs.
4) After reset, module returns to normal operation with no error latching or reporting.","Functional:
  - cp_neg_stimulus: bins {illegal_prio, illegal_prio_id, illegal_req_pattern, handshake_abuse}.
  - cp_error_reporting: bins {none}.
  - cp_post_fault: bins {continues_ok, silent_fail}.
Cross:
  - cross_neg_stimulus_x_error_reporting: cp_neg_stimulus × cp_error_reporting.",No Internal Error Reporting or ECC,"[('weighted_round_robin_mas.pdf', 14)]"
negative_multi_clock_domain_violation,"Drive the clk input with glitches or multiple clock domains (e.g., two different frequencies or spurious pulses), violating the single clock domain requirement. Expect the module to either ignore spurious edges or enter a safe state, with no metastability or undefined output behavior.","1) Start with clk toggling at nominal frequency; rst=1 for >=1 cycle, then rst=0 to begin normal operation.
2) During operation, inject a spurious clk pulse (extra rising edge) or briefly switch clk to a different frequency for a few cycles.
3) Observe outputs (gnt_w, gnt_id) and arbitration behavior for any signs of metastability, glitches, or protocol violation.
4) After fault injection, restore clk to nominal frequency and perform a legal synchronous reset (rst=1 on clk rising edge).
5) Resume normal operation and confirm correct recovery.","1) No output (gnt_w, gnt_id) glitches, metastability, or undefined transitions during clock domain violation.
2) No deadlock or hang; module either ignores spurious clk or enters a safe state.
3) After legal synchronous reset, all state is initialized per spec and normal arbitration resumes.
4) No persistent error or corruption after recovery.","Functional:
  - cp_err_type: bins {multi_clock_violation, clk_glitch}.
  - cp_detector: bins {output_glitch, metastability, safe_ignore}.
  - cp_recovery: bins {legal_sync_reset, normal_resume}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Single Clock and Power Domain Operation,"[('weighted_round_robin_mas.pdf', 12)]"
illegal_req_vector_encoding_and_grant_output_consistency,"Drive the arbiter with illegal 'req' vector encodings, such as multiple bits set (not one-hot) or bits set beyond the valid range (e.g., req[N]=1 when N=32). During this period, manipulate 'ack' to create hazard windows and observe the arbiter's response. The arbiter must ignore illegal requestors, never grant to out-of-range indices, and always maintain consistent grant outputs: 'gnt_w' must be one-hot or zero, and 'gnt_id' must match the asserted bit in 'gnt_w'. Arbitration among legal requestors must continue without deadlock, and the system must recover to normal operation after legal input or reset.","1) Apply clk and rst; assert rst for at least one cycle, then deassert to initialize the arbiter.
2) Wait for a few cycles to ensure normal operation.
3) Drive 'req' with illegal encoding: set multiple bits (multi-hot) and/or bits beyond N-1; manipulate 'ack' to create hazard windows (e.g., hold ack=0 for several cycles, then toggle ack=1 while req remains illegal).
4) Observe 'gnt_w' and 'gnt_id' for any abnormal or inconsistent grant behavior on every cycle.
5) After the illegal stimulus, drive a legal 'req' vector and ack=0 to confirm recovery.
6) Optionally, assert rst again to confirm reset recovery.","1) No grant is issued to out-of-range requestors (gnt_w/gnt_id never indicate illegal index).
2) On every cycle, check that gnt_w is either all zeros or exactly one bit set (one-hot).
3) If gnt_w is nonzero, gnt_id must match the index of the asserted bit in gnt_w.
4) Arbitration among legal requestors continues normally; no deadlock or hang.
5) After legal req vector or reset, system returns to normal, legal operation.","Functional:
  - cp_err_type: bins {illegal_req_encoding, multi_req_inconsistency}.
  - cp_detector: bins {grant_output, arbitration_continuity, gnt_w_onehot_violation, gnt_id_mismatch}.
  - cp_recovery: bins {legal_req, reset, reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Grant Output and Credit Update Consistency,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
negative_multiple_grants_per_cycle_violation,"Intentionally assert multiple bits in the 'gnt_w' output (i.e., simulate a scenario where the arbiter grants more than one requestor in a single cycle, which is illegal per WRR spec). Expect detection of protocol violation (if monitored), or at minimum, observe that such a condition never occurs even under stress or corner-case input patterns.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert to 0.
2) Configure all priorities to legal values (e.g., prio=4 for all).
3) Drive req with multiple bits set (e.g., req=0b1111... for all N requestors) for several cycles, with ack toggling as needed.
4) Observe gnt_w output every cycle for the duration of the test.
5) After stress, assert rst again to confirm recovery to known state.","1) At no time does gnt_w have more than one bit set (one-hot encoding enforced).
2) If multiple bits are ever set, flag error and record cycle.
3) After reset, gnt_w returns to all-zero or valid one-hot state.
4) No deadlock or hang occurs during or after the test.","Functional:
  - cp_err_type: bins {multi_grant}.
  - cp_detector: bins {gnt_w_monitor}.
  - cp_recovery: bins {reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Weighted Round Robin Arbitration and Fairness,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 16)]"
grant_acknowledge_and_request_edge_cases,"This scenario combines two key error/negative cases for arbiter grant progression: (1) Intentionally withholding the 'ack' signal after a grant is issued while keeping the corresponding 'req' bit high, to verify that the arbiter does not advance to the next requestor or repeat the grant without acknowledgment; and (2) Acknowledging a grant (asserting ack=1) while deasserting the corresponding req bit in the same cycle, simulating a protocol violation where the requestor drops its request at the same time as accepting the grant. Expectation: In the first case, the grant remains asserted to the same requestor, no new grants are issued, and no deadlock or illegal grant cycling occurs; after ack is asserted, normal progression resumes. In the second case, the arbiter must not issue a repeated grant to the same requestor, must not deadlock, and must correctly advance to the next eligible requestor or idle if none are present.","1) Apply clk and rst; hold rst=1 for >=2 cycles, then deassert rst=0.
2) Drive req[N-1:0] with a single bit high (e.g., req[3]=1), all others 0.
3) Wait for gnt_w[3]=1 and gnt_id=3 (grant issued).
4a) For the first case: Keep req[3]=1, but do NOT assert ack for several cycles (e.g., 10 cycles). Observe that gnt_w/gnt_id remain unchanged; no new grants are issued. After the hold period, assert ack=1 for one cycle while req[3]=1. Confirm that the arbiter can now progress to the next eligible requestor (if any) or deassert grant if no requests remain.
4b) For the second case: In the next cycle after grant, simultaneously assert ack=1 and deassert req[3]=0. Observe the arbiter's response: check that no further grants are issued to requestor 3, and that the arbiter advances to the next eligible requestor (if any) or deasserts all grants.
5) Optionally, repeat with multiple requestors to confirm correct behavior under both edge cases.","1) gnt_w and gnt_id remain stable (no grant progression) while ack=0 and req held high.
2) No grant is issued to any other requestor until ack=1 in the first case.
3) After ack is asserted, arbiter resumes normal operation and grants progress as per round-robin/weight.
4) No spurious grant toggling or repeated grants without ack.
5) No assertion of illegal outputs or protocol violations on gnt_w/gnt_id.
6) In the second case, no repeated grant to a requestor after req is deasserted and ack=1.
7) Arbiter advances to the next eligible requestor or deasserts all grants if none are present.
8) No deadlock or hang; outputs remain legal.
9) No grant is issued to a requestor that is not requesting.","Functional:
  - cp_err_type: bins {grant_without_ack, ack_with_req_drop}.
  - cp_detector: bins {grant_sticky, no_progress, no_repeat_grant, correct_progression}.
  - cp_recovery: bins {ack_assertion, normal_progression, next_requestor, idle}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Grant Acknowledge and Progression,"[('weighted_round_robin_mas.pdf', 9)]"
simultaneous_ack_and_priority_update_hazard_on_granted_requestor,"Apply a priority update (prio_upt=1) for a requestor in the same cycle as its grant is being acknowledged (ack=1). This scenario tests the arbiter's ability to handle coincident control events, ensuring that no hazard, glitch, or corruption occurs in the grant or credit logic. The arbiter must process both the acknowledgment and the priority update correctly, reflecting the new priority in subsequent arbitration cycles, and must not deadlock or produce illegal outputs.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0.
2) Set up a scenario where a requestor (e.g., req[1]=1 or req[3]=1) is about to be granted (req asserted, credits available).
3) Wait for gnt_w and gnt_id to indicate a grant to the chosen requestor.
4) In the same cycle as ack=1 for that requestor, simultaneously drive prio_upt=1, prio_id to that requestor, and prio to a new legal value.
5) Observe gnt_w, gnt_id, and credit behavior for the affected requestor over several cycles to ensure no hazard or glitch occurs.
6) Afterward, perform normal arbitration for several cycles to confirm continued correct operation and no deadlock.
7) Optionally, assert rst to confirm recovery to a legal state.","1) No hazard, glitch, or corruption occurs in grant or credit logic when ack and prio_upt are asserted together.
2) The affected requestor's grant frequency reflects the updated priority in subsequent cycles.
3) Grant advances as expected; new priority is used in subsequent arbitration.
4) No deadlock, no repeated grants, no illegal outputs.
5) Credit counters and priorities are updated per spec.
6) After reset, all outputs and credits return to a legal state.","Functional:
  - cp_err_type: bins {prio_update_during_ack, ack_prio_upt_overlap, simultaneous_ack_prio_update}.
  - cp_detector: bins {grant_behavior, credit_monitor, grant_consistency, credit_update_hazard, correct_update, no_deadlock}.
  - cp_recovery: bins {normal_operation, reset_recovery, normal_progression}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Weighted Round Robin Arbitration and Fairness,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
simultaneous_priority_update_acknowledge_and_request_overlap_pipeline_hazard_negative_test,"Intentionally assert combinations of prio_upt (priority update strobe), ack (grant acknowledge), and new req[N-1:0] in the same clock cycle, with overlapping or back-to-back requests, to stress the hazard-free handling of simultaneous operations in the arbitration pipeline. This includes cases where ack and prio_upt target the same or different requestors, and where a new request arrives as a grant is being acknowledged. Expectation: No functional hazard, no grant misallocation, no deadlock, correct update of both priority and grant state, and proper round-robin pointer and credit management as per spec. Any race, mis-sequencing, or pipeline hazard should be detected and reported.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0] such that at least two requestors are active (e.g., req=0110).
3) Wait for a grant to be issued (observe gnt_w/gnt_id).
4) On the next rising clk edge, simultaneously assert ack=1 (to acknowledge the current grant), prio_upt=1 (to update the priority of a requestor), and/or set a new req[N-1:0] (to introduce a new request), with prio_id and prio set to valid values.
5) Maintain all other signals at legal values; ensure no other protocol violations.
6) After the simultaneous event, continue with legal requests and observe outputs for at least 4 cycles.
7) Optionally, repeat with prio_upt and ack targeting the same or different requestors, and with various new req patterns.
8) After test, assert rst=1 to confirm clean recovery.","1) No deadlock: gnt_w and gnt_id continue to update in subsequent cycles (arbitration proceeds).
2) Correct grant: The grant is not misallocated (no double grant, no skipped requestor, no stuck output).
3) Priority update: The targeted requestor's priority is updated exactly once, and the new priority is reflected in subsequent arbitration cycles.
4) No data corruption: No requestor receives a grant it did not request, and no grant is lost.
5) No credit mis-accounting: credits for each requestor are decremented only when granted and acknowledged.
6) Round-robin pointer advances exactly once per arbitration cycle, even with overlapping ack, prio_upt, and new req.
7) No error/IRQ/status flags are set (unless spec defines such for this case).
8) After reset, all outputs and internal state return to initial values (gnt_w/gnt_id idle, priorities and pointers reset).","Functional:
  - cp_err_type: bins {simultaneous_ack_and_prio_upt, pipeline_hazard_overlap}.
  - cp_detector: bins {grant_logic, priority_update_logic, grant_output, credit_update, pointer_update}.
  - cp_recovery: bins {reset_recovery}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.
Ensure coverage of both same and different requestor for ack/prio_upt overlap, and overlapping ack with new req.",Hazard-Free Simultaneous Priority Update and Grant Acknowledge,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 21)]"
negative_grant_behavior_on_no_eligible_requestors_and_credit_exhaustion,"This scenario verifies that the arbiter FSM and credit-based scheduling logic do not issue grants when no requestors are eligible, either due to all req inputs being low, all credits being exhausted, or a specific requestor's credits being zero. It also checks that the FSM transitions correctly to the REPLENISH state when no eligible requestors exist, that credits are refilled as per the replenishment policy, and that normal arbitration resumes only after eligibility is restored. The scenario covers observability of internal credit state via outputs, ensures no grant is issued during zero-credit periods, and confirms correct recovery after reset.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0 to initialize all state.
2) Initialize all priorities to legal values (e.g., prio=4 for all, or assign specific prio/prio_id/prio_upt as needed).
3) Drive req[N-1:0]=1 (all requestors requesting) and ack=1 repeatedly, cycling through grants until all credits are exhausted (simulate N*credits grants).
4) Alternatively, for a specific requestor Y, assert req[Y]=1 and ack=1 for CREDIT_W cycles to exhaust its credits, then keep req[Y]=1 and ack=0.
5) Once all credits are zero (globally or for a specific requestor), continue to hold req as appropriate and monitor gnt_w and gnt_id for several cycles.
6) Observe that no grant is issued (gnt_w=0, gnt_id=0 or not indicating the requestor) during the zero-credit period.
7) Confirm that in the next cycle, credits are refilled (REPLENISH state), and then arbitration resumes.
8) Optionally, set all req=0 (no requestors active) for several cycles and observe outputs.
9) After recovery or replenishment, drive a single req bit high and confirm normal grant behavior resumes.
10) Optionally, perform a reset (rst=1) after the test to confirm clean recovery.","1) When all credits are zero and/or no req is active, gnt_w and gnt_id outputs remain zero (no grant issued).
2) No grant is issued to a requestor with zero credits until credits are refilled.
3) No spurious grant pulses or glitches on gnt_w/gnt_id during ineligible periods.
4) In the following cycle after all credits are zero, credits are refilled (can be checked via grant resumption or debug outputs if available).
5) After refill, arbitration resumes and grants are issued as per normal operation.
6) No deadlock or hang occurs; FSM transitions as per spec (ARBITRATION→REPLENISH→ARBITRATION).
7) After reset, all outputs return to initial state and arbitration resumes from a known state.","Functional:
  - cp_fsm_state: bins {arbitration, replenish}.
  - cp_no_eligible: bins {all_credits_zero & req_active, all_req_zero}.
  - cp_err_type: bins {grant_on_no_eligible_req, credit_exhaustion_not_observable, credit_underflow}.
  - cp_detector: bins {gnt_w, gnt_id, no_grant_on_zero_credit, correct_replenishment}.
  - cp_recovery: bins {refill_then_grant, new_req, credit_refill, replenish, reset}.
Cross:
  - cross_no_eligible_x_recovery: cp_no_eligible × cp_recovery.
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Global Arbitration FSM State Machine Operation,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10)]"
comprehensive_starvation_and_zero-starvation_guarantee_verification,"This scenario comprehensively stresses the zero-starvation guarantee of the WRR arbiter by combining multiple starvation-inducing conditions: (1) extreme priority skew where one requestor has minimum priority and others have maximum, (2) credit counter exhaustion and pointer manipulation to repeatedly skip a requestor, (3) dynamic priority updates that keep a requestor at lowest priority just before eligibility, and (4) long-term denial of grant to continuously requesting agents under legal but skewed priorities. The test expects that, under all these pathological conditions, every continuously requesting agent is eventually granted, confirming the zero-starvation guarantee and correct operation of credit, pointer, and dynamic priority update logic.","1) Apply clk and rst; hold rst=1 for at least 2 cycles, then deassert rst=0.
2) Configure priorities to cover:
   a) One requestor with prio=0 (lowest), others with prio=15 (highest).
   b) All requestors with prio=4 (default).
   c) Skewed legal priorities (e.g., prio[0]=1, prio[1]=8, prio[2]=1, others=1).
3) For each sub-case:
   - Assert req[0]=1 and req[1..N-1]=1 continuously (for extreme skew).
   - For requestor X, assert req[X]=1 continuously; for others, assert req[i]=1 only when pointer is not at X (simulate pointer skipping X).
   - On cycles where pointer is about to select a low-priority requestor, issue prio_upt to keep its priority at minimum (dynamic update glitch).
   - For all cases, keep ack high to accept every grant.
4) Observe gnt_w and gnt_id for at least 1000 cycles (or 10x max credit window).
5) After test, assert rst and confirm system returns to known state.","1) For each continuously requesting agent, check that at least one grant is observed within a bounded window (no starvation).
2) Check that gnt_id==target occurs at least once per scenario.
3) Confirm that credit counters are refilled as per spec (if observable).
4) Confirm that dynamic priority updates do not cause permanent starvation.
5) No deadlock: gnt_w and gnt_id continue to change, no output stuck.
6) No illegal grants (e.g., grant to non-requesting or out-of-range ID).
7) After reset, all counters and pointers re-initialize and normal arbitration resumes.","Functional:
  - cp_err_type: bins {starvation_violation, pointer_skip_starvation, dynamic_priority_starvation, starvation}.
  - cp_detector: bins {grant_monitor, credit_refill_monitor, prio_update_monitor}.
  - cp_recovery: bins {reset_recovery, reset}.
Cross:
  - cross_err_x_detector: cp_err_type × cp_detector.
  - cross_err_x_recovery: cp_err_type × cp_recovery.",Zero-Starvation Guarantee,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 16)]"
corner_reset_startup_pipeline_and_state_initialization_all_durations,"Verify that after synchronous reset (rst=1 for legal minimum and maximum durations), all pipeline and arbitration state (credits, priorities, pointer) is initialized to legal values per spec. Confirm that no grants are issued during reset, all outputs are held at reset values, and that arbitration is ready to begin immediately after reset deassertion. Check that the first arbitration cycle after reset produces a valid grant with correct latency, that priority and credit updates are accepted immediately post-reset, and that minimum credit is honored. Ensure all state initialization and grant behavior is synchronous to clk, with no asynchronous glitches or hazards.","1) Drive clk continuously at nominal frequency.
2) Assert rst=1 for both minimum (1 clk) and maximum (e.g., 16 clk) legal durations.
3) During rst=1, observe that no grant is issued (gnt_w=0, gnt_id=0), and all other inputs (req, ack, prio, prio_id, prio_upt) are X or 0.
4) Deassert rst=0; on the first cycle, drive req[N-1:0] with a single active request (e.g., req[0]=1, others=0), ack=0, prio_upt=0.
5) Observe gnt_w/gnt_id in the next cycle; acknowledge grant with ack=1 for one cycle.
6) Repeat for all requestors (i=0..N-1) and for both min and max rst durations.
7) After reset deassertion, drive prio, prio_id, prio_upt to update a priority and confirm update is accepted in the first cycle post-reset.
8) Optionally, repeat with different single-bit req patterns and verify grant order for N cycles.","1) During rst=1, check that all outputs (gnt_w, gnt_id) are inactive and held at reset values; no grants issued.
2) After rst=0, check that credits=1, priorities=0, pointer=0 (implied by grant to requestor 0 or matching req).
3) Confirm that the first grant is issued with 1-cycle latency after req is driven, and only one-hot gnt_w per cycle.
4) Ensure no pipeline hazard, spurious grant, or asynchronous output transitions at reset boundary; all transitions must be synchronous to clk rising edge.
5) After reset, check that priority update via prio/prio_id/prio_upt is accepted and reflected in subsequent arbitration.
6) No grants are issued with credit=0.","Functional:
  - cp_reset_state: bins {rst_active, rst_deasserted}.
  - cp_rst_duration: bins {min=1, max=16} cycles.
  - cp_first_grant: bins {grant_to_0, grant_to_other}.
  - cp_credit_init: bins {credit=1 after reset}.
  - cp_priority_update_post_reset: bins {update_accepted_first_cycle}.
  - cp_grant_after_reset: bins for first grant after reset.
Cross:
  - cross_reset_x_first_grant: cp_reset_state × cp_first_grant.
  - cross_rst_duration_x_post_reset_arbitration: cp_rst_duration × cp_first_grant.
Code:
  - Reset logic, pipeline register, arbitration path, credit/prio register init, pointer reset, and synchronous output toggles.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 16)]"
corner_reset_concurrency_with_all_inputs_active_ack_and_priority_update_min_inter_reset_gap,"Verify synchronous reset and state initialization behavior under concurrency of all requestors active, priority update, and ack asserted at reset boundary, as well as with minimum legal inter-reset gap (back-to-back resets). This scenario tests legal timing and input concurrency edges, including simultaneous input activity, configuration, and handshake at reset exit and during rapid reset cycling.","1) Drive clk continuously.
2) Assert rst=1 for 4 cycles (typical legal duration).
3) On the cycle rst transitions from 1→0, simultaneously drive req[N-1:0]=all 1s, prio_upt=1, prio_id=0, prio=4'b1111 (max priority for requestor 0), ack=1.
4) Hold ack=1 for 1 cycle to simulate grant acceptance, then ack=0.
5) Observe gnt_w, gnt_id for grant decision in the first arbitration cycle.
6) In subsequent cycles, observe that the priority update is reflected in arbitration (requestor 0 should win more frequently).
7) Repeat with prio=4'b0001 (min nonzero priority) for requestor 0.
8) After 2 cycles, re-assert rst=1 for 1 cycle (minimum legal inter-reset gap), then deassert rst=0.
9) On the next clk, drive req[N-1:0]=one-hot (e.g., req[2]=1), ack=1, prio_upt=0.
10) Observe gnt_w, gnt_id after each reset for correct grant and state initialization.","1) On rst=1, no grant is issued (gnt_w=0, gnt_id=0).
2) On first clk after rst=0, a grant is issued to one of the active requestors (per round-robin and credit rules), and the priority update is accepted (reflected in subsequent arbitration cycles).
3) After each rst deassertion, gnt_w and gnt_id reflect the new requestor (no stale state from before reset).
4) Confirm that no spurious grants or glitches occur during or immediately after reset.
5) ack input during/after reset does not cause illegal state or missed grant.
6) Arbitration is ready immediately after each reset, regardless of inter-reset gap.
7) Confirm that the priority update does not corrupt initialization or cause illegal state.","Functional:
  - cp_req_pattern: bins {all_zeros, all_ones, one-hot} at reset exit.
  - cp_prio_value: bins {min=1, max=15} for prio input.
  - cp_concurrent_prio_upt: bins {prio_upt_at_reset_exit}.
  - cp_ack_during_reset: bins {ack=0, ack=1} at/after reset.
  - cp_inter_reset_gap: bins {min=1, typical=2, max=16} cycles.
Cross:
  - cross_req_pattern_x_prio_value.
  - cross_ack_during_reset_x_inter_reset_gap.
Code:
  - Priority register and credit counter initialization, reset and handshake logic, state flops, and arbitration FSM transitions under full load and rapid reset cycling.",Synchronous Reset and State Initialization,"[('weighted_round_robin_mas.pdf', 13)]"
corner_fsm_credit_refill_and_pointer_update_edge_cases,"Verify the FSM and sequential update pipeline behavior at all legal edge cases involving credit exhaustion, refill, and round-robin pointer update. This includes: (1) the transition from ARBITRATION to REPLENISH when the last eligible requestor is granted and all credits are exhausted, (2) the correct withdrawal of grant and latency for credit refill, (3) the immediate re-entry to ARBITRATION after REPLENISH when requests are present, and (4) correct pointer advancement and hazard-free operation at the refill boundary.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst=0 to initialize FSM, credits, and pointer.
2) Drive req[N-1:0] to various patterns (e.g., single active, multiple active, all active) and consume credits via grants and acks until all credits are exhausted for the active requestors.
3) Observe the cycle where the last eligible requestor is granted and acked, resulting in no eligible requestor (all credits zero).
4) Confirm that on the next cycle, gnt_w=0 (no grant), and FSM enters REPLENISH state.
5) Maintain req asserted; after the specified refill latency (e.g., 2 cycles), observe credits are refilled and FSM transitions back to ARBITRATION.
6) After refill, continue driving req and observe that arbitration resumes with correct pointer advancement and grant issuance.","1) Check that after all credits are exhausted, the next cycle issues no grant (gnt_w=0), and FSM transitions to REPLENISH.
2) Confirm that REPLENISH state lasts for the specified latency (e.g., 2 cycles), with no spurious grants during this period.
3) After refill, verify that ARBITRATION resumes and a grant is issued immediately if requests are present, with correct round-robin pointer and priority.
4) Ensure that after refill, the pointer advances correctly and no hazard or double-grant occurs at the refill boundary.
5) Latency from last grant to next grant matches the specification.","Functional:
  - FSM transitions: bins {arbitration_to_replenish, replenish_to_arbitration}.
  - Credit state: bins {all_credits_exhausted, credits_refilled}.
  - Grant withdrawal and resumption: bins {grant_to_nogrant, grant_issued_immediately_post_refill}.
  - Pointer update: bins {pointer_wrap, pointer_no_wrap}.
  - Refill dwell: bins {min_dwell=1, latency=2}.
Cross:
  - cross_transition_x_latency: FSM transitions × refill latency.
  - cross_credit_state_x_pointer: credit state × pointer update.
Code:
  - FSM state transition and credit refill logic coverage.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12)]"
corner_dynamic_priority_update_during_arbitration,"Verify that dynamic priority updates (via prio, prio_id, prio_upt) applied at the legal timing edge (during an active grant/ack cycle) are correctly reflected in subsequent arbitration decisions, as observable on grant outputs. This scenario exercises the legal concurrency of configuration and arbitration, ensuring that the new priority takes effect without stalling arbitration, causing hazards, or corrupting grant behavior. It covers both mid-value and maximum priority updates, and checks that fairness and scheduling are preserved.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst=0 to initialize.
2) Set initial priorities for all requestors to a mid-value (e.g., prio=4).
3) For requestors #0 and #1, assert req[0]=1, req[1]=1, ack=0; observe which requestor is granted first (e.g., lower index wins).
4) On the next cycle, with ack=1, assert prio_upt=1, prio_id=1, prio=15 (max) to boost requestor 1's priority during the ack cycle.
5) Alternatively, set prio_id=1, prio=6 or prio=8 to test different priority increments during ack.
6) Deassert prio_upt in the next cycle; keep req=0011.
7) Continue with req[0]=1, req[1]=1, ack=0, and observe if requestor 1 now wins the grant due to higher priority.
8) Repeat with different prio/prio_id/prio_upt values to cover various legal update timings and values.","1) After priority update, grant outputs (gnt_w, gnt_id) must reflect the new priority in the next arbitration cycle.
2) Confirm that after the priority update, the updated requestor receives grants as per the new priority (e.g., more frequent grants if weight increased).
3) No glitch, illegal, missed, or duplicated grant during or after the update.
4) Grant order before and after update matches expected behavior per priority.
5) Only one-hot gnt_w per cycle, and gnt_id matches granted requestor.
6) Priority update is effective immediately after prio_upt is asserted.
7) No grant to non-requesting or non-eligible requestors.
8) Ensure that the update is hazard-free (no pipeline stall or glitch).","Functional:
  - cp_prio_update_timing: bins {update_during_ack, update_idle}.
  - cp_prio_value: bins {mid, max, increment}.
  - cp_grant_result: bins {grant_to_updated_requestor, grant_to_other}.
  - cp_grant_after_update: bins for which requestor is granted after update.
Cross:
  - cross_prio_update_x_grant: cp_prio_update_timing × cp_grant_result.
  - cross_update_timing_x_grant: cp_prio_update_timing × observed grant winner.
Code:
  - Priority update logic, register write, and arbitration logic under update.
  - Toggle/branch coverage in priority update and arbitration logic.
  - Pipeline interaction coverage.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 10), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 16)]"
corner_priority_update_and_weighted_grant_extremes_and_off_by_one,"Verify correct behavior of the arbitration logic and priority register file when updating a requestor's priority to the legal minimum (0), maximum (15), and off-by-one extremes (1, 14) via the sideband interface during active arbitration. Ensure that runtime priority updates at these boundary values, including when performed concurrently with grant/acknowledge activity, do not stall or interfere with ongoing grant decisions. Confirm that grant frequency is proportional to the assigned priority, that no requestor is starved, and that arbitration logic responds correctly to all legal and near-extreme weights.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0] such that at least two requestors (e.g., #0 and #1) are active (req[0]=1, req[1]=1, req[2..N-1]=0).
3) For requestor #0:
   a) Drive prio_id=0, prio=0, prio_upt=1 for one clk cycle (set to min weight).
   b) Wait 1 cycle, then drive prio_id=0, prio=1, prio_upt=1 for one clk cycle (off-by-one above min).
   c) After 4 cycles, drive prio_id=0, prio=14, prio_upt=1 for one clk cycle (off-by-one below max).
   d) After another 4 cycles, drive prio_id=0, prio=15, prio_upt=1 for one clk cycle (set to max weight).
4) For requestor #1, set prio_id=1, prio=15, prio_upt=1 for one cycle (set to max priority), then deassert prio_upt.
5) During each update, ensure ack=1 is asserted in the same cycle as prio_upt=1 (simultaneous grant acknowledge and priority update).
6) For all other cycles, prio_upt=0. Continue to assert req[0]=1, req[1]=1; drive ack=1 for each grant.
7) Observe gnt_w and gnt_id outputs throughout, for at least 32 cycles.","1) After each priority update, verify that requestor #0's grant frequency matches the updated priority: minimum for prio=0, just above minimum for prio=1, just below maximum for prio=14, and maximum for prio=15, compared to requestor #1.
2) Confirm that #1 (max priority) receives grants at the highest possible frequency, and #0 at the lowest when prio=0, with proportional adjustment at prio=1 and prio=14.
3) Ensure no arbitration stall, skipped grant, or output corruption during/after updates, including when prio_upt and ack are asserted together.
4) Check that only one-hot gnt_w is asserted per cycle, and gnt_id matches the granted requestor.
5) No starvation: #0 must eventually receive a grant (due to round-robin pointer).
6) No illegal values are driven on gnt_w or gnt_id.","Functional:
  - cp_prio_val: bins {min=0, minp1=1, maxm1=14, max=15} on prio input.
  - cp_prio_upt_ack_overlap: bin where prio_upt=1 and ack=1 in same cycle.
  - cp_update_timing: bins {update_during_grant, update_between_grants}.
  - cp_req_pattern: bins {two_active, one_active}.
  - cp_grant_ratio: bins for observed grant ratios (e.g., 1:1, 1:15, 1:16).
Cross:
  - cross_prio_val_x_gnt_id: cp_prio_val × cp_gnt_id.
  - cross_prio_value_x_update_timing: cp_prio_val × cp_update_timing.
  - cross_prio_x_grant: cp_prio_val × cp_grant_ratio.
Code:
  - Priority register file write, arbitration logic, credit counter refill, round-robin pointer advancement, and grant output toggles.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 16)]"
corner_simultaneous_priority_update_and_grant_acknowledge_all_priority_values,"Verify that a priority update (prio_upt=1) for any requestor can occur in the exact same cycle as a grant is acknowledged (ack=1), and that both operations are handled correctly without interference or hazard. This includes cases where the priority value is set to its minimum, maximum, or midpoint, and covers both the case where the updated requestor is the same as or different from the granted requestor. The scenario ensures that arbitration, grant progression, and priority register updates are all handled synchronously and hazard-free, with no missed, duplicated, or spurious grants, and that subsequent arbitration cycles reflect the updated priority as per spec.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req such that at least two requestors are active (e.g., req[1:0]=2'b11, others 0).
3) Allow arbitration to proceed until a grant is issued (gnt_id, gnt_w).
4) On a selected cycle, simultaneously assert ack=1 for the granted requestor and prio_upt=1 for a (possibly different) requestor, with prio_id set accordingly and prio set to MIN (0), MID (8), or MAX (15) in separate sub-cases.
5) For the case where the granted and updated requestor are the same, repeat with prio set to MIN and MAX.
6) Continue driving req and observe gnt_id, gnt_w for several cycles to confirm correct arbitration and priority update behavior.
7) Repeat for different pairs of granted and updated requestors.","1) Both priority update and grant acknowledge are processed synchronously in the same cycle, with no missed, duplicated, or spurious grants.
2) Priority register for the updated requestor is set to the new value (min, mid, or max) with no hazard.
3) Arbitration in subsequent cycles reflects the updated priority (i.e., requestor with higher priority wins more frequently).
4) Grant is not repeated to the same requestor without ack, even if prio_upt is asserted simultaneously.
5) No output glitches or asynchronous transitions on gnt_w, gnt_id.
6) No other requestor is erroneously granted.","Functional:
  - Bins for prio_upt=1 and ack=1 in the same cycle (concurrent event).
  - Bins for prio values at min=0, mid=8, max=15 during concurrent event.
  - Bins for each requestor as grant and as priority update target.
  - Bins for grant progression (grant advances, grant stalls).
Cross:
  - Cross prio_upt/ack concurrency with prio value and grant target.
  - Cross which requestor is granted vs. which is updated.
Code:
  - Toggle/branch coverage in priority update, grant FSM, and output logic during concurrent events.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 13), ('weighted_round_robin_mas.pdf', 21)]"
corner_back_to_back_priority_updates_all_and_multiple_requestors,"Verify that multiple and all requestors' priorities can be updated in back-to-back cycles (minimum legal inter-update gap), and that each update is correctly applied without loss, overwrite, or stalling arbitration. This exercises the legal minimum timing for consecutive sideband updates and ensures that runtime priority updates do not interfere with arbitration or corrupt grant outputs.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) For i=0 to N-1 (N=32):
   a) In cycle i, drive prio_id=i, prio=i (mod 16), prio_upt=1 for one clk cycle (assign unique legal priority to each requestor).
   b) prio_upt=0 in all other cycles.
3) After all updates, drive req[N-1:0]=all 1's (all requestors active).
4) For a subset of cycles, perform back-to-back updates for a few requestors (e.g., prio_id=0,1,2 with prio=5,10,2 in consecutive cycles) while req[0..2]=1, req[3..31]=0.
5) Continue to assert req as needed and drive ack=1 for each grant.
6) Observe gnt_id and gnt_w for arbitration behavior reflecting the programmed priorities.","1) Each requestor's priority is updated exactly once, with no missed or overwritten values.
2) Confirm that each priority update is applied to the correct requestor and reflected in subsequent arbitration cycles.
3) Arbitration and grant outputs are not stalled or corrupted during/after updates.
4) Arbitration after updates reflects the assigned priorities (higher priority requestors win more grants).
5) No illegal grant or priority value is observed.
6) gnt_id and gnt_w outputs match expected arbitration order based on programmed priorities.","Functional:
  - cp_prio_id: bins for all 32 requestor IDs.
  - cp_prio_val: bins for all legal priority values (0..15).
  - cp_prio_upt_gap: bin for minimum legal gap (1 cycle between updates).
  - cp_update_sequence: bins {back_to_back_updates}.
  - cp_prio_value: bins {5, 10, 2}.
Cross:
  - cross_prio_id_x_prio_val: all requestor IDs × all legal priorities.
  - cross_update_sequence_x_prio_id: update order × requestor.
Code:
  - Priority register file write, arbitration logic, and grant output toggles for all requestors.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 13)]"
corner_arbitration_and_credit_refill_latency_boundaries,"Verify that the arbitration and credit refill paths operate synchronously and that the latency for a grant matches the spec-defined boundaries: 1 cycle in normal operation and 2 cycles when a credit refill is required. This scenario exercises the legal minimum and maximum arbitration latency, ensuring the design meets both boundaries and that synchronous refill behavior is maintained.","1) Assert rst=1 on the rst port for at least 2 clk cycles, then deassert rst=0 to initialize the arbiter and credit manager.
2) For normal operation (no credit refill):
   a) Drive req[N-1:0] such that at least one requestor has credit (e.g., req[0]=1, others=0).
   b) For PRIORITY_W=4, set prio/prio_id/prio_upt to initialize the requestor's priority to 0 (minimum legal value, so credit=1).
   c) Observe gnt_w and gnt_id; drive ack=1 on the next cycle to accept the grant.
   d) Repeat for several cycles, ensuring credits are not exhausted (simulate with initial priorities and credits).
3) For credit refill case:
   a) Drive req[N-1:0] such that all requestors have exhausted their credits (simulate by granting each until credits reach 0).
   b) On the next arbitration cycle, keep req asserted for at least one requestor.
   c) Observe that no grant is issued in the first cycle after exhaustion, but a grant is issued in the second cycle after credits are refilled.
4) Use minimum legal inter-request gaps (1 cycle between ack assertions) to stress the pipeline.
5) All transitions and observations should be made on clk rising edge.","1) For normal operation: Check that the time from req assertion to gnt_w/gnt_id assertion is exactly 1 cycle for eligible requestors.
2) For credit refill: After credit is exhausted, check that no grant is issued for exactly 1 cycle (refill latency), then grant resumes in the next cycle (total 2 cycles latency).
3) Ensure that gnt_w is one-hot and gnt_id matches the granted requestor.
4) All transitions occur only on clk rising edge; no asynchronous output or meta-stability.
5) Scoreboard to track credits per requestor and confirm correct refill and arbitration behavior.
6) Grant latency matches spec (1 cycle for normal, 2 cycles for credit refill).","Functional:
  - cp_latency: bins {lat_1=1 cycle (normal), lat_2=2 cycles (refill)}.
  - cp_credit_value: bins {min=1, mid=8, max=15} (including min=1).
  - cp_credit_state: bins {credit_nonzero, credit_zero}.
  - cp_refill_latency: bins {1, 2} cycles.
Cross:
  - cross_latency_x_credit: cp_latency × cp_credit_state.
  - cross_credit_x_latency: cp_credit_value × cp_refill_latency.
Code:
  - Statement/branch/toggle in arbitration, credit refill, and FSM state transitions (ARBITRATION <-> REPLENISH).",Arbitration Latency Envelope and Pipelining,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 14)]"
corner_grant_and_ack_behavior_at_credit_exhaustion_and_refill_boundary,"Verify that the arbiter does not assert any grant (gnt_w, gnt_id) when all requestors are ineligible (either no req asserted or all credits exhausted), and only resumes granting after credits are refilled or new requests are asserted. Additionally, verify grant progression and ack behavior at the legal boundary where all credits are exhausted and a credit refill occurs, ensuring grants are not repeated or skipped across the refill boundary. This scenario exercises the legal boundary where no eligible requestors exist, the transition to the refill state, and the correct resumption of grant and acknowledge protocol after refill.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the arbiter (per reset/startup sequence).
2) For N=32, drive req=0 (all zeros) for at least 2 cycles after reset, with ack=0, prio_upt=0. Observe gnt_w and gnt_id: they must remain zero (no grant).
3) Next, drive req=0xFFFFFFFF (all ones) for N cycles, with ack=1 every cycle, to exhaust all credits (simulate all requestors being granted until credits run out).
4) After all credits are exhausted, continue driving req=0xFFFFFFFF, ack=1. Observe that gnt_w and gnt_id go to zero (no eligible requestors).
5) Now, on the next cycle, optionally drive prio=0xF (max), prio_id=0, prio_upt=1 to update priority of requestor 0, then prio_upt=0. Continue driving req=0xFFFFFFFF, ack=0. Observe that after the refill cycle, gnt_w and gnt_id resume granting (nonzero).
6) For a focused ack progression check: drive req[1:0]=1, req[N-1:2]=0 (only requestors 0 and 1 active). For cycles 0..2: (a) Cycle 0: ack=0; observe gnt_w, gnt_id. (b) Cycle 1: ack=1; observe gnt_w, gnt_id. (c) Cycle 2: ack=1; observe gnt_w, gnt_id (expect no eligible req, triggers refill). (d) Cycle 3: ack=0; observe gnt_w, gnt_id (after refill, grant resumes).","1) During cycles where req=0 (all zeros), gnt_w==0 and gnt_id==0 at all times.
2) After all credits are exhausted (after N grants with req=all ones and ack=1), gnt_w==0 and gnt_id==0 until credits are refilled.
3) After a refill (either by priority update or automatic refill per spec), gnt_w and gnt_id become nonzero if req is asserted.
4) No spurious grant pulses during the no-eligible period.
5) Latency from refill to first grant is within 2 cycles (per spec Table: Latency Under Different Conditions).
6) Grant is not repeated to the same requestor without ack, even across credit refill.
7) After refill, grant resumes to eligible requestor per round-robin and priority.
8) No grant is issued in the cycle where no eligible requestor exists (gnt_w=0, gnt_id=0).","Functional:
  - cp_req: bins {all_zeros, all_ones, single_one, alternating}
  - cp_gnt: bins {no_grant, grant_after_refill}
  - cp_credit_state: bins {all_credits_zero, all_credits_nonzero}
  - cp_credit_refill: bins {before_refill, at_refill, after_refill}
  - cp_ack: bins {ack=0, ack=1}
Cross:
  - cross_req_x_gnt: cp_req × cp_gnt
  - cross_credit_state_x_gnt: cp_credit_state × cp_gnt
  - cross_credit_refill_x_ack: cp_credit_refill × cp_ack
Code:
  - Statement/branch/toggle in grant logic, credit exhaustion, refill path, and FSM transition ARBITRATION <-> REPLENISH.",No Grant When No Eligible Requests,"[('weighted_round_robin_mas.pdf', 9)]"
corner_credit_counter_min_max_and_refill_boundary,"Exercise the legal minimum (credit=1) and maximum (credit=255) values for the credit counter (8 bits), verifying correct grant, decrement, and refill behavior at these boundaries. This scenario ensures that no overflow or underflow occurs at the legal limits, that the credit counter decrements correctly upon each grant, and that the refill logic sets the credit to prio+1 when exhausted. It also verifies correct grant output and latency at the refill boundary.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst to 0.
2) For a chosen requestor (e.g., #5 or #m):
   a) Set prio_id to the requestor, prio to a legal value (e.g., 254 or 255), prio_upt=1 for one cycle to set high priority.
   b) Wait 1 cycle, then deassert prio_upt.
3) Drive req[requestor]=1, all others 0, for 1 cycle. Wait for gnt_w[requestor]=1 and gnt_id==requestor.
4) Repeat grant/ack cycles for the requestor, observing the credit counter decrement from max (255) down to 1 (minimum legal value before exhaustion).
5) On the next grant, observe that credit is decremented to 0, triggering a refill to prio+1 (max legal value, e.g., 255 or 256 depending on prio).
6) After credit reaches 0, ensure the requestor is not granted until after the refill latency (per spec, 2 cycles), after which the requestor is eligible again with refilled credit.
7) Continue to observe grant/refill cycles for at least 2 more cycles to confirm repeated correct behavior.","1) Monitor credit counter for the requestor:
   - Ensure decrements from max (255) down to 0, one per grant.
   - At credit=1, grant is still issued; after grant, credit becomes 0 and triggers refill.
   - After refill, credit is set to prio+1 (legal max value).
   - No overflow (credit never > max legal value) and no underflow (never < 0).
2) After the last grant with credit=1, the requestor is not granted in the immediate next cycle (credit=0, ineligible).
3) After the refill latency (2 cycles), the requestor is granted again, and gnt_w and gnt_id are correct.
4) Only one-hot gnt_w and correct gnt_id per grant.
5) The number of grants between refills matches the programmed prio+1 value.
6) Latency from req to grant is 1 cycle (normal), 2 cycles on refill (per spec).","Functional:
  - cp_credit: bins {min=1, zero=0, max=255, refill=prio+1}.
  - cp_grant_at_edge: bins for grant at credit=1 and credit=0.
  - cp_refill_event: bins {refill_at_zero}.
  - cp_prio_value: bins {min=0, max=15} (if PRIORITY_W=4).
Cross:
  - cross_credit_x_grant: cp_credit × grant event.
  - cross_credit_x_prio: cp_credit × prio value.
  - cross_credit_value_x_refill: cp_credit × refill event.
Code:
  - Statement/branch/toggle in credit counter decrement and refill logic at min/max and refill boundaries.",Weighted Round Robin Arbitration and Fairness,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
corner_round_robin_pointer_wrap_and_zero_starvation_all_priorities,"Verify that the round-robin pointer advances through all requestors and wraps correctly at the boundary (N-1 to 0), ensuring zero-starvation: every requestor is eventually granted, even if all have equal priority and are always requesting. This scenario covers both the minimum legal priority (0) and a non-zero priority (e.g., 1), confirming that zero-starvation and pointer wraparound are guaranteed regardless of the assigned priority. It also checks that at the lowest possible bandwidth allocation per requestor, the round-robin pointer's fairness is maintained.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst to 0.
2) For all requestors (i=0..N-1):
   a) Set prio_id=i, prio=0, prio_upt=1 for one cycle (set all priorities to minimum legal value).
3) Deassert prio_upt.
4) For at least N*4 cycles:
   a) Drive req[N-1:0]=all 1's (all requestors always request).
   b) ack=1 every cycle after each grant is observed.
5) Repeat steps 2-4 with prio=4'b0001 (all priorities set to 1) to cover non-zero priority case.
6) Observe gnt_w and gnt_id each cycle.","1) Track which requestors are granted over the test window (N*4 cycles for each priority setting).
2) Ensure each requestor is granted at least once per round (no starvation), and the pointer wraps from N-1 to 0.
3) Only one-hot gnt_w per cycle, and gnt_id matches granted requestor.
4) No duplicate grants in a single round unless refill occurs.
5) Confirm that latency between consecutive grants to the same requestor is within the legal bound (no more than N cycles, except during refill).","Functional:
  - cp_pointer: bins {wrap=N-1→0, mid=N/2, start=0}.
  - cp_prio: bins {min=0, nonzero=1} for all requestors.
  - cp_req_pattern: bin {all_active}.
  - cp_grant_seq: bins for grant order across N cycles.
  - cp_grant: bins {each_requestor_granted}.
Cross:
  - cross_pointer_x_grant: cp_pointer × grant event.
  - cross_prio_x_grant: cp_prio × cp_grant (all requestors at min and nonzero priority, all granted).
Code:
  - Pointer increment, wrap logic, credit refill, and grant selection.",Weighted Round Robin Arbitration and Fairness,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 16)]"
corner_zero_starvation_and_dynamic_priority_update_at_credit_refill_boundary,"Verify that a requestor with minimum priority (0) is not starved even when all other requestors have maximum priority (15) and are continuously requesting, and further verify that if the requestor's priority is dynamically increased from minimum to maximum exactly at the cycle when its credit is refilled (i.e., at the refill boundary), it receives grants according to the new weight. This scenario stresses the starvation guarantee for the lowest-priority requestor amidst maximum-weight competitors and exercises the legal timing edge of dynamic priority update coinciding with credit refill, confirming both zero-starvation and correct grant frequency adjustment.","1) Assert rst=1 for at least 2 clk cycles, then deassert rst=0.
2) For i=0, set prio_id=0, prio=0, prio_upt=1 for one clk cycle (requestor 0 gets min priority).
3) For i=1..N-1, set prio_id=i, prio=15, prio_upt=1 for one clk cycle each (all others get max priority).
4) Deassert prio_upt.
5) Drive req[N-1:0]=all 1's (all requestors active) for at least N*16 cycles (to allow for multiple full pointer rotations and credit refills).
6) For each grant, drive ack=1 for one cycle after grant is observed.
7) Monitor gnt_w and gnt_id for grants to requestor 0.
8) When requestor 0's credit is about to be refilled (after prio+1 grants), on the same cycle as refill, set prio_id=0, prio=15, prio_upt=1 for one clk cycle (priority update coincides with refill).
9) Continue driving req and ack as before for at least N*16 cycles.
10) Monitor grant frequency to requestor 0 before and after the update.","1) Scoreboard: Record if gnt_w[0]==1 and gnt_id==0 is observed at least once during the test window.
2) Check that the interval between consecutive grants to requestor 0 does not exceed the legal maximum (should be no more than N*16 cycles, accounting for refill and pointer wraparound).
3) Confirm that all other requestors are granted proportionally more often, but requestor 0 is never starved.
4) After the priority update at refill, check that requestor 0 receives grants at a higher frequency (proportional to new prio+1 credits).
5) Confirm that requestor 0 is not starved before or after the update.
6) Check that no grant is missed or duplicated at the update boundary (no glitch in grant logic).","Functional:
  - cp_prio: bins {min=0, max=15}.
  - cp_req_pattern: bin {all_active}.
  - cp_grant: bins {requestor0_granted, others_granted, before_update, after_update}.
  - cp_prio_update_timing: bins {update_at_refill, update_not_at_refill}.
Cross:
  - cross_prio_x_grant: cp_prio × cp_grant (requestor 0 at min, others at max, all granted).
  - cross_update_timing_x_grant: cp_prio_update_timing × cp_grant.
Code:
  - Branch/toggle in credit refill, pointer advance, grant selection, and priority update logic.",Zero-Starvation Guarantee,"[('weighted_round_robin_mas.pdf', 4)]"
corner_concurrent_credit_and_priority_update_at_refill_boundary,"Verify hazard-free and synchronized credit updates and grant issuance when a priority update (prio/prio_id/prio_upt) occurs concurrently with a grant/ack, especially at the timing-critical edge where the priority update is applied exactly at the credit refill boundary (i.e., when credit is about to be exhausted). Ensure that the new priority value is used for the next credit refill and that no hazards or glitches occur in grant or credit logic during this legal concurrency.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Set prio for requestor k (or Y) to an initial value (e.g., prio=4'b0010 for value 2) via prio, prio_id, prio_upt.
3) Wait ≥2 cycles for update.
4) Drive req[k]=1 (all others 0); ack=1 on each grant to k, until credit is decremented to 1.
5) On the cycle when k is granted with credit=1, simultaneously drive prio=MAX (e.g., 0xF), prio_id=k, prio_upt=1 (priority update), and ack=1.
6) Deassert prio_upt and ack in the next cycle.
7) Continue driving req[k]=1 for several cycles to observe subsequent grant and credit behavior, including the next refill using the new prio value.
8) Optionally, repeat with prio_upt and ack in the same cycle at other credit values to cover concurrency cases.","1) No hazard: credit counter for requestor k is updated exactly once per grant, even with concurrent priority update at the refill boundary.
2) Grant output (gnt_w/gnt_id) remains consistent and no spurious grants occur.
3) Priority update takes effect for the next credit refill for requestor k, not retroactively for the current grant.
4) The number of grants between refills after the update matches the new prio+1.
5) No grants occur with credit=0.
6) gnt_w[k]=1 and gnt_id==k only when credit>0.","Functional:
  - cp_concurrent_ack_prio_upt: bins {ack & prio_upt same cycle, ack only, prio_upt only}.
  - cp_prio_update_timing: bins {update_at_credit_1, update_at_credit_0, update_after_refill}.
  - cp_prio_value: bins {min=0, max=0xF}.
  - cp_refill_value: bins {old_prio+1, new_prio+1}.
Cross:
  - cross_concurrent_x_prio_value: cp_concurrent_ack_prio_upt × cp_prio_value.
  - cross_update_timing_x_refill: cp_prio_update_timing × cp_refill_value.
Code:
  - Statement/branch/toggle in credit update, priority update, and credit refill logic.",Grant Output and Credit Update Consistency,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9), ('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 17)]"
corner_priority_and_credit_weight_extremes,"Verify correct scheduling and credit refill behavior when a requestor is programmed with both the minimum (prio=0) and maximum (prio=15, PRIORITY_W=4) legal priority values, resulting in the minimum (1) and maximum (16) credit refill values, respectively. This tests both lower and upper legal edges for weight-based scheduling.","1) Drive clk; assert rst=1 for ≥2 cycles, then deassert rst=0.
2) For requestor W, set prio to 4'b0000 (0) via prio, prio_id, prio_upt. For requestor Z, set prio to 4'b1111 (15) via prio, prio_id, prio_upt.
3) Wait ≥2 cycles for update.
4) Drive req[W]=1, all other req=0; ack=1 on each grant to W. Observe that W is granted for 1 cycle (credit=1), then not granted for 2 cycles (refill latency), then granted again for 1 cycle after refill. Repeat for at least two refill cycles.
5) Drive req[Z]=1, all other req=0; ack=1 on each grant to Z. Observe that Z is granted for 16 consecutive cycles (credit decremented from 16 to 1), then not granted for 2 cycles (refill latency), then granted again for 16 cycles after refill. Repeat for at least two refill cycles.","1) Number of consecutive grants to W between refills is exactly 1 (min legal value); for Z, exactly 16 (max legal value).
2) No grants to W or Z during refill latency (credit=0).
3) After each refill, credit is set to prio+1 (1 for W, 16 for Z).
4) gnt_w[W]=1 and gnt_id==W only when credit>0; gnt_w[Z]=1 and gnt_id==Z only when credit>0.","Functional:
  - cp_prio_value: bins {min=0, max=15}.
  - cp_credit_refill: bins {min=1, max=16}.
Cross:
  - cross_prio_x_credit: cp_prio_value × cp_credit_refill.
Code:
  - Min and max value handling in credit and priority logic.",Credit-Based Scheduling and Replenishment Policy,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
corner_concurrent_requests_acknowledge_progression_and_credit_exhaustion,"Verify correct arbitration, grant progression, and credit handling under various concurrency and acknowledgment conditions. This includes: (1) multiple requestors simultaneously reaching credit exhaustion and correct refill/eligibility behavior; (2) ensuring the arbiter does not repeat a grant to the same requestor without an intervening acknowledgment, even when only one requestor is active; (3) exercising the arbiter with all requestors active and issuing acks in round-robin order at the minimum legal interval to verify fair grant progression and no repeats without ack. This scenario covers edge cases for credit-based scheduling, grant acknowledge/progression, and round-robin fairness.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) For credit exhaustion concurrency:
   a) Set prio for requestors A and B to the same value via prio, prio_id, prio_upt.
   b) Wait ≥2 cycles for update.
   c) Drive req[A]=1, req[B]=1, all other req=0; ack=1 on each grant to A or B, until both reach credit=1.
   d) On the cycle when both A and B are granted with credit=1, drive ack=1 for both as appropriate.
   e) Observe that in the next arbitration cycle, neither A nor B is granted (credit=0), and after the refill latency, both are eligible again with credit=prio+1.
   f) Continue driving req[A]=1, req[B]=1, and ack=1, and verify correct round-robin and credit behavior.
3) For minimum grant gap:
   a) Drive req[N-1:0]=0 for all except req[0]=1 (only requestor 0 active).
   b) For several cycles, alternate ack=0 and ack=1, observing that grant is not repeated without ack.
4) For maximum concurrency:
   a) Drive req[N-1:0]=1 (all requestors active).
   b) On each cycle, drive ack=1 (immediate ack for each grant), and observe gnt_w, gnt_id for at least N+2 cycles to see full round-robin progression.
5) No prio/prio_id/prio_upt activity during grant progression scenarios unless specified.","1) After both A and B reach credit=0, neither is granted until after refill latency; after refill, both are eligible and can be granted again.
2) No grants occur with credit=0.
3) Arbitration alternates between A and B as per round-robin policy after refill.
4) When only one requestor is active, grant is not repeated to the same requestor without an intervening ack; grant is re-issued only after ack=1.
5) With all requestors active and ack=1 each cycle, each requestor receives a grant exactly once before any are repeated (no starvation, no repeats without ack), and gnt_w/gnt_id advance in round-robin order.
6) No requestor is skipped or granted twice before all others are granted once.","Functional:
  - cp_concurrent_credit_zero: bins {A_zero&B_zero_same_cycle}.
  - cp_refill_sync: bins {both_refilled_same_cycle}.
  - cp_ack: bins {ack=0, ack=1}.
  - cp_grant_stability: bins {grant_held_no_ack, grant_reissued_after_ack}.
  - cp_req_pattern: bins {single_active, all_active}.
  - cp_ack_timing: bins {min_gap=1cycle}.
  - cp_grant_sequence: bins {no_repeat, round_robin_full_cycle}.
Cross:
  - cross_concurrent_zero_x_refill: cp_concurrent_credit_zero × cp_refill_sync.
  - cross_ack_x_grant: cp_ack × cp_grant_stability.
  - cross_req_pattern_x_grant_sequence: cp_req_pattern × cp_grant_sequence.
Code:
  - Concurrency, refill, grant FSM, pointer update, and round-robin logic coverage.",Credit-Based Scheduling and Replenishment Policy,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 9)]"
corner_simultaneous_and_back_to_back_ack_and_prio_update,"Verify that the design remains hazard-free when simultaneous assertion of prio_upt (priority update) and ack (grant acknowledge) occurs for different requestors in the same cycle, as well as when such simultaneous events occur in consecutive cycles (legal minimum inter-event gap). This tests both cross-requestor concurrency and pipeline/sequential logic boundaries, ensuring that all operations are processed correctly without hazards, lost updates, or grant corruption.","1) Assert rst=1 for at least 2 clk cycles, then deassert rst=0.
2) Drive req[0]=1 and req[1]=1 (all others 0) to enable both requestors.
3) Wait until gnt_id==0 (requestor 0 is granted).
4) On cycle N, assert ack=1 (for requestor 0), and simultaneously assert prio_upt=1, prio_id=1, prio=7 (mid value) to update requestor 1's priority.
5) On cycle N+1, assert ack=1 and prio_upt=1, prio_id=0, prio=5 (simultaneous for requestor 0).
6) On cycle N+2, assert ack=1 and prio_upt=1, prio_id=1, prio=10 (simultaneous for requestor 1).
7) Observe grant and priority behavior for at least 4 cycles after the last event.","1) Confirm that each requestor's grant is properly acknowledged and the next grant is issued per WRR policy, with no skipped or duplicated grants.
2) Confirm that each requestor's priority is updated correctly in the cycle of prio_upt, with no hazard, lost update, or delay.
3) Ensure no cross-requestor corruption: a grant/credit for one requestor is not affected by a priority update for another, and vice versa.
4) No pipeline hazard or race condition is observed in outputs (gnt_w, gnt_id).
5) No spurious grants or skipped cycles for any requestor.","Functional:
  - cp_simultaneous_diff_req: bin for cycles where ack==1 for gnt_id==A and prio_upt==1 for prio_id==B (A≠B).
  - cp_back_to_back_simultaneous: bin for two consecutive cycles with ack==1 && prio_upt==1.
  - cp_prio_values: bins for prio=5, prio=7, prio=10.
Cross:
  - cross_simultaneous_diff_req_x_prio_value.
  - cross_back_to_back_x_prio_values.
Code:
  - Statement/branch/toggle in cross-requestor update logic.
  - Pipeline/sequence coverage in grant and priority update logic.",Hazard-Free Simultaneous Priority Update and Grant Acknowledge,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 21)]"
corner_param_scaling_and_functional_edges,"Verify correct operation, resource scaling, and functional behavior at the legal minimum, just-above-minimum, and maximum values for all key parameters: N (requestor count), PRIORITY_W (priority width), CREDIT_W (credit counter width), and ID_BITS (requestor ID width). Assess the impact of parameter changes on area, fanout, bandwidth granularity, grant encoding, priority update, and credit handling. Ensure that the design scales as specified and preserves functional correctness at all resource and encoding edges.","For each parameter at its min, just-above-min, and max legal values (N: 1,2,32; PRIORITY_W: 1,2,4; CREDIT_W: 1,2,8; ID_BITS: 1 (N=2), 2 (N=4), 5 (N=32)):
 1) Instantiate the DUT with the parameter set accordingly (using top RTL values for max).
 2) After reset:
   a) For N: Drive req with single, all, and alternating active patterns; observe gnt_w, gnt_id.
   b) For PRIORITY_W: For each requestor, update prio to min, mid, and max values; drive all req active and observe grant frequency over cycles.
   c) For CREDIT_W: For each requestor, set prio to max and min, drive continuous req, observe credits decrement/refill, and ensure no overflow/underflow.
   d) For ID_BITS: For each prio_id, update priority and confirm only legal requestors are updated; for each grant, drive req with one bit set and observe gnt_id/gnt_w.
   e) For area/fanout: Confirm port widths (req, gnt_w, prio_id, gnt_id) match expected values for each configuration.
   f) For bandwidth: Measure grant frequency per requestor and confirm proportionality to priority.
 3) For each configuration, record the number of grants per requestor and confirm proportionality to priority.","1) Port widths match parameter values (e.g., req[N-1:0], gnt_id[ID_BITS-1:0]).
2) gnt_w width matches N and only legal one-hot values are asserted.
3) gnt_id and prio_id never exceed legal range (0 to N-1).
4) Only the addressed requestor's priority is updated.
5) Grant frequency is proportional to assigned priority (as per weighted round robin).
6) Credit counters never exceed (2^CREDIT_W)-1 or go below 0; refill occurs exactly when credits reach zero.
7) Grant is only issued when credits are non-zero.
8) No illegal encoding, out-of-bounds access, or protocol violations at any parameter edge.
9) No illegal fanout or resource overuse (e.g., no more than N grants per cycle).","Functional:
 - cp_param_combo: bins for all combinations of {N, PRIORITY_W, CREDIT_W, ID_BITS} at min, min+1, max.
 - cp_req_patterns: bins {single_active, all_active, alternating}.
 - cp_prio_value: bins {min=0, mid, max=(2^PRIORITY_W)-1}.
 - cp_credit_value: bins {min=0, max=(2^CREDIT_W)-1}.
 - cp_id_value: bins {min=0, max=N-1}.
 - cp_bandwidth: bins for grant frequency at min/max priority.
Cross:
 - cross_param_x_bandwidth: cp_param_combo × cp_bandwidth.
 - cross_N_x_req: cp_N × cp_req_patterns.
 - cross_PRIORITY_W_x_prio: cp_PRIORITY_W × cp_prio_value.
 - cross_CREDIT_W_x_credit: cp_CREDIT_W × cp_credit_value.
 - cross_ID_BITS_x_id: cp_ID_BITS × cp_id_value.
Code:
 - Array index, width, grant logic, priority update, credit counter, and resource scaling logic coverage for all legal parameterizations.",Parameterization Coverage and Constraints,"[('weighted_round_robin_mas.pdf', 16), ('weighted_round_robin_mas.pdf', 17)]"
corner_combinational_arbitration_1cycle_latency_min_max_requests,"Verify that the combinational arbitration logic produces a grant (gnt_w/gnt_id) with exactly 1-cycle latency for both the minimum (single requestor) and maximum (all requestors) legal request patterns. This exercises the pipeline's legal latency boundary and ensures no extra cycles are inserted in the arbitration stage, per spec.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst=0 to initialize.
2) For min request case:
   a) Drive req[N-1:0]=0...01 (only requestor N-1 active), all other inputs idle.
   b) Observe gnt_w/gnt_id on the next cycle.
   c) Acknowledge grant with ack=1 for one cycle, then deassert.
3) For max request case:
   a) Drive req[N-1:0]=all 1's (all requestors active), all other inputs idle.
   b) Observe gnt_w/gnt_id on the next cycle.
   c) Acknowledge grant with ack=1 for one cycle, then deassert.
4) Repeat with different single-bit and all-bits request patterns to cover both edges.","1) For each request pattern, check that gnt_w/gnt_id reflect the correct granted requestor(s) exactly 1 cycle after req is asserted, per round-robin/weight rules.
2) Check that no grant is issued before 1 cycle, and no extra cycles are inserted (no pipeline bubbles).
3) Confirm that ack correctly advances the grant to the next eligible requestor on the following cycle.","Functional:
  - cp_req_pattern: bins {min_req=single active, max_req=all active}.
  - cp_latency: bins {latency_1cycle}.
Cross:
  - cross_req_pattern_x_latency: cp_req_pattern × cp_latency.
Code:
  - Statement/branch/toggle in arbitration combinational logic and pipeline register.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 12)]"
corner_weighted_round_robin_highest_weight_just_inside_max,"Verify that a requestor with the highest legal priority value (prio=15, just inside 4-bit max) receives proportionally more grants than others, but does not monopolize bandwidth due to round-robin pointer enforcement. This exercises the legal upper edge of priority weight and fairness enforcement.","1) Apply clk and assert rst=1 for at least 2 cycles; deassert rst=0 to initialize.
2) Set prio=15 (max legal value for PRIORITY_W=4) for requestor 1 via prio/prio_id/prio_upt; set prio=1 for all others.
3) Drive req[N-1:0]=all 1's (all requestors active) for at least 20 cycles.
4) For each grant, drive ack=1 for one cycle.
5) Observe gnt_id/gnt_w over time to track grant distribution.","1) Check that requestor 1 receives more grants than others, proportional to its weight (prio+1).
2) Confirm that all requestors eventually receive grants (zero-starvation), i.e., no requestor is starved.
3) Ensure that no requestor receives more than (prio+1) consecutive grants (fairness enforcement).","Functional:
  - cp_prio_value: bins {prio_min=1, prio_max=15}.
  - cp_grant_distribution: bins {proportional, fair, starvation}.
Cross:
  - cross_prio_value_x_grant: cp_prio_value × cp_grant_distribution.
Code:
  - Priority decode, credit counter, and round-robin pointer coverage.",Combinational Arbitration and Sequential Update Pipeline,"[('weighted_round_robin_mas.pdf', 4), ('weighted_round_robin_mas.pdf', 12)]"
corner_priority_update_during_credit_refill,Verify that a priority update (prio_upt=1) for a requestor is accepted and correctly applied during the credit refill phase (when no eligible requestors exist and credits are being refilled from prio+1). This is a legal timing edge per the spec FSM.,"1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Drive req[N-1:0]=all 1's (all requestors active) and ack=1 until all credits are exhausted (no eligible requestors remain).
3) In the cycle when the FSM enters REPLENISH (credit refill), drive prio_upt=1, prio_id=X, prio=Y (choose any legal X, Y).
4) Continue driving req and observe gnt_id, gnt_w for grant behavior after refill.
5) Optionally, repeat for min and max prio values.","1) Priority update is applied during the refill phase and reflected in the new credit value (credit=prio+1).
2) Arbitration after refill reflects the updated priority for the affected requestor.
3) No illegal grant or missed update occurs.
4) gnt_id and gnt_w outputs are legal and consistent with updated priorities.","Functional:
  - cp_fsm_state: bins for ARBITRATION and REPLENISH.
  - cp_prio_upt_in_refill: bin for prio_upt=1 during REPLENISH.
  - cp_prio_val: bins for min, max, and mid values.
Cross:
  - cross_fsm_state_x_prio_upt: FSM state × prio_upt activity.
Code:
  - Priority register file write, credit refill logic, and arbitration after refill.",Priority Register File Sideband Update Functionality,"[('weighted_round_robin_mas.pdf', 13)]"
corner_priority_update_with_all_requestors_active_and_max_contention,Verify that a priority update for one requestor during a cycle when all N=32 requestors are actively requesting does not interfere with arbitration or cause starvation. This is a legal concurrency and resource edge case.,"1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) Set req[0..31]=1 (all requestors active).
3) At cycle N, drive prio_id=15, prio=12, prio_upt=1 (update mid-index requestor to high priority).
4) For all other cycles, prio_upt=0.
5) Drive ack=1 for each grant.
6) Observe gnt_w, gnt_id outputs for correct arbitration and grant distribution.","1) Confirm that arbitration continues without stall during/after the priority update.
2) After update, requestor #15 receives grants at a higher frequency (proportional to prio=12) compared to before.
3) All requestors continue to receive grants (no starvation), and grant outputs are legal.","Functional:
  - cp_all_req_active: bins {all_ones} for req input.
  - cp_prio_value: bins {12}.
  - cp_prio_id: bins {15}.
Cross:
  - cross_all_req_active_x_prio_update: all requestors active × priority update event.
Code:
  - Arbitration logic, priority register update, grant output.",Runtime Priority Update Without Arbitration Interference,"[('weighted_round_robin_mas.pdf', 4)]"
corner_minimum_clock_period_synchronous_operation,"Verify correct operation at the minimum legal clk period (maximum frequency), ensuring all state transitions and outputs remain synchronous and stable. This is a corner because it stresses the timing closure and synchronous design at the legal performance edge.","1) Drive clk at the minimum legal period (as defined by implementation timing constraints; use the fastest supported by the design).
2) Assert rst=1 for 2 cycles, then deassert rst=0.
3) Immediately after rst deassertion, drive req with two adjacent bits set (e.g., req=32'b000...11), all other inputs 0.
4) On each clk rising edge, toggle ack to 1 for one cycle after a grant is observed, then back to 0.
5) Continue for several arbitration cycles, updating req pattern to exercise different requestors.
6) Observe gnt_w and gnt_id on every clk rising edge.","1) All output transitions (gnt_w, gnt_id) occur only on clk rising edge.
2) No output glitches or meta-stable values at any time.
3) Arbitration and grant behavior matches spec (one-hot grant, correct gnt_id, round-robin/fairness).
4) No missed or duplicated grants at high frequency.","Functional:
  - cp_clk_period: bins {min, mid, max} (here, min period).
  - cp_req_pattern: bins for different adjacent and non-adjacent req patterns.
  - cp_ack_timing: bins {ack_immediate, ack_delayed}.
Cross:
  - cross_clk_period_x_req_pattern: cp_clk_period × cp_req_pattern.
Code:
  - Toggle/branch coverage in arbitration and grant logic at high speed.",Single Clock and Power Domain Operation,"[('weighted_round_robin_mas.pdf', 12)]"
corner_internal_state_observability_min_max_priority_and_credit,"Verify that the observable outputs (gnt_w, gnt_id) reflect correct internal state transitions when per-requestor priorities and credits are set to their minimum and maximum legal values, and that arbitration and scheduling behavior at these boundaries is externally visible. This is a corner because it exercises the legal extremes of the priority and credit configuration, which directly affect grant decisions and fairness.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the design (per reset/startup sequence).
2) For each requestor i in 0..N-1:
   a) Set prio_id=i, prio=0 (min), prio_upt=1 for one cycle to set minimum priority; then prio_upt=0.
   b) Issue req[i]=1 (all others 0), ack=0, and observe gnt_w/gnt_id for grant.
   c) Repeat with prio=15 (max for PRIORITY_W=4), prio_upt=1 for one cycle, then prio_upt=0.
   d) Issue req[i]=1 (all others 0), ack=0, and observe gnt_w/gnt_id for grant.
3) For at least one requestor, repeatedly issue grants (req=1, ack=1) until credit is exhausted and observe refill behavior (per spec: refill from prio+1 when exhausted).","1) For each priority setting (min=0, max=15):
   - When req[i]=1 and all others 0, gnt_w must be one-hot for i, and gnt_id must equal i.
2) After credit is exhausted (after prio+1 grants), no grant is issued until refill occurs, then grant resumes.
3) Grant sequence and latency must match spec (1 cycle normal, 2 cycles on refill).
4) No grant is issued to a requestor with zero credit until refill.
5) No out-of-bounds grant IDs or grant vectors.","Functional:
  - cp_prio: bins {min=0, max=15} for prio input.
  - cp_credit: bins {min=0, max=255} for credit (via grant/ack cycles).
  - cp_refill: bins {refill_triggered, no_refill}.
Cross:
  - cross_prio_x_credit: cp_prio × cp_credit.
  - cross_refill_x_grant: cp_refill × observed grant behavior.
Code:
  - Toggle/branch coverage in priority/credit update and arbitration logic.",Internal State Observability for Debug and QoS,"[('weighted_round_robin_mas.pdf', 10)]"
corner_round_robin_pointer_wrap_and_state_observability,"Verify that the observable grant outputs (gnt_w, gnt_id) reflect correct round-robin pointer wrap-around behavior at the legal boundary (last requestor to first), ensuring fairness and correct scheduling at the pointer's legal limits. This is a corner because it exercises the pointer's wrap condition, which is critical for fairness and starvation avoidance.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0 to initialize the design.
2) Set all priorities to a mid-value (e.g., prio=8) for all requestors using prio_id and prio_upt.
3) For N consecutive cycles, assert req[i]=1 (for i=0..N-1, one at a time), ack=1, and observe gnt_w/gnt_id.
4) After reaching the last requestor (i=N-1), continue with req[0]=1, ack=1, and observe if the pointer wraps and grants to requestor 0 again.
5) Repeat with all req asserted simultaneously to check fairness and pointer advancement under full load.","1) Grant sequence must follow round-robin order: 0,1,...,N-1,0,1,...
2) After N grants, pointer wraps and grants to requestor 0 again.
3) gnt_w is one-hot for the granted requestor; gnt_id matches the granted index.
4) Under full-load (all req=1), each requestor receives a grant in turn, no starvation.
5) No skipped or repeated grants outside the expected order.","Functional:
  - cp_pointer: bins {first=0, last=N-1, wrap=0 after N-1}.
  - cp_req_pattern: bins {single, all} for req vector.
Cross:
  - cross_pointer_x_req: cp_pointer × cp_req_pattern.
Code:
  - Toggle/branch coverage in pointer increment and wrap logic.",Internal State Observability for Debug and QoS,"[('weighted_round_robin_mas.pdf', 10)]"
corner_no_error_output_on_all_legal_inputs,"Verify that under all legal input conditions, including boundary values for all input ports, the design does not assert any error reporting, ECC, or parity protection signals, as none are implemented per spec. This is a corner because it checks the absence of error signaling at the legal operational extremes.","1) Apply clk with normal frequency; assert rst=1 for 8 cycles, then deassert rst=0.
2) For each input port (req[N-1:0], prio[PRIORITY_W-1:0], prio_id[ID_BITS-1:0], ack, prio_upt):
   a) Drive all legal minimum values (e.g., all zeros).
   b) Drive all legal maximum values (e.g., all ones for each field).
   c) For vectors, drive single-hot, all-hot, and alternating patterns within legal range.
   d) For prio_upt, toggle at minimum and maximum legal intervals.
3) Observe all output ports (gnt_id, gnt_w) for any indication of error or unexpected behavior.
4) Repeat for at least 2 full arbitration cycles per input pattern.","1) Confirm that no output port (gnt_id, gnt_w) ever indicates an error state (e.g., no reserved/illegal values, no stuck outputs).
2) Confirm that no unlisted error, ECC, or parity output appears (since none are present per port list).
3) Scoreboard: For each legal input, outputs must remain within legal value ranges and never indicate error or protection features.","Functional:
  - cp_req: bins {all_zeros, all_ones, single_hot, alternating} for req[N-1:0].
  - cp_prio: bins {min=0, max=2^PRIORITY_W-1} for prio.
  - cp_prio_id: bins {min=0, max=2^ID_BITS-1} for prio_id.
  - cp_prio_upt: bins {no_update, update_every_cycle, update_max_gap}.
Cross:
  - cross_input_patterns: cp_req × cp_prio × cp_prio_id × cp_prio_upt.
Code:
  - Toggle/branch coverage in output logic for all input combinations.",No Internal Error Reporting or ECC,"[('weighted_round_robin_mas.pdf', 14)]"
corner_grant_output_encoding_consistency_min_max_id,"Verify that at the legal minimum (ID=0) and maximum (ID=N-1) requestor indices, the one-hot grant output (gnt_w) and encoded grant ID (gnt_id) are always consistent. This exercises the encoding logic at the edges of the requestor range, a classic corner for encoding/decoding errors.","1) Apply clk and assert rst=1 for at least 2 cycles, then deassert rst=0.
2) For each of the following cases:
   a) Set req to only bit 0 high (req=1 at LSB, others 0), all other inputs idle. Wait 1 cycle.
   b) Set req to only bit N-1 high (req=1 at MSB, others 0), all other inputs idle. Wait 1 cycle.
3) For each case, observe gnt_w and gnt_id on the next cycle.
4) For each grant, drive ack=1 for one cycle to complete the handshake, then deassert.
5) Idle for 2 cycles between cases.","1) When req[0]=1 and all others 0, gnt_w==1 at LSB and gnt_id==0.
2) When req[N-1]=1 and all others 0, gnt_w==1 at MSB and gnt_id==N-1.
3) For both, only one bit of gnt_w is high, and gnt_id matches the index of the high bit.
4) No spurious grants or glitches on gnt_w/gnt_id during or after ack.","Functional:
  - cp_req_idx: bins {min=0, max=N-1}.
  - cp_gnt_id: bins {min=0, max=N-1}.
  - cp_gnt_w: bins {min=1<<0, max=1<<(N-1)}.
Cross:
  - cross_req_idx_x_gnt_id: cp_req_idx × cp_gnt_id.
Code:
  - Statement/branch/toggle in grant encoding logic for min/max indices.",Grant Output and Credit Update Consistency,"[('weighted_round_robin_mas.pdf', 12), ('weighted_round_robin_mas.pdf', 17)]"
corner_fsm_arbitration_with_minimum_and_maximum_priority_weights,"Verify FSM operation at the legal extremes of priority weights: minimum (0) and maximum (15, for PRIORITY_W=4). This is a corner because it tests the FSM's ability to handle the smallest and largest legal credit refills and grant cycles.","1) Assert rst=1 for at least 2 clk cycles, then deassert rst=0.
2) For requestor 0, set prio_id=0, prio=0, prio_upt=1 (minimum priority); for requestor 1, set prio_id=1, prio=15, prio_upt=1 (maximum priority).
3) Set req[0]=1, req[1]=1, others=0; drive ack=1 when gnt_w[0]=1 or gnt_w[1]=1.
4) Observe grant cycling: requestor 0 should be granted once per refill, requestor 1 up to 16 times per refill.
5) After all credits are exhausted, observe FSM transition to REPLENISH and refill credits to prio+1 for each requestor.","1) Check that requestor 0 is granted only once per refill cycle, and requestor 1 is granted 16 times per refill cycle.
2) Confirm that after all credits are exhausted, FSM transitions to REPLENISH and refills credits to prio+1 (1 for prio=0, 16 for prio=15).
3) Ensure correct grant sequencing and no starvation.
4) Latency from last grant to next grant after refill matches spec (2 cycles).","Functional:
  - cp_priority_weight: bins {min=0, max=15} (for PRIORITY_W=4).
  - cp_grant_count: bins {min=1, max=16} (grants per refill cycle).
  - cp_fsm_transition: bins {arbitration_to_replenish, replenish_to_arbitration}.
Cross:
  - cross_priority_x_grant: cp_priority_weight × cp_grant_count.
Code:
  - Priority decode, credit refill, FSM transition.",Global Arbitration FSM State Machine Operation,"[('weighted_round_robin_mas.pdf', 10)]"
