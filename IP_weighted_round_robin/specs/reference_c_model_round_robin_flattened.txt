--- directory structure ---
.
├── CMakeLists.txt
├── flattened.txt
├── flatten.py
├── test_0.cpp
├── weighted_round_robin.cpp
├── weighted_round_robin.h
├── weighted_round_robin_ports.h
└── Weighted_Round_Robin_readme.txt

0 directories, 9 files


--- Contents of weighted_round_robin.cpp ---

#include "weighted_round_robin.h"
#include <sstream>

weighted_round_robin::weighted_round_robin()
    : libtb::TopLevel("t"),
      uut_("uut")
#define __declare_port(__port, __type) , __port##_(#__port)
          WEIGHTED_ROUND_ROBIN_PORTS(__declare_port)
#undef __declare_port
{
  LIBTB_REPORT_INFO("FOO");
  bind_rtl();
  SC_METHOD(m_checker);
  sensitive << e_tb_sample();
  dont_initialize();

  wave_on("foo.vcd", uut_);
}

weighted_round_robin::~weighted_round_robin() {}

void weighted_round_robin::bind_rtl() {
  uut_.clk(clk());
  uut_.rst(rst());
#define __bind_signals(__port, __type) uut_.__port(__port##_);
  WEIGHTED_ROUND_ROBIN_PORTS(__bind_signals)
#undef __bind_signals
}

void weighted_round_robin::m_checker() {
  ack_ = true;
  if (req_ != 0) {
    const ReqT gnt = gnt_w_;
    const unsigned idx = libtb::ffs(gnt);
    if (gnt != 0) {
      const bool is_valid = (prio_map_[idx] > 0 && (req_ & (1 << idx)));
      if (!is_valid) LIBTB_REPORT_ERROR("Invalid GNT asserted");
    }

    const unsigned gnt_count = libtb::pop_count(gnt);
    if (gnt_count != 1 && prio_map_[idx] != 0) {
        std::stringstream ss;
        ss << "Invalid number of grants: " << gnt_count;
        LIBTB_REPORT_ERROR(ss.str());
    }

    if (gnt != 0)
        freq_[libtb::ffs(gnt)]++;
  }
}

void weighted_round_robin::report() {
  std::stringstream ss;

  ss << "Number of Grant lines: " << freq_.size();
  LIBTB_REPORT_INFO(ss.str());

  unsigned total = 0;
  for (auto g : freq_) total += g.second;

  for (int i = 0; i < OPT_N; i++) {
    ss.str("");

    int order = 0;
    if (freq_.count(i)) order = ((double)freq_[i] / (double)total) * 100;
    ss << i << "| " << std::string(order, '*');
    LIBTB_REPORT_INFO(ss.str());
  }
}

void weighted_round_robin::b_prio_idle() {
  prio_upt_ = false;
  prio_ = PriorityT{};
  prio_id_ = IdT{};
}

void weighted_round_robin::reset_perf() { freq_.clear(); }

void weighted_round_robin::b_prio_set(IdT id, PriorityT p) {
  prio_upt_ = true;
  prio_ = p;
  prio_id_ = id;
  {
    std::stringstream ss;
    ss << "Setting priority ID=" << id << " P=" << p;
    LIBTB_REPORT_DEBUG(ss.str());
  }
  t_wait_posedge_clk();
  prio_map_[id] = p;
  b_prio_idle();
}


--- Contents of weighted_round_robin_ports.h ---

#pragma once

#define WEIGHTED_ROUND_ROBIN_PORTS(__func)      \
    __func(req, ReqT)                           \
    __func(ack, bool)                           \
    __func(gnt_w, ReqT)                         \
    __func(gnt_id, IdT)                         \
    __func(prio, PriorityT)                     \
    __func(prio_id, IdT)                        \
    __func(prio_upt, bool)


--- Contents of test_0.cpp ---

#include <libtb.h>
#include "weighted_round_robin.h"

struct test_0 : public weighted_round_robin {
  SC_HAS_PROCESS(test_0);
  test_0() {}
  bool run_test() {
    LIBTB_REPORT_INFO("Stimulus begins");
    b_prio_idle();

    //    b_prio_set(2, 1);
    for (int i = 0; i < OPT_N; i++) b_prio_set(i, i % 2 == 0);

    reset_perf();
    int ROUNDS = 100;
    while (ROUNDS--) round();

    report();

    LIBTB_REPORT_INFO("Stimulus ends");
    return true;
  }

  void round() {
      const ReqT req_vector = libtb::ones<ReqT>();

      int N = 100;
      req_ = req_vector;
      while (N--)
          t_wait_posedge_clk();
  }
};

int sc_main(int argc, char **argv) {
  using namespace libtb;
  test_0 t;
  LibTbContext::init(argc, argv);
  return LibTbContext::start();
}


--- Contents of CMakeLists.txt ---

LIBTB_BUILD_TB(weighted_round_robin weighted_round_robin.cpp)
LIBTB_BUILD_TEST(weighted_round_robin test_0 test_0.cpp)


--- Contents of Weighted_Round_Robin_readme.txt ---
# Weighted Round Robin

[![Build Status](https://travis-ci.org/stephenry/weighted_round_robin.svg?branch=master)](https://travis-ci.org/stephenry/weighted_round_robin)

## Introduction

Round Robin (RR) arbitration is a common scheme used to fairly distribute work
across a number of agents. A number of agents request access to some shared
resource and are in turn granted access in a circular manner.

For the majority of day-to-day arbitration needs, fixed priority arbitration
schemes are sufficient. They are limited however by the fact that all requestors
have fixed priority and therefore respond with equal weighting to all
requestors. For some use cases, it is desireable to weigh certain requestors
over others. There are a variety of ways that this can be achieved.

* __Duplicated request lines__ High priority agents may be allocated more than
  one request line. By consequence of this, a single agent may be granted more
  frequently than others requestors. In addition, by intelligent allocation of
  request lines, grant distribution may be distributed as desired over
  time. This scheme, although simple, is inherently static in nature, and there
  is no way to dynamically alter weights of agents in situ (at least trivially).
* __Request Counters__ Alternatively, request can be masked against a
  counter. For each grant, the request counter is decremented. When the count
  reaches zero, the agent is no longer eligible for arbitration. Such a process
  continues until all counters have been exhausted. This scheme, although
  dynamic, does not ensure fairness between agents, as grants are not equally
  distributed over time and requestors may experience long latency between
  requests.
* __Dynamically Weighted Arbiters [PDF][1]__ Finally, requestors can be
  attributed binary priorites. Arbitration procedes by walking through indexes
  in the priority range, and performing standard RR arbitration between
  requestors in a particular round. This is the approach in this implementation
  and is presented formally in the reference.

## System Requirements
* cmake >= 3.2
* systemc >= 2.3.1
* verilator >= 3.9
* clang >= 3.9

## Build Steps
~~~~
git clone https://github.com/stephenry/weighted_round_robin.git
cd weighted_round_robin
git submodule update --init --recursive
mkdir build
cd build
cmake ../
make
~~~~

## Parameterizations

* __N__ The number of requestors.

* __PRIORITY_W__ The width (in bits) of the priority assigned to each requestor.

## Memory Requirements

All internal state is retained in FLOPS are as such there are no dependencies
upon external RAM macros.

## Micro-architecture

Priorities are uploaded using the PRIO interface. There are no
micro-architectural limitations upon when priorities may be modified however the
effect that this has on arbitration over the short-term is undefined.

The micro-architecture of the arbitration mechanism is discussed in detail
in [PDF][1] and therefore shall not be repeated here.

## Error handling

There are no error conditions.

## Performance

Requests are updated on a cycle-by-cycle basis. Grants are retained until
explicitly acknowledged by the external agent.

## Verification Methodology

The verification environment is self-checking and verifies the following
properties:

* No grant is made to a requestor that is not asserted.

* No grant is made to a requestor that as nil priority (disabled).

For a given input distribution, grant count is tabulated and graphed. The
expected number of grants over the period of interest can be computed statically
and is checked against the measured result.

### Tests

* __test_0__ Configure a static priority distribution and assert
  requests. Tabulate received grants.

[1]: http://ieeexplore.ieee.org/document/105173/?tp=&arnumber=105173&url=http:%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D105173

--- Contents of weighted_round_robin.h ---

#pragma once

#include <libtb.h>
#include "Vweighted_round_robin.h"
#include "weighted_round_robin_ports.h"
#include <map>

// Opts:
constexpr uint32_t OPT_N = 8;
constexpr uint32_t OPT_PRIORITY_W = 4;

using ReqT = vluint32_t;
using IdT = vluint32_t;
using PriorityT = vluint32_t;

struct weighted_round_robin : public libtb::TopLevel {
  SC_HAS_PROCESS(weighted_round_robin);
  weighted_round_robin();
  virtual ~weighted_round_robin();

 protected:
  void b_prio_idle();
  void b_prio_set(IdT id, PriorityT p);
  void report();
  void reset_perf();

 private:
  void bind_rtl();
  void m_checker();
  Vweighted_round_robin uut_;

  std::map<IdT, int> freq_;
  std::map<IdT, PriorityT> prio_map_;

 protected:
#define __define_signals(__port, __type) sc_core::sc_signal<__type> __port##_;
  WEIGHTED_ROUND_ROBIN_PORTS(__define_signals)
#undef __define_signals
};


